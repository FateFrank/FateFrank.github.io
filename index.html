<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fatefrank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Seif Zheng&#39;s blog">
<meta property="og:url" content="http://fatefrank.github.io/index.html">
<meta property="og:site_name" content="Seif Zheng&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Seif Zheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fatefrank.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Seif Zheng's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seif Zheng's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日积月累，水滴石穿</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fatefrank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/MyBatis%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/MyBatis%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Mybatis 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：16:27:14" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h3><ol>
<li>创建 SqlSessionFactory 对象。</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象。</li>
<li>通过 SqlSession 获得 Mapper 代理对象。</li>
<li>通过 Mapper 代理对象，执行数据库操作。</li>
<li>执行成功，则使用 SqlSession 提交事务。</li>
<li>执行失败，则使用 SqlSession 回滚事务。</li>
<li>最终，关闭会话。</li>
</ol>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</h3><p><code>$&#123;&#125;</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>$&#123;driver&#125;</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure>

<p><code>$&#123;&#125;</code> 也可以对传递进来的参数<strong>原样拼接</strong>在 SQL 中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;getSubject3&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Subject&quot;&gt;</span><br><span class="line">    SELECT * FROM subject</span><br><span class="line">    WHERE id &#x3D; $&#123;id&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际场景下，不推荐这么做。因为，可能有 SQL 注入的风险。</li>
</ul>
<hr>
<p><code>#&#123;&#125;</code> 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#&#123;&#125;</code> 是<strong>预编译处理</strong>，可以有效防止 SQL 注入，提高系统安全性。</p>
<hr>
<p>另外，<code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的取值方式非常方便。例如：<code>#&#123;item.name&#125;</code> 的取值方式，是使用反射，从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 。</p>
<h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h3><p>第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Order&quot;</span>&gt;</span> </span><br><span class="line">    SELECT order_id AS id, order_no AS orderno, order_price AS price </span><br><span class="line">    FROM orders </span><br><span class="line">    WHERE order_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里，艿艿还有几点建议：<ul>
<li>1、数据库的关键字，统一使用大写，例如：<code>SELECT</code>、<code>AS</code>、<code>FROM</code>、<code>WHERE</code> 。</li>
<li>2、每 5 个查询字段换一行，保持整齐。</li>
<li>3、<code>,</code> 的后面，和 <code>=</code> 的前后，需要有空格，更加清晰。</li>
<li>4、<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等，单独一行，高端大气。</li>
</ul>
</li>
</ul>
<hr>
<p>第二种，是第一种的特殊情况。大多数场景下，数据库字段名和实体类中的属性名差，主要是前者为<strong>下划线风格</strong>，后者为<strong>驼峰风格</strong>。在这种情况下，可以直接配置如下，实现自动的下划线转驼峰的功能。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就说，约定大于配置。非常推荐！</p>
<hr>
<p>第三种，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;me.gacl.domain.Order&quot;</span> <span class="attr">id</span>=<span class="string">”OrderResultMap”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">!–-</span> 用 <span class="attr">id</span> 属性来映射主键字段 <span class="attr">-</span>–&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">!–-</span> 用 <span class="attr">result</span> 属性来映射非主键字段，<span class="attr">property</span> 为实体类属性名，<span class="attr">column</span> 为数据表中的属性 <span class="attr">-</span>–&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderNo&quot;</span> <span class="attr">column</span> =<span class="string">&quot;order_no&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_price&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;OrderResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM orders </span><br><span class="line">    WHERE order_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此处 <code>SELECT *</code> 仅仅作为示例只用，实际场景下，千万千万千万不要这么干。用多少字段，查询多少字段。</li>
<li>相比第一种，第三种的<strong>重用性</strong>会高一些。</li>
</ul>
<h3 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h3><p>如下部分，可见 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">《MyBatis 文档 —— Mapper XML 文件》</a> ：</p>
<ul>
<li><code>&lt;cache /&gt;</code>标签，给定命名空间的缓存配置。</li>
<li><code>&lt;cache-ref /&gt;</code> 标签，其他命名空间缓存配置的引用。</li>
<li><code>&lt;resultMap /&gt;</code> 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><del><code>&lt;parameterMap /&gt;</code> 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</del></li>
<li><code>&lt;sql /&gt;</code>标签，可被其他语句引用的可重用语句块。</li>
<li><code>&lt;include /&gt;</code> 标签，引用 <code>&lt;sql /&gt;</code> 标签的语句。</li>
<li><code>&lt;selectKey /&gt;</code> 标签，不支持自增的主键生成策略标签。</li>
</ul>
<p>如下部分，可见 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> ：</p>
<ul>
<li><code>&lt;if /&gt;</code></li>
<li><code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code></li>
<li><code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code></li>
<li><code>&lt;foreach /&gt;</code></li>
<li><code>&lt;bind /&gt;</code></li>
</ul>
<h3 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h3><ul>
<li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li>
<li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li>
<li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li>
</ul>
<p>如上的内容，更加详细的话，请看 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> 文档。</p>
<h3 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h3><p>Mapper 接口，对应的关系如下：</p>
<ul>
<li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。</li>
</ul>
<p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p>
<p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p>
<p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：</p>
<p><img src="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png" alt="流程"></p>
<ul>
<li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得 MappedStatement 对象</span></span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        executor.query(ms, wrapCollection(parameter), rowBounds, handler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整的流程，胖友可以慢慢撸下 MyBatis 的源码。</li>
</ul>
</li>
</ul>
<hr>
<p>Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p>
<h3 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h3><p>接口绑定有三种实现方式：</p>
<p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p>
<p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p>
<p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p>
<hr>
<p>实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p>
<h3 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h3><p>不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。</p>
<p>原因就是，<code>namespace + id</code> 是作为 <code>Map</code> 的 key 使用的。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p>
<h3 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h3><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p>
<p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方式一，使用 useGeneratedKeys + keyProperty 属性</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO person(name, pswd)</span><br><span class="line">    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">// 方式二，使用 `<span class="tag">&lt;<span class="name">selectKey</span> /&gt;</span>` 标签</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    INSERT INTO person(name, pswd)</span><br><span class="line">    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其中，<strong>方式一</strong>较为常用。</li>
</ul>
<hr>
<p>Oracle 有两种方式，<strong>序列</strong>和<strong>触发器</strong>。因为艿艿自己不了解 Oracle ，所以问了银行的朋友，他们是使用<strong>序列</strong>。而基于<strong>序列</strong>，根据 `` 执行的时机，也有两种方式，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这个是创建表的自增序列</span><br><span class="line">CREATE SEQUENCE student_sequence</span><br><span class="line">INCREMENT BY 1</span><br><span class="line">NOMAXVALUE</span><br><span class="line">NOCYCLE</span><br><span class="line">CACHE 10;</span><br><span class="line"></span><br><span class="line">// 方式一，使用 `<span class="tag">&lt;<span class="name">selectKey</span> /&gt;</span>` 标签 + BEFORE</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;student_id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">      select student_sequence.nextval FROM dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">     INSERT INTO student(student_id, student_name, student_age)</span><br><span class="line">     VALUES (#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 方式二，使用 `<span class="tag">&lt;<span class="name">selectKey</span> /&gt;</span>` 标签 + AFTER</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.threeti.to.ZoneTO&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span> &gt;</span></span><br><span class="line">      SELECT SEQ_ZONE.CURRVAL AS id FROM dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    INSERT INTO TBL_ZONE (ID, NAME ) </span><br><span class="line">    VALUES (SEQ_ZONE.NEXTVAL, #&#123;name,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>他们使用第一种方式，没有具体原因，可能就没什么讲究吧。嘿嘿。</li>
</ul>
<p>至于为什么不用<strong>触发器</strong>呢？朋友描述如下：</p>
<blockquote>
<p>朋友：触发器不行啊，我们这边原来也有触发器，一有数据更改就会有问题了呀<br>艿艿：数据更改指的是？<br>朋友：就改线上某几条数据<br>艿艿：噢噢。手动改是吧？<br>朋友：不行~</p>
</blockquote>
<hr>
<p>当然，数据库还有 SQLServer、PostgreSQL、DB2、H2 等等，具体的方式，胖友自己 Google 下噢。</p>
<p>关于如何获取自动生成的(主)键值的<strong>原理</strong>，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/executor-3/">《精尽 MyBatis 源码分析 —— SQL 执行（三）之 KeyGenerator》</a> 。</p>
<h3 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h3><p>能，JDBC 都能做，Mybatis 当然也能做。</p>
<h3 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h3><p>第一种，使用 Map 集合，装载多个参数进行传递。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用方法</span><br><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap();</span><br><span class="line">map.put(&quot;start&quot;, start);</span><br><span class="line">map.put(&quot;end&quot;, end);</span><br><span class="line">return studentMapper.selectStudents(map);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mapper 接口</span><br><span class="line">List&lt;Student&gt; selectStudents(Map&lt;String, Object&gt; map);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mapper XML 代码</span><br><span class="line">&lt;select id&#x3D;&quot;selectStudents&quot; parameterType&#x3D;&quot;Map&quot; resultType&#x3D;&quot;Student&quot;&gt;</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM students </span><br><span class="line">    LIMIT #&#123;start&#125;, #&#123;end&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>显然，这不是一种优雅的方式。</li>
</ul>
<hr>
<p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="keyword">return</span> studentMapper.selectStudents(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper 接口</span></span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectStudents</span><span class="params">(<span class="meta">@Param(&quot;start&quot;)</span> Integer start, <span class="meta">@Param(&quot;end&quot;)</span> Integer end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper XML 代码</span></span><br><span class="line">&lt;select id=<span class="string">&quot;selectStudents&quot;</span> resultType=<span class="string">&quot;Student&quot;</span>&gt;</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM students </span><br><span class="line">    LIMIT #&#123;start&#125;, #&#123;end&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>推荐使用这种方式。</li>
</ul>
<hr>
<p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="keyword">return</span> studentMapper.selectStudents(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper 接口</span></span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectStudents</span><span class="params">(Integer start, Integer end)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper XML 代码</span></span><br><span class="line">&lt;select id=<span class="string">&quot;selectStudents&quot;</span> resultType=<span class="string">&quot;Student&quot;</span>&gt;</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM students </span><br><span class="line">    LIMIT #&#123;param1&#125;, #&#123;param2&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#&#123;param1&#125;</code>、<code>#&#123;param2&#125;</code>、<code>#&#123;param3&#125;</code> 不断向下。</li>
</ul>
<h3 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h3><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p>
<ul>
<li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li>
<li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 `` 来设置。</li>
</ul>
<p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更佳的方式是，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATUS_GOOD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATUS_BETTER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATUS_BEST = <span class="number">3</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p>
<p>TypeHandler 有两个作用：</p>
<ul>
<li>一是，完成从 javaType 至 jdbcType 的转换。</li>
<li>二是，完成 jdbcType 至 javaType 的转换。</li>
</ul>
<p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p>
<p>关于 TypeHandler 的<strong>原理</strong>，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/type-package/">《精尽 MyBatis 源码分析 —— 类型模块》</a> 。</p>
<h3 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p>
<ul>
<li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li>
<li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li>
</ul>
<hr>
<p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p>
<p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p>
<hr>
<p>这块的源码解析，可见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/executor-1">《精尽 MyBatis 源码分析 —— SQL 执行（一）之 Executor》</a> 。</p>
<h3 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h3><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span> </span><br><span class="line">    INSERT INTO users(name) </span><br><span class="line">    VALUES (#&#123;value&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，调用该 Mapper 接口方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建要插入的用户的名字的数组</span></span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;占小狼&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;朱小厮&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;徐妈&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;飞哥&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动提交</span></span><br><span class="line">    <span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获得 Mapper 对象</span></span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 循环插入</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            mapper.insertUser(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交批量操作</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO [表名]([列名],[列名]) </span><br><span class="line">VALUES</span><br><span class="line">([列值],[列值])),</span><br><span class="line">([列值],[列值])),</span><br><span class="line">([列值],[列值]));</span><br></pre></td></tr></table></figure>

<ul>
<li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li>
</ul>
<p>这两种方式的性能对比，可以看看 [《<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cce617be9f9e">实验]mybatis批量插入方式的比较》</a> 。</p>
<h3 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h3><p>内容有些长，直接参见 <a target="_blank" rel="noopener" href="https://tech.meituan.com/mybatis_cache.html">《聊聊 MyBatis 缓存机制》</a> 一文。</p>
<hr>
<p>这块的源码解析，可见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/cache-package">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p>
<h3 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p>
<p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。</p>
<hr>
<p>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code> 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p>
<hr>
<p>这块的源码解析，可见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/executor-5">《 精尽 MyBatis 源码分析 —— SQL 执行（五）之延迟加载》</a> 文章。</p>
<h3 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h3><blockquote>
<p>艿艿：这道题有点难度。理解倒是好理解，主要那块源码的实现，艿艿看的有点懵逼。大体的意思是懂的，但是一些细节没扣完。</p>
</blockquote>
<p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p>
<blockquote>
<p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p>
</blockquote>
<ul>
<li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xzm_rainbow/article/details/15336959">《MyBatis：多对一表关系详解》</a> 。</li>
<li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/eson_15/article/details/51655188">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li>
</ul>
<hr>
<p>关联对象查询，有两种实现方式：</p>
<blockquote>
<p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p>
</blockquote>
<ul>
<li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li>
<li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li>
</ul>
<p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的<code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p>
<table>
<thead>
<tr>
<th align="left">t_id</th>
<th align="left">t_name</th>
<th align="left">s_id</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">38</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">39</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">40</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">41</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">42</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">teacher</td>
<td align="left">43</td>
</tr>
</tbody></table>
<h3 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h3><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p>
<p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p>
<hr>
<p>编写一个 MyBatis 插件的步骤如下：</p>
<ol>
<li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li>
<li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li>
<li>最后，在配置文件中配置你编写的插件。</li>
</ol>
<p>具体的，可以参考 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">《MyBatis 官方文档 —— 插件》</a> 。</p>
<hr>
<p>插件的详细解析，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/plugin-1">《精尽 MyBatis 源码分析 —— 插件体系（一）之原理》</a> 。</p>
<h3 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p>
<p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p>
<ul>
<li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li>
<li>也可以使用分页插件来完成数据库分页。</li>
</ul>
<p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p>
<hr>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p>
<p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a></li>
</ul>
<p>从现在看来，<a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 逐步使用的更加广泛。</p>
<p>关于 MyBatis 分页插件的原理深入，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/plugin-2">《精尽 MyBatis 源码分析 —— 插件体系（二）之 PageHelper》</a> 。</p>
<h3 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h3><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p>
<p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p>
<p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。</p>
<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p>
<ul>
<li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li>
<li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li>
</ul>
<p>另外，在 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/96171e647885">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p>
<p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a target="_blank" rel="noopener" href="http://mp.baomidou.com/">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p>
<h3 id="JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p>
<p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p>
<hr>
<p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p>
<hr>
<p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p>
<p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p>
<hr>
<p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p>
<p>当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p>
<h3 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h3><blockquote>
<p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p>
</blockquote>
<ol>
<li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li>
<li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li>
<li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code>&lt;resultMap /&gt;</code> 里面配置。</li>
</ol>
<h3 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h3><blockquote>
<p>这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<p>可能有一些绕，胖友可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/builder-package-1">《精尽 MyBatis 源码解析 —— MyBatis 初始化（一）之加载 mybatis-config》</a> 。</p>
<p>此处，我们在引申一个问题，Spring IOC 中，存在互相依赖的 Bean 对象，该如何解决呢？</p>
<p>同样使用了类似的手法，做解析标记，答案见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a> 。</p>
<h3 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h3><blockquote>
<p>这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p>
<p>在 XML Mapper 文件中：</p>
<ul>
<li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li>
<li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li>
<li>每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/Spring%20MVC%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/Spring%20MVC%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring MVC 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：14:27:33" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>推荐去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>考虑到 Spring MVC 和 Rest 关系比较大，所以本文一共分成两大块：</p>
<ul>
<li>Spring MVC</li>
<li>REST</li>
</ul>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供”模型-视图-控制器”( Model-View-Controller )架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p>
<p>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="介绍下-Spring-MVC-的核心组件？"><a href="#介绍下-Spring-MVC-的核心组件？" class="headerlink" title="介绍下 Spring MVC 的核心组件？"></a>介绍下 Spring MVC 的核心组件？</h3><p>Spring MVC 一共有九大核心组件，分别是：</p>
<ul>
<li>MultipartResolver</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ul>
<p>虽然很多，但是在前后端分离的架构中，在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/Interview/#">「描述一下 DispatcherServlet 的工作流程？」</a> 问题中，我们会明白，最关键的只有 HandlerMapping + HandlerAdapter + HandlerExceptionResolver 。</p>
<p>关于每个组件的说明，直接看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a> 。</p>
<h3 id="描述一下-DispatcherServlet-的工作流程？"><a href="#描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="描述一下 DispatcherServlet 的工作流程？"></a>描述一下 DispatcherServlet 的工作流程？</h3><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15300766829012.jpg" alt="DispatcherServlet 的工作流程"></p>
<p>① <strong>发送请求</strong></p>
<p>用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器 DispatcherServlet 捕获。</p>
<p>② <strong>映射处理器</strong></p>
<p>DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 <strong>Handler</strong> 对象以及 Handler 对象对应的<strong>拦截器</strong>），最后以 HandlerExecutionChain 对象的形式返回。</p>
<ul>
<li>即 HandlerExecutionChain 中，包含对应的 <strong>Handler</strong> 对象和<strong>拦截器</strong>们。</li>
</ul>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;&#x2F; HandlerMapping.java</span><br><span class="line">&gt; </span><br><span class="line">&gt; @Nullable</span><br><span class="line">&gt; HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>③④ <strong>处理器适配 + 调用处理器方法</strong></p>
<p>DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 <code>#preHandler(...)</code> 方法）。</p>
<p>提取请求 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConverter ：会将请求消息（如 JSON、XML 等数据）转换成一个对象。</li>
<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。</li>
</ul>
<p>Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;&#x2F; HandlerAdapter.java</span><br><span class="line">&gt; </span><br><span class="line">&gt; @Nullable</span><br><span class="line">&gt; ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>⑤ <strong>解析视图</strong></p>
<p>根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;&#x2F; ViewResolver.java</span><br><span class="line">&gt; </span><br><span class="line">&gt; @Nullable</span><br><span class="line">&gt; View resolveViewName(String viewName, Locale locale) throws Exception;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>⑥ ⑦ <strong>渲染视图</strong> + <strong>响应请求</strong></p>
<p>ViewResolver 结合 Model 和 View，来渲染视图，并写回给用户( 浏览器 )。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#x2F;&#x2F; View.java</span><br><span class="line">&gt; </span><br><span class="line">&gt; void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这样一看，胖友可能有点懵逼，所以还是推荐看看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p><strong>但是 Spring MVC 的流程真的一定是酱紫么</strong>？</p>
<p>既然这么问，答案当然不是。对于目前主流的架构，前后端已经进行分离了，所以 Spring MVC 只负责 <strong>M</strong>odel 和 <strong>C</strong>ontroller 两块，而将 <strong>V</strong>iew 移交给了前端。所以，在上图中的步骤 ⑤ 和 ⑥ 两步，已经不在需要。</p>
<p>那么变成什么样了呢？在步骤 ③ 中，如果 Handler(Controller) 执行完后，如果判断方法有 <code>@ResponseBody</code> 注解，则直接将结果写回给用户( 浏览器 )。</p>
<p>但是 HTTP 是不支持返回 Java POJO 对象的，所以需要将结果使用 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/HandlerAdapter-5-HttpMessageConverter/">HttpMessageConverter</a> 进行转换后，才能返回。例如说，大家所熟悉的 <a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">FastJsonHttpMessageConverter</a> ，将 POJO 转换成 JSON 字符串返回。</p>
<p>再来补充两个图，这真的是 Spring MVC 非常关键的问题，所以要用心理解。</p>
<p>FROM <a target="_blank" rel="noopener" href="https://blog.csdn.net/J080624/article/details/77990164">《SpringMVC - 运行流程图及原理分析》</a></p>
<p><strong>流程示意图</strong>：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png" alt="流程示意图"></p>
<p><strong>代码序列图</strong>：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2022-02-21/02.png" alt="代码序列图"></p>
<p>FROM <a target="_blank" rel="noopener" href="https://item.jd.com/11807414.html">《看透 Spring MVC：源代码分析与实践》</a> P123</p>
<p><strong>流程示意图</strong>：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2022-02-21/03.png" alt="《流程示意图》"></p>
<h3 id="Controller-注解有什么用？"><a href="#Controller-注解有什么用？" class="headerlink" title="@Controller 注解有什么用？"></a>@Controller 注解有什么用？</h3><p><code>@Controller</code> 注解，它将一个类标记为 Spring Web MVC <strong>控制器</strong> Controller 。</p>
<h3 id="RestController-和-Controller-有什么区别？"><a href="#RestController-和-Controller-有什么区别？" class="headerlink" title="@RestController 和 @Controller 有什么区别？"></a>@RestController 和 @Controller 有什么区别？</h3><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 <code>&quot;ACCEPT&quot;</code> 请求头来决定。</p>
<h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><p><code>@RequestMapping</code> 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL。</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法。</li>
</ul>
<h3 id="RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="@RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><ul>
<li><code>@RequestMapping</code> 可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上。</li>
<li><code>@RequestMapping</code> 可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ul>
<h3 id="返回-JSON-格式使用什么注解？"><a href="#返回-JSON-格式使用什么注解？" class="headerlink" title="返回 JSON 格式使用什么注解？"></a>返回 JSON 格式使用什么注解？</h3><p>可以使用 <strong><code>@ResponseBody</code></strong> 注解，或者使用包含 <code>@ResponseBody</code> 注解的 <strong><code>@RestController</code></strong> 注解。</p>
<p>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter 。</p>
<h3 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h3><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中<strong>加载配置文件</strong>，<strong>完成初始化 Spring MVC 组件的工作</strong>。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<p>关于这一块，如果想要详细了解，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器》</a></li>
</ul>
<h3 id="Spring-MVC-的异常处理？"><a href="#Spring-MVC-的异常处理？" class="headerlink" title="Spring MVC 的异常处理？"></a>Spring MVC 的异常处理？</h3><p>Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，将处理器( <code>handler</code> )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerExceptionResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析异常，转换成对应的 ModelAndView 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="meta">@Nullable</span> Object handler, Exception ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也就是说，如果异常被解析成功，则会返回 ModelAndView 对象。</li>
<li>详细的源码解析，见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/HandlerExceptionResolver/">《精尽 Spring MVC 源码解析 —— HandlerExceptionResolver 组件》</a> 。</li>
</ul>
<p>一般情况下，我们使用 <code>@ExceptionHandler</code> 注解来实现过异常的处理，可以先看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/12e1a752974d">《Spring 异常处理 ExceptionHandler 的使用》</a> 。</p>
<ul>
<li>一般情况下，艿艿喜欢使用<strong>第三种</strong>。</li>
</ul>
<h3 id="Spring-MVC-有什么优点？"><a href="#Spring-MVC-有什么优点？" class="headerlink" title="Spring MVC 有什么优点？"></a>Spring MVC 有什么优点？</h3><ol>
<li>使用真的真的真的非常<strong>方便</strong>，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。</li>
<li>提供<strong>拦截器机制</strong>，可以方便的对请求进行拦截处理。</li>
<li>提供<strong>异常机制</strong>，可以方便的对异常做统一处理。</li>
<li>可以任意使用各种<strong>视图</strong>技术，而不仅仅局限于 JSP ，例如 Freemarker、Thymeleaf 等等。</li>
<li>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，当然仅仅依赖 Servlet ，而不依赖 Filter、Listener )。</li>
</ol>
<h3 id="Spring-MVC-怎样设定重定向和转发-？"><a href="#Spring-MVC-怎样设定重定向和转发-？" class="headerlink" title="Spring MVC 怎样设定重定向和转发 ？"></a>Spring MVC 怎样设定重定向和转发 ？</h3><ul>
<li>结果转发：在返回值的前面加 <code>&quot;forward:/&quot;</code> 。</li>
<li>重定向：在返回值的前面加上 <code>&quot;redirect:/&quot;</code> 。</li>
</ul>
<p>当然，目前前后端分离之后，我们作为后端开发，已经很少有机会用上这个功能了。</p>
<h3 id="Spring-MVC-的-Controller-是不是单例？"><a href="#Spring-MVC-的-Controller-是不是单例？" class="headerlink" title="Spring MVC 的 Controller 是不是单例？"></a>Spring MVC 的 Controller 是不是单例？</h3><p>绝绝绝大多数情况下，Controller 是<strong>单例</strong>。</p>
<p>那么，Controller 里一般不建议存在<strong>共享的变量</strong>。实际场景下，艿艿也没碰到需要使用共享变量的情况。</p>
<h3 id="Spring-MVC-和-Struts2-的异同？"><a href="#Spring-MVC-和-Struts2-的异同？" class="headerlink" title="Spring MVC 和 Struts2 的异同？"></a>Spring MVC 和 Struts2 的异同？</h3><ol>
<li><p>入口</p>
<p>不同</p>
<ul>
<li>Spring MVC 的入门是一个 Servlet <strong>控制器</strong>。</li>
<li>Struts2 入门是一个 Filter <strong>过滤器</strong>。</li>
</ul>
</li>
<li><p>配置映射</p>
<p>不同，</p>
<ul>
<li>Spring MVC 是基于<strong>方法</strong>开发，传递参数是通过<strong>方法形参</strong>，一般设置为<strong>单例</strong>。</li>
<li>Struts2 是基于<strong>类</strong>开发，传递参数是通过<strong>类的属性</strong>，只能设计为<strong>多例</strong>。</li>
</ul>
</li>
</ol>
<ul>
<li><p>视图</p>
<p>不同</p>
<ul>
<li>Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 <strong>ModelAndView</strong> 对象，最后又将模型数据通过 <strong>Request</strong> 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 <strong>JSTL</strong> 。</li>
<li>Struts2 采用<strong>值栈</strong>存储请求和响应的数据，通过 <strong>OGNL</strong> 存取数据。</li>
</ul>
</li>
</ul>
<p>当然，更详细的也可以看看 <a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-ylualwcj-c.html">《面试题：Spring MVC 和 Struts2 的区别》</a> 一文。</p>
<h3 id="详细介绍下-Spring-MVC-拦截器？"><a href="#详细介绍下-Spring-MVC-拦截器？" class="headerlink" title="详细介绍下 Spring MVC 拦截器？"></a>详细介绍下 Spring MVC 拦截器？</h3><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                          HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                          Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                        Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并且，只有该处理器 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一共有三个方法，分别为：<ul>
<li><code>#preHandle(...)</code> 方法，调用 Controller 方法之<strong>前</strong>执行。</li>
<li><code>#postHandle(...)</code> 方法，调用 Controller 方法之<strong>后</strong>执行。</li>
<li><code>#afterCompletion(...)</code>方法，处理完 Controller 方法返回结果之后执行。<ul>
<li>例如，页面渲染后。</li>
<li><strong>当然，要注意，无论调用 Controller 方法是否成功，都会执行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>举个例子：<ul>
<li>当俩个拦截器都实现放行操作时，执行顺序为 <code>preHandle[1] =&gt; preHandle[2] =&gt; postHandle[2] =&gt; postHandle[1] =&gt; afterCompletion[2] =&gt; afterCompletion[1]</code> 。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>false</code> ，也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行 <code>#preHandle(...)</code> 部分。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>true</code> ，第二个拦截器 <code>#preHandle(...)</code> 返回 <code>false</code> ，执行顺序为 <code>preHandle[1] =&gt; preHandle[2] =&gt; afterCompletion[1]</code> 。</li>
</ul>
</li>
<li>总结来说：<ul>
<li><code>#preHandle(...)</code> 方法，按拦截器定义<strong>顺序</strong>调用。若任一拦截器返回 <code>false</code> ，则 Controller 方法不再调用。</li>
<li><code>#postHandle(...)</code> 和 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用。</li>
<li><code>#postHandler(...)</code> 方法，在调用 Controller 方法之<strong>后</strong>执行。</li>
<li><code>#afterCompletion(...)</code> 方法，只有该拦截器在 <code>#preHandle(...)</code> 方法返回 <code>true</code> 时，才能够被调用，且一定会被调用。为什么“且一定会被调用”呢？即使 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用时，前面的拦截器发生异常，后面的拦截器还能够调用，<strong>即无视异常</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p>关于这块，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/amaxiaochen/article/details/77210880">《Spring MVC 多个拦截器执行顺序及拦截器使用方法》</a> 文章，通过<strong>实践</strong>更加理解。</li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-MVC/HandlerMapping-2-HandlerInterceptor/">《精尽 Spring MVC 源码分析 —— HandlerMapping 组件（二）之 HandlerInterceptor》</a> 文章，通过<strong>源码</strong>更加理解。</li>
</ul>
<h3 id="Spring-MVC-的拦截器可以做哪些事情？"><a href="#Spring-MVC-的拦截器可以做哪些事情？" class="headerlink" title="Spring MVC 的拦截器可以做哪些事情？"></a>Spring MVC 的拦截器可以做哪些事情？</h3><p>拦截器能做的事情非常非常非常多，例如：</p>
<ul>
<li>记录访问日志。</li>
<li>记录异常日志。</li>
<li>需要登陆的请求操作，拦截未登陆的用户。</li>
<li>…</li>
</ul>
<h3 id="Spring-MVC-的拦截器和-Filter-过滤器有什么差别？"><a href="#Spring-MVC-的拦截器和-Filter-过滤器有什么差别？" class="headerlink" title="Spring MVC 的拦截器和 Filter 过滤器有什么差别？"></a>Spring MVC 的拦截器和 Filter 过滤器有什么差别？</h3><p>看了文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaodanjava/article/details/32125687">《过滤器( Filter )和拦截器( Interceptor )的区别》</a> ，感觉对比的怪怪的。艿艿觉得主要几个点吧：</p>
<ul>
<li><strong>功能相同</strong>：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li>
<li><strong>容器不同</strong>：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li>
<li><strong>使用便利性不同</strong>：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li>
</ul>
<p>另外，再补充一点小知识。我们会发现，拓展性好的框架，都会提供相应的拦截器或过滤器机制，方便的我们做一些拓展。例如：</p>
<ul>
<li>Dubbo 的 Filter 机制。</li>
<li>Spring Cloud Gateway 的 Filter 机制。</li>
<li>Struts2 的拦截器机制。</li>
</ul>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><h3 id="REST-代表着什么"><a href="#REST-代表着什么" class="headerlink" title="REST 代表着什么?"></a>REST 代表着什么?</h3><p>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。</p>
<p>然而，假如你不熟悉REST，我建议你先看看 <a target="_blank" rel="noopener" href="http://bit.ly/2zIGzWK">REST API design and development</a> 这篇文章来更好的了解它。不过对于大多数胖友的英语，可能不太好，所以也可以阅读知乎上的 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28557115">《怎样用通俗的语言解释 REST，以及 RESTful？》</a> 讨论。</p>
<h3 id="资源是什么"><a href="#资源是什么" class="headerlink" title="资源是什么?"></a>资源是什么?</h3><p>资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，它允许客户端通过 HTTP 方法如：<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2012/03/get-post-method-in-http-and-https.html">GET</a>, <a target="_blank" rel="noopener" href="http://www.java67.com/2014/08/difference-between-post-and-get-request.html">POST</a>,<a target="_blank" rel="noopener" href="http://www.java67.com/2016/09/when-to-use-put-or-post-in-restful-web-services.html">PUT</a>, DELETE 等读，写，修改和创建资源。</p>
<h3 id="什么是安全的-REST-操作"><a href="#什么是安全的-REST-操作" class="headerlink" title="什么是安全的 REST 操作?"></a>什么是安全的 REST 操作?</h3><p>REST 接口是通过 HTTP 方法完成操作。</p>
<ul>
<li>一些HTTP操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源</li>
<li>换句话说，PUT,POST 和 DELETE 是不安全的，因为他们能修改服务端的资源。</li>
</ul>
<p>所以，是否安全的界限，在于<strong>是否修改</strong>服务端的资源。</p>
<h3 id="什么是幂等操作-为什么幂等操作如此重要"><a href="#什么是幂等操作-为什么幂等操作如此重要" class="headerlink" title="什么是幂等操作? 为什么幂等操作如此重要?"></a>什么是幂等操作? 为什么幂等操作如此重要?</h3><p>有一些HTTP方法，如：GET，不管你使用多少次它都能产生相同的结果，在没有任何一边影响的情况下，发送多个 GET 请求到相同的<a target="_blank" rel="noopener" href="http://www.java67.com/2013/01/difference-between-url-uri-and-urn.html">URI</a> 将会产生相同的响应结果。因此，这就是所谓<strong>幂等</strong>操作。</p>
<p>换句话说，<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html">POST方法不是幂等操作</a> ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是，假如你用PUT更新资源，它将是幂等操作。</p>
<p>甚至多个 PUT 请求被用来更新服务端资源，将得到相同的结果。你可以通过 Pluralsight 学习 <a target="_blank" rel="noopener" href="http://pluralsight.pxf.io/c/1193463/424552/7490?u=https://www.pluralsight.com/courses/xhttp-fund">HTTP Fundamentals</a> 课程来了解 HTTP 协议和一般的 HTTP 的更多幂等操作。</p>
<h3 id="REST-是可扩展的或说是协同的吗"><a href="#REST-是可扩展的或说是协同的吗" class="headerlink" title="REST 是可扩展的或说是协同的吗?"></a>REST 是可扩展的或说是协同的吗?</h3><p>是的，<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2015/08/difference-between-soap-and-restfull-webservice-java.html">REST</a> 是可扩展的和可协作的。它既不托管一种特定的技术选择，也不定在客户端或者服务端。你可以用 <a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2017/11/top-5-free-java-courses-for-beginners.html">Java</a>, <a target="_blank" rel="noopener" href="http://www.java67.com/2018/02/5-free-cpp-courses-to-learn-programming.html">C++</a>, <a target="_blank" rel="noopener" href="http://www.java67.com/2018/02/5-free-python-online-courses-for-beginners.html">Python</a>, 或 <a target="_blank" rel="noopener" href="http://www.java67.com/2018/04/top-5-free-javascript-courses-to-learn.html">JavaScript</a> 来创建 RESTful Web 服务，也可以在客户端使用它们。</p>
<p>我建议你读一本关于REST接口的书来了解更多，如：<a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2017/02/top-5-books-to-learn-rest-and-restful-web-services-in-java.html">RESTful Web Services</a> 。</p>
<blockquote>
<p>艿艿：所以这里的“可拓展”、“协同”对应到我们平时常说的，“跨语言”、“语言无关”。</p>
</blockquote>
<h3 id="REST-用哪种-HTTP-方法呢"><a href="#REST-用哪种-HTTP-方法呢" class="headerlink" title="REST 用哪种 HTTP 方法呢?"></a>REST 用哪种 HTTP 方法呢?</h3><p>REST 能用任何的 HTTP 方法，但是，最受欢迎的是：</p>
<ul>
<li>用 GET 来检索服务端资源</li>
<li>用 POST 来创建服务端资源</li>
<li><a target="_blank" rel="noopener" href="http://javarevisited.blogspot.sg/2016/04/what-is-purpose-of-http-request-types-in-RESTful-web-service.html#axzz56WGunSwy">用 PUT 来更新服务端资源</a></li>
<li>用 DELETE 来删除服务端资源。</li>
</ul>
<p>恰好，这四个操作，对上我们日常逻辑的 CRUD 操作。</p>
<blockquote>
<p>艿艿：经常能听到胖友抱怨自己做的都是 CRUD 的功能。看了这个面试题，有没觉得原来 CRUD 也能玩的稍微高级一点？！</p>
<p>实际上，每个 CRUD 也是可以通过不断的打磨，玩的很高级。例如说 DDD 领域驱动，完整的单元测试，可扩展的设计。</p>
</blockquote>
<h3 id="删除的-HTTP-状态返回码是什么"><a href="#删除的-HTTP-状态返回码是什么" class="headerlink" title="删除的 HTTP 状态返回码是什么 ?"></a>删除的 HTTP 状态返回码是什么 ?</h3><p>在删除成功之后，您的 REST API 应该返回什么状态代码，并没有严格的规则。它可以返回 200 或 204 没有内容。</p>
<ul>
<li>一般来说，如果删除操作成功，响应主体为空，返回 <a target="_blank" rel="noopener" href="http://www.netingcn.com/http-status-204.html">204</a> 。</li>
<li>如果删除请求成功且响应体不是空的，则返回 200 。</li>
</ul>
<h3 id="REST-API-是无状态的吗"><a href="#REST-API-是无状态的吗" class="headerlink" title="REST API 是无状态的吗?"></a>REST API 是无状态的吗?</h3><p><strong>是的</strong>，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。</p>
<p>REST API 中的请求应该包含处理它所需的所有细节。它<strong>不应该</strong>依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</p>
<p><strong>REST 规范为使其无状态设置了一个约束，在设计 REST API 时，您应该记住这一点</strong>。</p>
<h3 id="REST安全吗-你能做什么来保护它"><a href="#REST安全吗-你能做什么来保护它" class="headerlink" title="REST安全吗? 你能做什么来保护它?"></a>REST安全吗? 你能做什么来保护它?</h3><p>安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的。</p>
<p>REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。</p>
<ul>
<li>至少，你可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。</li>
<li>类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。</li>
</ul>
<h3 id="RestTemplate-的优势是什么"><a href="#RestTemplate-的优势是什么" class="headerlink" title="RestTemplate 的优势是什么?"></a>RestTemplate 的优势是什么?</h3><p>在 Spring Framework 中，RestTemplate 类是 <a target="_blank" rel="noopener" href="http://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html">模板方法模式</a> 的实现。跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，它将在客户端简化跟 RESTful Web 服务的集成。正如在 RestTemplate 例子中显示的一样，你能非常容易地用它来调用 RESTful Web 服务。</p>
<blockquote>
<p>艿艿：当然，实际场景我还是更喜欢使用 <a target="_blank" rel="noopener" href="http://square.github.io/okhttp/">OkHttp</a> 作为 HTTP 库，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。</p>
</blockquote>
<h3 id="HttpMessageConverter-在-Spring-REST-中代表什么"><a href="#HttpMessageConverter-在-Spring-REST-中代表什么" class="headerlink" title="HttpMessageConverter 在 Spring REST 中代表什么?"></a>HttpMessageConverter 在 Spring REST 中代表什么?</h3><p>HttpMessageConverter 是一种<a target="_blank" rel="noopener" href="http://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html">策略接口</a> ，它指定了一个转换器，它可以转换 HTTP 请求和响应。Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。</p>
<p>每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。Spring 使用 <code>&quot;Accept&quot;</code> 的标头来确定客户端所期待的内容类型。</p>
<p>然后，它将尝试找到一个注册的 HTTPMessageConverter ，它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。</p>
<p>如果胖友对 HttpMessageConverter 不了解，可以看看 <a target="_blank" rel="noopener" href="https://leokongwq.github.io/2017/06/14/spring-MessageConverter.html">《Spring 中 HttpMessageConverter 详解》</a> 。</p>
<h3 id="如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？"><a href="#如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？" class="headerlink" title="如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？"></a>如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？</h3><p>我们仅需要创建自定义的 AbstractHttpMessageConverter 的实现，并使用 WebMvcConfigurerAdapter 的 <code>#extendMessageConverters(List&gt; converters)</code> 方法注中册它，该方法可以生成一种新的请求 / 响应类型。</p>
<p>具体的示例，可以学习 <a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">《在 Spring 中集成 Fastjson》</a> 文章。</p>
<h3 id="PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？"><a href="#PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？" class="headerlink" title="@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？"></a>@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？</h3><p><code>@PathVariable</code> 注解，是 Spring MVC 中有用的注解之一，它允许您从 URI 读取值，比如查询参数。它在使用 Spring 创建 RESTful Web 服务时特别有用，因为在 REST 中，资源标识符是 URI 的一部分。</p>
<p>具体的使用示例，胖友如果不熟悉，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/cx361006796/article/details/52829759">《Spring MVC 的 @RequestParam 注解和 @PathVariable 注解的区别》</a> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/%E7%BC%93%E5%AD%98%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/%E7%BC%93%E5%AD%98%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">缓存 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：16:52:18" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文只分享通用的【缓存】的面试题，关于 Redis、MemCache 会单独分享。</p>
<p>再另外，本文【缓存】指的更多的是分布式缓存服务，而不是 HTTP 缓存等等。</p>
<h3 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h3><blockquote>
<p>艿艿：这个问题，理解即可。</p>
</blockquote>
<p>缓存，就是数据交换的缓冲区，针对服务对象的不同（本质就是不同的硬件）都可以构建缓存。</p>
<p>目的是，<strong>把读写速度【慢】的介质的数据保存在读写速度【快】的介质中，从而提高读写速度，减少时间消耗</strong>。例如：</p>
<ul>
<li>CPU 高速缓存 ：高速缓存的读写速度远高于内存。<ul>
<li>CPU 读数据时，如果在高速缓存中找到所需数据，就不需要读内存</li>
<li>CPU 写数据时，先写到高速缓存，再回写到内存。</li>
</ul>
</li>
<li>磁盘缓存：磁盘缓存其实就把常用的磁盘数据保存在内存中，内存读写速度也是远高于磁盘的。<ul>
<li>读数据，时从内存读取。</li>
<li>写数据时，可先写到内存，定时或定量回写到磁盘，或者是同步回写。</li>
</ul>
</li>
</ul>
<p>在 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/liqiu/p/3211746.html">《CPU 内存访问速度，磁盘和网络速度，所有人都应该知道的数字》</a> 中，胖友可以更好的理解不同介质的速度。</p>
<h3 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h3><p>正如在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「什么是缓存？」</a> 问题中所看到的，使用缓存的目的，就是提升读写性能。而实际业务场景下，更多的是为了提升<strong>读性能</strong>，带来更好的性能，更高的并发量。</p>
<p>日常业务中，我们使用比较多的数据库是 MySQL ，缓存是 Redis 。一起来看看，阿里云提供的性能规格：</p>
<ul>
<li>Redis 性能规格，<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/26350.html">https://help.aliyun.com/document_detail/26350.html</a> 。打底 8W QPS ，最高可达千万 QPS 。</li>
<li>MySQL 性能规格 <a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/53637.html">https://help.aliyun.com/document_detail/53637.html</a> 。打底 1.4K QPS ，最高 7W QPS 。</li>
</ul>
<p>艿艿自己，也分别进行了下 Redis 和 MySQL 的基准测试，感兴趣的胖友，可以看看，甚至自己上手玩玩。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Performance-Testing/Redis-benchmark/?vip">《性能测试 —— Redis 基准测试》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Performance-Testing/MySQL-benchmark/?vip">《性能测试 —— MySQL 基准测试》</a></li>
</ul>
<p>如此一比较，Redis 比 MySQL 的读写性能好很多。那么，我们将 MySQL 的热点数据，缓存到 Redis 中，提升读取性能，也减小 MySQL 的读取压力。例如说：</p>
<ul>
<li>论坛帖子的访问频率比较高，且要实时更新阅读量，使用 Redis 记录帖子的阅读量，可以提升性能和并发。</li>
<li>商品信息，数据更新的频率不高，但是读取的频率很高，特别是热门商品。</li>
</ul>
<h3 id="请说说有哪些缓存算法？是否能手写一下-LRU-代码的实现？"><a href="#请说说有哪些缓存算法？是否能手写一下-LRU-代码的实现？" class="headerlink" title="请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？"></a>请说说有哪些缓存算法？是否能手写一下 LRU 代码的实现？</h3><p><strong>缓存算法</strong></p>
<p>缓存算法，比较常见的是三种：</p>
<ul>
<li>LRU（least recently used ，最近最少使用)</li>
<li>LFU（Least Frequently used ，最不经常使用)</li>
<li>FIFO（first in first out ，先进先出)</li>
</ul>
<p>完整的话，胖友可以看看 <a target="_blank" rel="noopener" href="http://blog.jobbole.com/30940/">《缓存、缓存算法和缓存框架简介》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「缓存算法」</a> 部分。</p>
<p><strong>手写 LRU 代码的实现</strong></p>
<p>手写 LRU 代码的实现，有多种方式。其中，最简单的是基于 LinkedHashMap 来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 LinkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map 中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它更复杂，更能体现个人编码能力的 LRU 实现方式，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://crossoverjie.top/2018/04/07/algorithm/LRU-cache/">《动手实现一个 LRU Cache》</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/30940/">《缓存、缓存算法和缓存框架简介》</a> 文末，并且还提供了 FIFO、LFU 的代码实现。</li>
</ul>
<h3 id="常见的常见的缓存工具和框架有哪些？"><a href="#常见的常见的缓存工具和框架有哪些？" class="headerlink" title="常见的常见的缓存工具和框架有哪些？"></a>常见的常见的缓存工具和框架有哪些？</h3><p>在 Java 后端开发中，常见的缓存工具和框架列举如下：</p>
<ul>
<li>本地缓存：Guava LocalCache、Ehcache、Caffeine 。<ul>
<li>Ehcache 的功能更加丰富，Caffeine 的性能要比 Guava LocalCache 好。</li>
</ul>
</li>
<li>分布式缓存：Redis、Memcached、Tair 。<ul>
<li>Redis 最为主流和常用。</li>
</ul>
</li>
</ul>
<h3 id="用了缓存之后，有哪些常见问题？"><a href="#用了缓存之后，有哪些常见问题？" class="headerlink" title="用了缓存之后，有哪些常见问题？"></a>用了缓存之后，有哪些常见问题？</h3><p>常见的问题，可列举如下：</p>
<ul>
<li>写入问题<ul>
<li>缓存何时<strong>写入</strong>？并且写时如何避免并发重复写入？</li>
<li>缓存如何<strong>失效</strong>？</li>
<li>缓存和 DB 的<strong>一致性</strong>如何保证？</li>
</ul>
</li>
<li>经典三连问<ul>
<li>如何避免缓存<strong>穿透</strong>的问题？</li>
<li>如何避免缓存<strong>击穿</strong>的问题？</li>
<li>如果避免缓存<strong>雪崩</strong>的问题？</li>
</ul>
</li>
</ul>
<blockquote>
<p>艿艿：重点可以去“记”加粗的六个词。</p>
</blockquote>
<p>下面，我们会对每个问题，逐步解析。</p>
<h3 id="当查询缓存报错，怎么提高可用性？"><a href="#当查询缓存报错，怎么提高可用性？" class="headerlink" title="当查询缓存报错，怎么提高可用性？"></a>当查询缓存报错，怎么提高可用性？</h3><p>缓存可以极大的提高查询性能，但是缓存数据丢失和缓存不可用不能影响应用的正常工作。</p>
<p>因此，一般情况下，如果缓存出现异常，需要手动捕获这个异常，并且记录日志，并且从数据库查询数据返回给用户，而不应该导致业务不可用。</p>
<p>当然，这样做可能会带来缓存雪崩的问题。具体怎么解决，可以看看本文 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「如何避免缓存”雪崩”的问题？」</a> 问题。</p>
<h3 id="如果避免缓存”穿透”的问题？"><a href="#如果避免缓存”穿透”的问题？" class="headerlink" title="如果避免缓存”穿透”的问题？"></a>如果避免缓存”穿透”的问题？</h3><p><strong>缓存穿透</strong></p>
<p>缓存穿透，是指查询一个一定<strong>不存在</strong>的数据，由于缓存是不命中时被动写，并且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。</p>
<blockquote>
<p>被动写：当从缓存中查不到数据时，然后从数据库查询到该数据，写入该数据到缓存中。</p>
</blockquote>
<p>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。如下图：<a target="_blank" rel="noopener" href="http://static2.iocoder.cn/images/Cache/2019-11-21/01.png"><img src="http://static2.iocoder.cn/images/Cache/2019-11-21/01.png" alt="缓存穿透"></a>缓存穿透</p>
<ul>
<li>在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「为什么要用缓存？」</a> 中，我们已经看到，MySQL 的性能是远不如 Redis 的，如果大量的请求直接打到 MySQL ，则会直接打挂 MySQL 。</li>
<li>当然，缓存穿透不一定是攻击，也可能是我们自己程序写的问题，疯狂读取不存在的数据，又或者“无脑”的爬虫，顺序爬取数据。</li>
<li>另外，一定要注意，<strong>缓存穿透</strong>，指的是查询一个<strong>不存在</strong>的数据，很容器和我们要讲到的<strong>缓存击穿</strong>搞混淆。</li>
</ul>
<p><strong>如何解决</strong></p>
<p>有两种方案可以解决：</p>
<p>1）方案一，缓存空对象。</p>
<p>当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用<strong>特殊的标识</strong>，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，一般建议不要超过 5 分钟。</p>
<blockquote>
<p>为什么要较短的过期时间？因为缓存久没有意义，也浪费缓存的内存。</p>
</blockquote>
<p>2）方案二，BloomFilter 布隆过滤器。</p>
<p>在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值<strong>不为空</strong>。那么整个逻辑的如下：</p>
<ul>
<li>1、根据 KEY 查询【BloomFilter 缓存】。如果不存在对应的值，直接返回；如果存在，继续向下执行。【后续的流程，就是标准的流程】</li>
<li>2、根据 KEY 查询在【数据缓存】的值。如果存在值，直接返回；如果不存在值，继续向下执行。</li>
<li>3、查询 DB 对应的值，如果存在，则更新到缓存，并返回该值。</li>
</ul>
<p>可能有胖友不是很了解 BloomFilter 布隆过滤器，会有疑惑，为什么 BloomFilter 不存储 KEY 是不存在的情况（就是我们方案二反过来）？</p>
<ul>
<li>BloomFilter 存在误判。简单来说，<strong>存在的不一定存在，不存在的一定不存在</strong>。这样就会导致，一个存在的 KEY 被误判成不存在。</li>
<li>同时，BloomFilter 不允许删除。例如说，一个 KEY 一开始是不存在的，后来数据新增了，但是 BloomFilter 不允许删除的特点，就会导致一直会被判断成不存在。</li>
</ul>
<p>当然，使用 BloomFilter 布隆过滤器的话，需要提前将已存在的 KEY ，初始化存储到【BloomFilter 缓存】中。</p>
<p><strong>选择</strong></p>
<p>这两个方案，各有其优缺点。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">缓存空对象</th>
<th align="left">BloomFilter 布隆过滤器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">适用场景</td>
<td align="left">1、数据命中不高 2、保证一致性</td>
<td align="left">1、数据命中不高 2、数据相对固定、实时性低</td>
</tr>
<tr>
<td align="left">维护成本</td>
<td align="left">1、代码维护简单 2、需要过多的缓存空间 3、数据不一致</td>
<td align="left">1、代码维护复杂 2、缓存空间占用小</td>
</tr>
</tbody></table>
<p>实际情况下，使用方案二比较多。因为，相比方案一来说，更加节省内容，对缓存的负荷更小。</p>
<p>注意，常用的缓存 Redis 默认不支持 BloomFilter 数据结构。具体怎么解决，参考如下文章：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a></p>
<blockquote>
<p>Redis 4.0 引入 Module 机制，支持 Server 自定义拓展。而 RedisBloom ，就是 Redis BloomFilter 的拓展。</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter">Redis-Lua-scaling-bloom-filter</a></p>
<blockquote>
<p>Lua 脚本，实现 BloomFilter 的功能。</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/6.-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1#68-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8bloom-filter">Redisson BloomFilter</a></p>
<blockquote>
<p>Java Redis 库，实现 BloomFilter 的功能。</p>
</blockquote>
</li>
<li><p>其它文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012620152">《Google Guava之BloomFilter 源码分析及基于 Redis 的重构》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017370384">《基于 Redis 的 BloomFilter 实现》</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>艿艿的遐想：因为 BloomFilter 布隆过滤器存在的误判的情况，如果最后去 DB 查询不到数据的情况，是不是可以结合方案一，缓存空对象到【BloomFilter 缓存】中。后来想想，必要性不大，因为 BloomFilter 布隆过滤器误判率很低，没必要把方案复杂化，大道至简。</p>
</blockquote>
<hr>
<p>另外，推荐看下 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug">《Redis架构之防雪崩设计：网站不宕机背后的兵法》</a> 文章的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「一、缓存穿透预防及优化」</a> ，大神解释的更好，且提供相应的图和伪代码。</p>
<h3 id="如何避免缓存”雪崩”的问题？"><a href="#如何避免缓存”雪崩”的问题？" class="headerlink" title="如何避免缓存”雪崩”的问题？"></a>如何避免缓存”雪崩”的问题？</h3><p>🦅 <strong>缓存雪崩</strong></p>
<p>缓存雪崩，是指缓存由于某些原因无法提供服务( 例如，缓存挂掉了 )，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。</p>
<p>🦅 <strong>如何解决</strong></p>
<p>预防和解决缓存雪崩的问题，可以从以下<strong>多个方面进行共同着手</strong>。</p>
<p>1）缓存高可用</p>
<p>通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。</p>
<p>假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。</p>
<p>2）本地缓存</p>
<p>如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请求全部到达 DB 中。</p>
<p>当然，引入本地缓存也会有相应的问题，例如说：</p>
<ul>
<li>本地缓存的实时性怎么保证？<ul>
<li>方案一，可以引入消息队列。在数据更新时，发布数据更新的消息；而进程中有相应的消费者消费该消息，从而更新本地缓存。</li>
<li>方案二，设置较短的过期时间，请求时从 DB 重新拉取。</li>
<li>方案三，使用 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「如果避免缓存”击穿”的问题？」</a> 问题的【方案二】，手动过期。</li>
</ul>
</li>
<li>每个进程可能会本地缓存相同的数据，导致数据浪费？<ul>
<li>方案一，需要配置本地缓存的过期策略和缓存数量上限。</li>
</ul>
</li>
</ul>
<p>如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。</p>
<p>3）请求 DB 限流</p>
<p>通过限制 DB 的每秒请求数，避免把 DB 也打挂了。这样至少能有两个好处：</p>
<ol>
<li>可能有一部分用户，还可以使用，系统还没死透。</li>
<li>未来缓存服务恢复后，系统立即就已经恢复，无需再处理 DB 也挂掉的情况。</li>
</ol>
<p>当然，被限流的请求，我们最好也要有相应的处理，走【服务降级】，提供一些默认的值，或者友情提示，甚至空白的值也行。</p>
<p>如果我们使用 Java ，则可以使用 Guava RateLimiter、Sentinel、Hystrix 实现限流的功能。</p>
<p>4）提前演练</p>
<p>在项目上线前，演练缓存宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。</p>
<hr>
<p>另外，推荐看下 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug">《Redis架构之防雪崩设计：网站不宕机背后的兵法》</a> 文章的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「二、缓存雪崩问题优化」</a> ，大神解释的更好，且提供相应的图和伪代码。</p>
<h3 id="如果避免缓存”击穿”的问题？"><a href="#如果避免缓存”击穿”的问题？" class="headerlink" title="如果避免缓存”击穿”的问题？"></a>如果避免缓存”击穿”的问题？</h3><p><strong>缓存击穿</strong></p>
<p>缓存击穿，是指某个<strong>极度“热点”</strong>数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。</p>
<ul>
<li>对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。</li>
<li>区别：<ul>
<li>和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。</li>
<li>和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。</li>
</ul>
</li>
</ul>
<p><strong>如何解决</strong></p>
<p>有两种方案可以解决：</p>
<p>1）方案一，使用互斥锁。</p>
<p>请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。流程如下：</p>
<ul>
<li>1、获取分布式锁，直到成功或超时。如果超时，则抛出异常，返回。如果成功，继续向下执行。</li>
<li>2、获取缓存。如果存在值，则直接返回；如果不存在，则继续往下执行。😈 因为，获得到锁，可能已经被“那个”线程去查询过 DB ，并更新到缓存中了。</li>
<li>3、查询 DB ，并更新到缓存中，返回值。</li>
</ul>
<p>2）方案二，手动过期。</p>
<p>缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里。流程如下：</p>
<ul>
<li>1、获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下执行。</li>
<li>2、通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。</li>
<li>3、同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。</li>
</ul>
<p>🦅 <strong>选择</strong></p>
<p>这两个方案，各有其优缺点。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">使用互斥锁</th>
<th align="left">手动过期</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">1、思路简单 2、保证一致性</td>
<td align="left">1、性价最佳，用户无需等待</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">1、代码复杂度增大 2、存在死锁的风险</td>
<td align="left">1、无法保证缓存一致性</td>
</tr>
</tbody></table>
<p>具体使用哪一种方案，胖友可以根据自己的业务场景去做选择。</p>
<ul>
<li>有一点要注意，上述的两个方案，都是建立在<strong>极度“热点”</strong>数据存在的情况，所以实际场景下，需要结合 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「如果避免缓存”穿透”的问题？」</a> 的方案，一起使用。</li>
</ul>
<hr>
<p>另外，推荐看下 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug">《Redis 架构之防雪崩设计：网站不宕机背后的兵法》</a> 文章的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「三、缓存热点 key 重建优化」</a> ，大神解释的更好，且提供相应的图和伪代码。</p>
<h3 id="缓存和-DB-的一致性如何保证？"><a href="#缓存和-DB-的一致性如何保证？" class="headerlink" title="缓存和 DB 的一致性如何保证？"></a>缓存和 DB 的一致性如何保证？</h3><p><strong>产生原因</strong></p>
<p>主要有两种情况，会导致缓存和 DB 的一致性问题：</p>
<ol>
<li><p>并发的场景下，导致读取老的 DB 数据，更新到缓存中。</p>
<blockquote>
<p>这里，主要指的是，更新 DB 数据之前，先删除 Cache 的数据。在低并发量下没什么问题，但是在高并发下，就会存在问题。在(删除 Cache 的数据, 和更新 DB 数据)时间之间，恰好有一个请求，我们如果使用<strong>被动读</strong>，因为此时 DB 数据还是老的，又会将老的数据写入到 Cache 中。</p>
</blockquote>
</li>
<li><p>缓存和 DB 的操作，不在一个事务中，可能只有一个 DB 操作成功，而另一个 Cache 操作失败，导致不一致。</p>
</li>
</ol>
<p>当然，有一点我们要注意，缓存和 DB 的一致性，我们指的更多的是最终一致性。我们使用缓存只要是提高读操作的性能，真正在写操作的业务逻辑，还是以数据库为准。例如说，我们可能缓存用户钱包的余额在缓存中，在前端查询钱包余额时，读取缓存，在使用钱包余额时，读取数据库。</p>
<p><strong>解决方案</strong></p>
<p>在开始说解决方案之前，胖友先看看如下几篇文章，可能有一丢丢多，保持耐心。</p>
<ul>
<li>左耳朵耗子<ul>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">《缓存更新的套路》</a></li>
</ul>
</li>
<li>沈剑<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html">《缓存架构设计细节二三事》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-database.html">《缓存与数据库一致性优化》</a> 这篇，我觉得写的方案不太可行。</li>
</ul>
</li>
</ul>
<p>下面，我们就来看看几种方案。当然无论哪种方案，比较重要的就是解决两个问题：</p>
<ul>
<li><p>1、将缓存可能存在的并行写，实现串行写。</p>
<blockquote>
<p>注意，这里指的是缓存的并行写。在被动读中，如果缓存不存在，也存在写。</p>
</blockquote>
</li>
<li><p>2、实现数据的最终一致性。</p>
</li>
</ul>
<p>1）先淘汰缓存，再写数据库</p>
<p>因为先淘汰缓存，所以数据的最终一致性是可以得到有效的保证的。为什么呢？先淘汰缓存，即使写数据库发生异常，也就是下次缓存读取时，多读取一次数据库。</p>
<p>但是，这种方案会存在缓存和 DB 的数据会不一致的情况，<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-database.html">《缓存与数据库一致性优化》</a> 已经说了。</p>
<p>那么，我们需要解决缓存并行写，实现串行写。比较简单的方式，引入分布式锁。</p>
<ul>
<li>在写请求时，先淘汰缓存之前，先获取该分布式锁。</li>
<li>在读请求时，发现缓存不存在时，先获取分布式锁。</li>
</ul>
<p>这样，缓存的并行写就成功的变成串行写落。实际上，就是 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「如果避免缓存”击穿”的问题？」</a> 的【方案一】互斥锁的加强版。</p>
<p>整体执行，如下草图：</p>
<p><a target="_blank" rel="noopener" href="http://static2.iocoder.cn/images/Cache/2019-11-21/02.png"><img src="http://static2.iocoder.cn/images/Cache/2019-11-21/02.png" alt="草图"></a>草图</p>
<ul>
<li>写请求时，是否主动更新缓存，根据自己业务的需要，是否有，都没问题。</li>
</ul>
<p>2）先写数据库，再更新缓存</p>
<p>按照“先写数据库，再更新缓存”，我们要保证 DB 和缓存的操作，能够在“同一个事务”中，从而实现最终一致性。</p>
<p><strong>基于定时任务来实现</strong></p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，在写入数据库所在的事务中，插入一条记录到任务表。该记录会存储需要更新的缓存 KEY 和 VALUE 。</li>
<li>【异步】最后，定时任务每秒扫描任务表，更新到缓存中，之后删除该记录。</li>
</ul>
<p><strong>基于消息队列来实现</strong></p>
<ul>
<li>首先，写入数据库。</li>
<li>然后，发送带有缓存 KEY 和 VALUE 的事务消息。此时，需要有支持事务消息特性的消息队列，或者我们自己封装消息队列，支持事务消息。</li>
<li>【异步】最后，消费者消费该消息，更新到缓存中。</li>
</ul>
<p>这两种方式，可以进一步优化，可以先尝试更新缓存，如果失败，则插入任务表，或者事务消息。</p>
<p>另外，极端情况下，如果并发写执行时，先更新成功 DB 的，结果后更新缓存，如下图所示：<img src="http://static2.iocoder.cn/images/Cache/2019-11-21/03.png" alt="草图"></p>
<ul>
<li>理论来说，希望的更新缓存顺序是，线程 1 快于线程 2 ，但是实际线程1 晚于线程 2 ，导致数据不一致。</li>
<li>可能胖友会说，图中不是基于定时任务或消息队列来实现异步更新缓存啊？答案是一直的，如果网络抖动，导致【插入任务表，或者事务消息】的顺序不一致。</li>
<li>那么怎么解决呢？需要做如下三件事情：<ul>
<li>1、在缓存值中，拼接上数据版本号或者时间戳。例如说：<code>value = &#123;value: 原值, version: xxx&#125;</code> 。</li>
<li>2、在任务表的记录，或者事务消息中，增加上数据版本号或者时间戳的字段。</li>
<li>3、在定时任务或消息队列执行更新缓存时，先读取缓存，对比版本号或时间戳，大于才进行更新。😈 当然，此处也会有并发问题，所以还是得引入分布式锁或 CAS 操作。<ul>
<li>关于 Redis 分布式锁，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview">《精尽 Redis 面试题》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「如何使用 Redis 实现分布式锁？」</a> 问题。</li>
<li>关于 Redis CAS 操作，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview">《精尽 Redis 面试题》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Cache/Interview/#">「什么是 Redis 事务？」</a> 问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3）基于数据库的 binlog 日志</p>
<blockquote>
<p>艿艿：如下内容，引用自 <a target="_blank" rel="noopener" href="http://www.spring4all.com/question/177">《技术专题讨论第五期：论系统架构设计中缓存的重要性》</a> 文章，超哥对这个问题的回答。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://static.iocoder.cn/f434927790ae53b4fa955ecd9952f787"><img src="http://static.iocoder.cn/f434927790ae53b4fa955ecd9952f787" alt="binlog 方案"></a>binlog 方案</p>
<ul>
<li>应用直接写数据到数据库中。</li>
<li>数据库更新binlog日志。</li>
<li>利用Canal中间件读取binlog日志。</li>
<li>Canal借助于限流组件按频率将数据发到MQ中。</li>
<li>应用监控MQ通道，将MQ的数据更新到Redis缓存中。</li>
</ul>
<p>可以看到这种方案对研发人员来说比较轻量，不用关心缓存层面，而且这个方案虽然比较重，但是却容易形成统一的解决方案。</p>
<hr>
<p>当然，以上种种方案，各有其复杂性，如果胖友心里没底，还是仅仅使用如下任一方案：</p>
<ul>
<li><p>“<strong>先淘汰缓存，再写数据库</strong>”的方案，并且无需引入分布式锁。</p>
<blockquote>
<p>沈剑大佬，比较支持这种方案，见 <a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html">《缓存架构设计细节二三事》</a> 。</p>
</blockquote>
</li>
<li><p>“<strong>先写数据库，再更新缓存</strong>”的方案，并且无需引入定时任务或者消息队列。</p>
<blockquote>
<p>左耳朵耗子，比较支持这种方案，<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">《缓存更新的套路》</a>。</p>
</blockquote>
</li>
</ul>
<p>原因如下：</p>
<blockquote>
<p>FROM 基友老梁的总结</p>
<p>使用缓存过程中，经常会遇到缓存数据的不一致性和脏读现象。一般情况下，采取缓存双淘汰机制，在更新数据库的<strong>前</strong>淘汰缓存。此外，设定超时时间，例如三十分钟。</p>
<p><strong>极端场景下，即使有脏数据进入缓存，这个脏数据也最存在一段时间后自动销毁。</strong></p>
</blockquote>
<ul>
<li>重点，是最后一句话哟。</li>
<li>真的，和几个朋友沟通了下，真的出现不一致的情况，靠缓存过期后，重新从 DB 中读取即可。</li>
</ul>
<p>另外，在 DB 主从架构下，方案会更加复杂。详细可以看看 <a target="_blank" rel="noopener" href="https://www.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-master-and-slave-database.html">《主从 DB 与 cache 一致性优化》</a> 。</p>
<blockquote>
<p>艿艿：这是一道相对复杂的问题，重点在于理解为什么产生不一致的原因，然后针对这个原因去解决。</p>
</blockquote>
<h3 id="什么是缓存预热？如何实现缓存预热？"><a href="#什么是缓存预热？如何实现缓存预热？" class="headerlink" title="什么是缓存预热？如何实现缓存预热？"></a>什么是缓存预热？如何实现缓存预热？</h3><p>🦅 <strong>缓存预热</strong></p>
<p>在刚启动的缓存系统中，如果缓存中没有任何数据，如果依靠用户请求的方式重建缓存数据，那么对数据库的压力非常大，而且系统的性能开销也是巨大的。</p>
<p>此时，最好的策略是启动时就把热点数据加载好。这样，用户请求时，直接读取的就是缓存的数据，而无需去读取 DB 重建缓存数据。</p>
<p>举个例子，热门的或者推荐的商品，需要提前预热到缓存中。</p>
<p>🦅 <strong>如何实现</strong></p>
<p>一般来说，有如下几种方式来实现：</p>
<ol>
<li>数据量不大时，项目启动时，自动进行初始化。</li>
<li>写个修复数据脚本，手动执行该脚本。</li>
<li>写个管理界面，可以手动点击，预热对应的数据到缓存中。</li>
</ol>
<h3 id="缓存数据的淘汰策略有哪些？"><a href="#缓存数据的淘汰策略有哪些？" class="headerlink" title="缓存数据的淘汰策略有哪些？"></a>缓存数据的淘汰策略有哪些？</h3><p>除了缓存服务器自带的缓存<strong>自动</strong>失效策略之外，我们还可以根据具体的业务需求进行自定义的<strong>“手动”</strong>缓存淘汰，常见的策略有两种：</p>
<ul>
<li>1、定时去清理过期的缓存。</li>
<li>2、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
<p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！<br>具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h3 id="缓存如何存储-POJO-对象？"><a href="#缓存如何存储-POJO-对象？" class="headerlink" title="缓存如何存储 POJO 对象？"></a>缓存如何存储 POJO 对象？</h3><p>实际场景下，缓存值可能是一个 POJO 对象，就需要考虑如何 POJO 对象存储的问题。目前有两种方式：</p>
<ul>
<li><p>方案一，将 POJO 对象</p>
<p>序列化</p>
<p>进行存储，适合 Redis 和 Memcached 。</p>
<ul>
<li>可参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaolyuh123/article/details/78682200">《Redis 序列化方式StringRedisSerializer、FastJsonRedisSerializer 和 KryoRedisSerializer》</a> 文章。</li>
<li>对于 POJO 对象比较大，可以考虑使用压缩算法，例如说 Snappy、zlib、GZip 等等。</li>
</ul>
</li>
<li><p>方案二，使用 Hash 数据结构，适合 Redis 。</p>
<ul>
<li>可参考 <a target="_blank" rel="noopener" href="https://my.oschina.net/yuyidi/blog/499951">《Redis 之序列化 POJO》</a> 文章。</li>
</ul>
</li>
</ul>
<p>不过对于 Redis 来说，大多数情况下，会考虑使用 JSON 序列化的方案。想要深入的胖友，可以看看如下两篇文章，很有趣：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/Redis-memory-compression-combat/?self">《Redis 内存压缩实战》</a> ，Redis HASH 数据结构，可以通过 ziplist 的编码方式，压缩数据。</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency">《redis-strings-vs-redis-hashes-to-represent-json-efficiency》</a> ，重点看 BMiner 的回答，提供了四种方案，非常有趣。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring Boot 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：15:47:25" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心技术篇"><a href="#核心技术篇" class="headerlink" title="核心技术篇"></a>核心技术篇</h2><h3 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h3><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot">Spring Boot</a> 是 Spring 的<strong>子项目</strong>，正如其名字，提供 Spring 的引导( <strong>Boot</strong> )的功能。</p>
<p>通过 Spring Boot ，我们开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、MyBatis 等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。</p>
<p>Spring Boot 提供了各种 Starter 启动器，提供标准化的默认配置。例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/2.1.1.RELEASE"><code>spring-boot-starter-web</code></a> 启动器，可以快速配置 Spring MVC 。</li>
<li><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/1.3.2"><code>mybatis-spring-boot-starter</code></a> 启动器，可以快速配置 MyBatis 。</li>
</ul>
<p>并且，Spring Boot 基本已经一统 Java 项目的开发，大量的开源项目都实现了其的 Starter 启动器。例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo-spring-boot-project"><code>incubator-dubbo-spring-boot-project</code></a> 启动器，可以快速配置 Dubbo 。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/maihaoche/rocketmq-spring-boot-starter"><code>rocketmq-spring-boot-starter</code></a> 启动器，可以快速配置 RocketMQ 。</li>
</ul>
<h3 id="Spring-Boot-提供了哪些核心功能？"><a href="#Spring-Boot-提供了哪些核心功能？" class="headerlink" title="Spring Boot 提供了哪些核心功能？"></a>Spring Boot 提供了哪些核心功能？</h3><ul>
<li><p>1、独立运行 Spring 项目</p>
<p>Spring Boot 可以以 jar 包形式独立运行，运行一个 Spring Boot 项目只需要通过 <code>java -jar xx.jar</code> 来运行。</p>
</li>
<li><p>2、内嵌 Servlet 容器</p>
<p>Spring Boot 可以选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。</p>
<blockquote>
<p>第 2 点是对第 1 点的补充，在 Spring Boot 未出来的时候，大多数 Web 项目，是打包成 war 包，部署到 Tomcat、Jetty 等容器。</p>
</blockquote>
</li>
<li><p>3、提供 Starter 简化 Maven 配置</p>
<p>Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载。例如，当你使用了 <code>spring-boot-starter-web</code> ，会自动加入如下依赖：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-26/01.png" alt="`spring-boot-starter-web` 的 pom 文件"></p>
</li>
<li><p>4、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ddb6e32e3faf">自动配置 Spring Bean</a></p>
<p>Spring Boot 检测到特定类的存在，就会针对这个应用做一定的配置，进行自动配置 Bean ，这样会极大地减少我们要使用的配置。</p>
<p>当然，Spring Boot 只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean ，而 Spring Boot 没有提供支持，则可以自定义自动配置进行解决。</p>
</li>
<li><p>5、<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangshuang1631/article/details/72810412">准生产的应用监控</a></p>
<p>Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p>
</li>
<li><p>6、无代码生成和 XML 配置</p>
<p>Spring Boot 没有引入任何形式的代码生成，它是使用的 Spring 4.0 的条件 <code>@Condition</code> 注解以实现根据条件进行配置。同时使用了 Maven /Gradle 的<strong>依赖传递解析机制</strong>来实现 Spring 应用里面的自动配置。</p>
</li>
</ul>
<h3 id="Spring-Boot-有什么优缺点？"><a href="#Spring-Boot-有什么优缺点？" class="headerlink" title="Spring Boot 有什么优缺点？"></a>Spring Boot 有什么优缺点？</h3><p><strong>Spring Boot 的优点</strong></p>
<blockquote>
<p>优点和 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 提供了哪些核心功能？」</a> 问题的答案，是比较重叠的。</p>
</blockquote>
<ul>
<li>1、使【编码】变简单。</li>
<li>2、使【配置】变简单。</li>
<li>3、使【部署】变简单。</li>
<li>4、使【监控】变简单。</li>
</ul>
<p><strong>Spring Boot 的缺点</strong></p>
<blockquote>
<p>如下的缺点，基于 <a target="_blank" rel="noopener" href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a>，考虑的出发点是把 Spring Boot 作为微服务的框架的选型的角度进行考虑。</p>
</blockquote>
<ul>
<li><p>1、没有提供相应的【服务发现和注册】的配套功能。</p>
<blockquote>
<p>艿艿：当然，实际上 Spring Boot 本身是不需要提供这样的功能。服务发现和注册的功能，是在 Spring Cloud 中进行提供。</p>
</blockquote>
</li>
<li><p>2、自身的 acturator 所提供的【监控功能】，也需要与现有的监控对接。</p>
</li>
<li><p>3、没有配套的【安全管控】方案。</p>
<blockquote>
<p>艿艿：关于这一点，艿艿也有点迷糊，Spring Security 是可以比较方便的集成到 Spring Boot 中，所以不晓得这里的【安全管控】的定义是什么。所以这一点，面试的时候回答，可以暂时先省略。</p>
</blockquote>
</li>
<li><p>4、对于 REST 的落地，还需要自行结合实际进行 URI 的规范化工作</p>
<blockquote>
<p>艿艿：这个严格来说，不算缺点。本身，是规范的范畴。</p>
</blockquote>
</li>
</ul>
<p>所以，上面的缺点，严格来说可能不太适合在面试中回答。艿艿认为，Spring Boot 的缺点主要是，因为自动配置 Spring Bean 的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p>
<h3 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别？"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别？"></a>Spring Boot、Spring MVC 和 Spring 有什么区别？</h3><p>Spring 的完整名字，应该是 Spring Framework 。它提供了多个模块，Spring IoC、Spring AOP、Spring MVC 等等。所以，Spring MVC 是 Spring Framework 众多模块中的一个。</p>
<p>而 Spring Boot 是构造在 Spring Framework 之上的 Boot 启动器，旨在更容易的配置一个 Spring 项目。</p>
<p>总结说来，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-26/02.png" alt="Spring Boot 对比 Spring MVC 对比 Spring ？"></p>
<h3 id="Spring-Boot-中的-Starter-是什么？"><a href="#Spring-Boot-中的-Starter-是什么？" class="headerlink" title="Spring Boot 中的 Starter 是什么？"></a>Spring Boot 中的 Starter 是什么？</h3><p>比较<strong>通俗</strong>的说法：</p>
<blockquote>
<p>FROM <a target="_blank" rel="noopener" href="https://www.cnblogs.com/EasonJim/p/7615801.html">《Spring Boot 中 Starter 是什么》</a></p>
<p>比如我们要在 Spring Boot 中引入 Web MVC 的支持时，我们通常会引入这个模块 <code>spring-boot-starter-web</code> ，而这个模块如果解压包出来会发现里面什么都没有，只定义了一些 <strong>POM</strong> 依赖。如下图所示：<a target="_blank" rel="noopener" href="http://static2.iocoder.cn/images/Spring/2018-12-26/03.png"><img src="http://static2.iocoder.cn/images/Spring/2018-12-26/03.png" alt="`spring-boot-starter-web`"></a><code>spring-boot-starter-web</code></p>
<p>经过研究，Starter 主要用来简化依赖用的。比如我们之前做MVC时要引入日志组件，那么需要去找到log4j的版本，然后引入，现在有了Starter之后，直接用这个之后，log4j就自动引入了，也不用关心版本这些问题。</p>
</blockquote>
<p>比较<strong>书名</strong>的说法：</p>
<blockquote>
<p>FROM <a target="_blank" rel="noopener" href="http://www.importnew.com/27101.html">《Spring Boot Starter 介绍》</a></p>
<p>依赖管理是任何复杂项目的关键部分。以手动的方式来实现依赖管理不太现实，你得花更多时间，同时你在项目的其他重要方面能付出的时间就会变得越少。</p>
<p>Spring Boot Starter 就是为了解决这个问题而诞生的。Starter <strong>POM</strong> 是一组方便的依赖描述符，您可以将其包含在应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，无需通过示例代码搜索和复制粘贴依赖。</p>
</blockquote>
<h3 id="Spring-Boot-常用的-Starter-有哪些？"><a href="#Spring-Boot-常用的-Starter-有哪些？" class="headerlink" title="Spring Boot 常用的 Starter 有哪些？"></a>Spring Boot 常用的 Starter 有哪些？</h3><ul>
<li><code>spring-boot-starter-web</code> ：提供 Spring MVC + 内嵌的 Tomcat 。</li>
<li><code>spring-boot-starter-data-jpa</code> ：提供 Spring JPA + Hibernate 。</li>
<li><code>spring-boot-starter-data-redis</code> ：提供 Redis 。</li>
<li><code>mybatis-spring-boot-starter</code> ：提供 MyBatis 。</li>
</ul>
<h3 id="如何统一引入-Spring-Boot-版本？"><a href="#如何统一引入-Spring-Boot-版本？" class="headerlink" title="如何统一引入 Spring Boot 版本？"></a>如何统一引入 Spring Boot 版本？</h3><p><strong>目前有两种方式</strong>。</p>
<p>① 方式一：继承 <code>spring-boot-starter-parent</code> 项目。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>

<p>② 方式二：导入 spring-boot-dependencies 项目依赖。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p><strong>如何选择？</strong></p>
<p>因为一般我们的项目中，都有项目自己的 Maven parent 项目，所以【方式一】显然会存在冲突。</p>
<p>所以实际场景下，推荐使用【方式二】。</p>
<p>详细的，推荐阅读 <a target="_blank" rel="noopener" href="https://blog.csdn.net/rainbow702/article/details/55046298">《Spring Boot 不使用默认的 parent，改用自己的项目的 parent》</a> 文章。</p>
<p>另外，在使用 Spring Cloud 的时候，也可以使用这样的方式。</p>
<h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><ul>
<li>1、打包成 Fat Jar ，直接使用 <code>java -jar</code> 运行。目前主流的做法，推荐。</li>
<li>2、在 IDEA 或 Eclipse 中，直接运行应用的 Spring Boot 启动类的 <code>#main(String[] args)</code> 启动。适用于开发调试场景。</li>
<li>3、如果是 Web 项目，可以打包成 War 包，使用外部 Tomcat 或 Jetty 等容器。</li>
</ul>
<h3 id="如何打包-Spring-Boot-项目？"><a href="#如何打包-Spring-Boot-项目？" class="headerlink" title="如何打包 Spring Boot 项目？"></a>如何打包 Spring Boot 项目？</h3><p>通过引入 <code>spring-boot-maven-plugin</code> 插件，执行 <code>mvn clean package</code> 命令，将 Spring Boot 项目打成一个 Fat Jar 。后续，我们就可以直接使用 <code>java -jar</code> 运行。</p>
<p>关于 <code>spring-boot-maven-plugin</code> 插件，更多详细的可以看看 [《创建可执行 jar》](<a target="_blank" rel="noopener" href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II</a>. Getting started/11.5. Creating an executable jar.html) 。</p>
<h3 id="如果更改内嵌-Tomcat-的端口？"><a href="#如果更改内嵌-Tomcat-的端口？" class="headerlink" title="如果更改内嵌 Tomcat 的端口？"></a>如果更改内嵌 Tomcat 的端口？</h3><ul>
<li><p>方式一，修改 <code>application.properties</code> 配置文件的 <code>server.port</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;9090</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二，通过启动命令增加 <code>server.port</code> 参数进行修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --server.port&#x3D;9090</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，以上的方式，不仅仅适用于 Tomcat ，也适用于 Jetty、Undertow 等服务器。</p>
<h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</h3><p>一共有三种方式，可以实现效果：</p>
<ul>
<li><p>【推荐】<code>spring-boot-devtools</code> 插件。注意，这个工具需要配置 IDEA 的自动编译。</p>
</li>
<li><p>Spring Loaded 插件。</p>
<blockquote>
<p>Spring Boot 2.X 后，官方宣布不再支持 Spring Loaded 插件 的更新，所以基本可以无视它了。</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bab43eaa4e14">JRebel</a> 插件，需要付费。</p>
</li>
</ul>
<p>关于如何使用 <code>spring-boot-devtools</code> 和 Spring Loaded 插件，胖友可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014488100">《Spring Boot 学习笔记：Spring Boot Developer Tools 与热部署》</a> 。</p>
<h3 id="Spring-Boot-的配置文件有哪几种格式？"><a href="#Spring-Boot-的配置文件有哪几种格式？" class="headerlink" title="Spring Boot 的配置文件有哪几种格式？"></a>Spring Boot 的配置文件有哪几种格式？</h3><p>Spring Boot 目前支持两种格式的配置文件：</p>
<ul>
<li><p><code>.properties</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port &#x3D; 9090</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.yaml</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 9090</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>可能有胖友不了解 <strong>YAML 格式</strong>？</p>
<p>YAML 是一种人类可读的数据序列化语言，它通常用于配置文件。</p>
<ul>
<li>与 Properties 文件相比，如果我们想要在配置文件中添加复杂的属性 YAML 文件就更加<strong>结构化</strong>。从上面的示例，我们可以看出 YAML 具有<strong>分层</strong>配置数据。</li>
<li>当然 YAML 在 Spring 会存在一个缺陷，<code>@PropertySource</code>注解不支持读取 YAML 配置文件，仅支持 Properties 配置文件。<ul>
<li>不过这个问题也不大，可以麻烦一点使用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lafengwnagzi/article/details/74178374"><code>@Value</code></a> 注解，来读取 YAML 配置项。</li>
</ul>
</li>
</ul>
<p>实际场景下，艿艿相对比较喜欢使用 Properties 配置文件。个人喜欢~当然，YAML 已经越来越流行了。</p>
<h3 id="Spring-Boot-默认配置文件是什么？"><a href="#Spring-Boot-默认配置文件是什么？" class="headerlink" title="Spring Boot 默认配置文件是什么？"></a>Spring Boot 默认配置文件是什么？</h3><p>对于 Spring Boot 应用，默认的配置文件根目录下的 <strong>application</strong> 配置文件，当然可以是 Properties 格式，也可以是 YAML 格式。</p>
<p>可能有胖友说，我在网上看到面试题中，说还有一个根目录下的 <strong>bootstrap</strong> 配置文件。这个是 Spring Cloud 新增的启动配置文件，<a target="_blank" rel="noopener" href="https://my.oschina.net/freeskyjs/blog/1843048">需要引入 <code>spring-cloud-context</code> 依赖后，才会进行加载</a>。它的特点和用途主要是：</p>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://my.oschina.net/neverforget/blog/1525947">《Spring Cloud 中配置文件名 bootstrap.yml 和 application.yml 区别》</a> 文章。</p>
</blockquote>
<ul>
<li>【特点】因为 bootstrap 由父 ApplicationContext 加载，比 application 优先加载。</li>
<li>【特点】因为 bootstrap 优先于 application 加载，所以不会被它覆盖。</li>
<li>【用途】使用配置中心 Spring Cloud Config 时，需要在 bootstrap 中配置配置中心的地址，从而实现父 ApplicationContext 加载时，从配置中心拉取相应的配置到应用中。</li>
</ul>
<p>另外，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">《Appendix A. Common application properties》</a> 中，有 application 配置文件的通用属性列表。</p>
<h3 id="Spring-Boot-如何定义多套不同环境配置？"><a href="#Spring-Boot-如何定义多套不同环境配置？" class="headerlink" title="Spring Boot 如何定义多套不同环境配置？"></a>Spring Boot 如何定义多套不同环境配置？</h3><p>可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/top_code/article/details/78570047">《Spring Boot 教程 - Spring Boot Profiles 实现多环境下配置切换》</a> 一文。</p>
<p>但是，需要考虑一个问题，生产环境的配置文件的安全性，显然我们不能且不应该把生产的配置放到项目的 Git 仓库中进行管理。那么应该怎么办呢？</p>
<ul>
<li>方案一，生产环境的配置文件放在生产环境的服务器中，以 <code>java -jar myproject.jar --spring.config.location=/xxx/yyy/application-prod.properties</code> 命令，设置 参数 <code>spring.config.location</code> 指向配置文件。</li>
<li>方案二，使用 Jenkins 在执行打包，配置上 Maven Profile 功能，使用服务器上的配置文件。整体来说，和【方案一】的差异是，将配置文件打包进了 Jar 包中。</li>
<li>方案三，使用配置中心。</li>
</ul>
<h3 id="Spring-Boot-配置加载顺序？"><a href="#Spring-Boot-配置加载顺序？" class="headerlink" title="Spring Boot 配置加载顺序？"></a>Spring Boot 配置加载顺序？</h3><p>在 Spring Boot 中，除了我们常用的 application 配置文件之外，还有：</p>
<ul>
<li>系统环境变量</li>
<li>命令行参数</li>
<li>等等…</li>
</ul>
<p>参考 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">《Externalized Configuration》</a> 文档，我们整理顺序如下：</p>
<ol>
<li><p>spring-boot-devtools 依赖的 spring-boot-devtools.properties 配置文件。</p>
<blockquote>
<p>这个灰常小众，具体说明可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011499747/article/details/71746325">《Spring Boot参考文档（12）开发者工具》</a> ，建议无视。</p>
</blockquote>
</li>
<li><p>单元测试上的 @TestPropertySource 和 @SpringBootTest 注解指定的参数。</p>
<blockquote>
<p>前者的优先级高于后者。可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010854607">《Spring、Spring Boot 和TestNG 测试指南 - @TestPropertySource》</a> 一文。</p>
</blockquote>
</li>
<li><p>命令行指定的参数。例如 <code>java -jar springboot.jar --server.port=9090</code> 。</p>
</li>
<li><p>命令行中的 <code>spring.application.json</code> 指定参数。例如 <code>java -Dspring.application.json=&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar</code> 。</p>
</li>
<li><p>ServletConfig 初始化参数。</p>
</li>
<li><p>ServletContext 初始化参数。</p>
</li>
<li><p>JNDI 参数。例如 <code>java:comp/env</code> 。</p>
</li>
<li><p>Java 系统变量，即 <code>System#getProperties()</code> 方法对应的。</p>
</li>
<li><p>操作系统环境变量。</p>
</li>
<li><p>RandomValuePropertySource 配置的 <code>random.*</code> 属性对应的值。</p>
</li>
<li><p>Jar <strong>外部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>外部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>在自定义的 <code>@Configuration</code> 类中定于的 <code>@PropertySource</code> 。</p>
</li>
<li><p>启动的 main 方法中，定义的默认配置。即通过 <code>SpringApplication#setDefaultProperties(Map defaultProperties)</code> 方法进行设置。</p>
</li>
</ol>
<p>嘿嘿，是不是很多很长，不用真的去记住。</p>
<ul>
<li>一般来说，面试官不会因为这个题目回答的不好，对你扣分。</li>
<li>实际使用时，做下测试即可。</li>
<li>每一种配置方式的详细说明，可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015069140">《Spring Boot 参考指南（外部化配置）》</a> 。</li>
</ul>
<h3 id="Spring-Boot-有哪些配置方式？"><a href="#Spring-Boot-有哪些配置方式？" class="headerlink" title="Spring Boot 有哪些配置方式？"></a>Spring Boot 有哪些配置方式？</h3><p>和 Spring 一样，一共提供了三种方式。</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.edureka.firstSpring.StudentBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Edureka&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h3 id="Spring-Boot-的核心注解是哪个？"><a href="#Spring-Boot-的核心注解是哪个？" class="headerlink" title="Spring Boot 的核心注解是哪个？"></a>Spring Boot 的核心注解是哪个？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iocoder.skywalking.web01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web01Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Web01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootApplication</code> 注解，就是 Spring Boot 的核心注解。</li>
</ul>
<p><code>org.springframework.boot.autoconfigure.@SpringBootApplication</code> 注解的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringBootApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackages&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackageClasses&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>它组合了 3 个注解，详细说明，胖友看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/claram/article/details/75125749">《Spring Boot 系列：@SpringBootApplication 注解》</a> 。</p>
</li>
<li><p><code>@Configuration</code> 注解，指定类是 <strong>Bean 定义</strong>的配置类。</p>
<blockquote>
<p><code>@Configuration</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>@ComponentScan</code> 注解，扫描指定包下的 Bean 们。</p>
<blockquote>
<p><code>@ComponentScan</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>@EnableAutoConfiguration</code> 注解，打开自动配置的功能。如果我们想要关闭某个类的自动配置，可以设置注解的 <code>exclude</code> 或 <code>excludeName</code> 属性。</p>
<blockquote>
<p><code>@EnableAutoConfiguration</code> 注解，来自 <code>spring-boot-autoconfigure</code> 项目，<strong>它才是 Spring Boot 新带来的</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="什么是-Spring-Boot-自动配置？"><a href="#什么是-Spring-Boot-自动配置？" class="headerlink" title="什么是 Spring Boot 自动配置？"></a>什么是 Spring Boot 自动配置？</h3><p>在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 的核心注解是哪个？」</a> 中，我们已经看到，使用 <code>@@EnableAutoConfiguration</code> 注解，打开 Spring Boot 自动配置的功能。具体如何实现的，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/464d04c36fb1">《@EnableAutoConfiguration 注解的工作原理》</a> 。</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>建议，能一边调试，一边看这篇文章。调试很简单，任一搭建一个 Spring Boot 项目即可。</li>
</ul>
<p>如下是一个比较简单的总结：</p>
<ol>
<li>Spring Boot 在启动时扫描项目所依赖的 jar 包，寻找包含<code>spring.factories</code> 文件的 jar 包。</li>
<li>根据 <code>spring.factories</code> 配置加载 AutoConfigure 类。</li>
<li>根据 [<code>@Conditional</code> 等条件注解](<a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring-Boot/Interview/Spring">http://svip.iocoder.cn/Spring-Boot/Interview/Spring</a> Boot 条件注解) 的条件，进行自动配置并将 Bean 注入 Spring IoC 中。</li>
</ol>
<h3 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h3><p>Spring Boot 目前支持 <strong>2</strong> 种读取配置：</p>
<ol>
<li><p><code>@Value</code> 注解，读取配置到属性。最最最常用。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
<li><p><code>@ConfigurationProperties</code> 注解，读取配置到类上。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
</ol>
<p>详细的使用方式，可以参考 <a target="_blank" rel="noopener" href="https://aoyouzi.iteye.com/blog/2422837">《Spring Boot 读取配置的几种方式》</a> 。</p>
<h3 id="使用-Spring-Boot-后，项目结构是怎么样的呢？"><a href="#使用-Spring-Boot-后，项目结构是怎么样的呢？" class="headerlink" title="使用 Spring Boot 后，项目结构是怎么样的呢？"></a>使用 Spring Boot 后，项目结构是怎么样的呢？</h3><p>我们先来说说项目的分层。一般来说，主流的有两种方式：</p>
<ul>
<li>方式一，<code>controller</code>、<code>service</code>、<code>dao</code> 三个包，每个包下面添加相应的 XXXController、YYYService、ZZZDAO 。</li>
<li>方式二，按照业务模块分包，每个包里面放 Controller、Service、DAO 类。例如，业务模块分成 <code>user</code>、<code>order</code>、<code>item</code> 等等包，在 <code>user</code> 包里放 UserController、UserService、UserDAO 类。</li>
</ul>
<p>那么，使用 Spring Boot 的项目怎么分层呢？艿艿自己的想法</p>
<ul>
<li>现在项目都会进行服务化分拆，每个项目不会特别复杂，所以建议使用【方式一】。</li>
<li>以前的项目，大多是单体的项目，动则项目几万到几十万的代码，当时多采用【方式二】。</li>
</ul>
<p>下面是一个简单的 Spring Boot 项目的 Demo ，如下所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-26/05.png" alt="Spring Boot 项目的 Demo"></p>
<h3 id="如何在-Spring-Boot-启动的时候运行一些特殊的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特殊的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特殊的代码？"></a>如何在 Spring Boot 启动的时候运行一些特殊的代码？</h3><p>如果需要在 SpringApplication 启动后执行一些特殊的代码，你可以实现 ApplicationRunner 或 CommandLineRunner 接口，这两个接口工作方式相同，都只提供单一的 run 方法，该方法仅在 <code>SpringApplication#run(...)</code> 方法<strong>完成之前调用</strong>。</p>
<p>一般情况下，我们不太会使用该功能。如果真需要，胖友可以详细看看 [《使用 ApplicationRunner 或 CommandLineRunner 》](<a target="_blank" rel="noopener" href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV</a>. Spring Boot features/23.8 Using the ApplicationRunner or CommandLineRunner.html) 。</p>
<h3 id="Spring-Boot-2-X-有什么新特性？"><a href="#Spring-Boot-2-X-有什么新特性？" class="headerlink" title="Spring Boot 2.X 有什么新特性？"></a>Spring Boot 2.X 有什么新特性？</h3><ol>
<li>起步 JDK 8 和支持 JDK 9</li>
<li>第三方库的升级</li>
<li>Reactive Spring</li>
<li>HTTP/2 支持</li>
<li>配置属性的绑定</li>
<li>Gradle 插件</li>
<li>Actuator 改进</li>
<li>数据支持的改进</li>
<li>Web 的改进</li>
<li>支持 Quartz 自动配置</li>
<li>测试的改进</li>
<li>其它…</li>
</ol>
<p>详细的说明，可以看看 <a target="_blank" rel="noopener" href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features">《Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解》</a> 。</p>
<h2 id="整合篇"><a href="#整合篇" class="headerlink" title="整合篇"></a>整合篇</h2><h3 id="如何将内嵌服务器换成-Jetty-？"><a href="#如何将内嵌服务器换成-Jetty-？" class="headerlink" title="如何将内嵌服务器换成 Jetty ？"></a>如何将内嵌服务器换成 Jetty ？</h3><p>默认情况下，<code>spring-boot-starter-web</code> 模块使用 Tomcat 作为内嵌的服务器。所以需要去除对 <code>spring-boot-starter-tomcat</code> 模块的引用，添加 <code>spring-boot-starter-jetty</code> 模块的引用。代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> <span class="comment">&lt;!-- 去除 Tomcat --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- 引入 Jetty --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Spring-Boot-中的监视器-Actuator-是什么？"><a href="#Spring-Boot-中的监视器-Actuator-是什么？" class="headerlink" title="Spring Boot 中的监视器 Actuator 是什么？"></a>Spring Boot 中的监视器 Actuator 是什么？</h3><p><code>spring-boot-actuator</code> 提供 Spring Boot 的监视器功能，可帮助我们访问生产环境中正在运行的应用程序的<strong>当前状态</strong>。</p>
<ul>
<li>关于 Spring Boot Actuator 的教程，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/af9738634a21">《Spring Boot Actuator 使用》</a> 。</li>
<li>上述教程是基于 Spring Boot 1.X 的版本，如果胖友使用 Spring Boot 2.X 的版本，你将会发现 <code>/beans</code> 等 Endpoint 是不存在的，参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/49174700/spring-boot-2-actuator-endpoint-where-is-beans-endpoint">《Spring boot 2 - Actuator endpoint, where is /beans endpoint》</a> 问题来解决。</li>
</ul>
<p><strong>安全性</strong></p>
<p>Spring Boot 2.X 默认情况下，<code>spring-boot-actuator</code> 产生的 Endpoint 是没有安全保护的，但是 Actuator 可能暴露敏感信息。</p>
<p>所以一般的做法是，引入 <code>spring-boot-start-security</code> 依赖，使用 Spring Security 对它们进行安全保护。</p>
<h3 id="如何集成-Spring-Boot-和-Spring-MVC-？"><a href="#如何集成-Spring-Boot-和-Spring-MVC-？" class="headerlink" title="如何集成 Spring Boot 和 Spring MVC ？"></a>如何集成 Spring Boot 和 Spring MVC ？</h3><ol>
<li><p>引入 <code>spring-boot-starter-web</code> 的依赖。</p>
</li>
<li><p>实现 WebMvcConfigurer 接口，可添加自定义的 Spring MVC 配置。</p>
<blockquote>
<p>因为 Spring Boot 2 基于 JDK 8 的版本，而 JDK 8 提供 <code>default</code> 方法，所以 Spring Boot 2 废弃了 WebMvcConfigurerAdapter 适配类，直接使用 WebMvcConfigurer 即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebMvcConfigurer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 配置路径匹配器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 配置内容裁决的一些选项 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 异步相关的配置 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加拦截器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 静态资源处理 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解决跨域问题 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 配置视图解析器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加参数解析器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加返回值处理器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; handlers)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 这里配置视图解析器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 配置消息转换器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 配置异常处理器 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">extendHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Validator <span class="title">getValidator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> MessageCodesResolver <span class="title">getMessageCodesResolver</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<p>在使用 Spring MVC 时，我们一般会做如下几件事情：</p>
<ol>
<li>实现自己项目需要的拦截器，并在 WebMvcConfigurer 实现类中配置。可参见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/MVCConfiguration.java">MVCConfiguration</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 注解，实现全局异常处理。可参见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalExceptionHandler.java">GlobalExceptionHandler</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> ，实现 ResponseBodyAdvice 接口，实现全局统一返回。可参见 <a target="_blank" rel="noopener" href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalResponseBodyAdvice.java">GlobalResponseBodyAdvice</a> 。</li>
</ol>
<p>当然，有一点需要注意，WebMvcConfigurer、ResponseBodyAdvice、<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code> 接口，都是 Spring MVC 框架自身已经有的东西。</p>
<ul>
<li><code>spring-boot-starter-web</code> 的依赖，帮我们解决的是 Spring MVC 的依赖以及相关的 Tomcat 等组件。</li>
</ul>
<h3 id="如何集成-Spring-Boot-和-Spring-Security-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security ？"></a>如何集成 Spring Boot 和 Spring Security ？</h3><p>目前比较主流的安全框架有两个：</p>
<ol>
<li>Spring Security</li>
<li>Apache Shiro</li>
</ol>
<p>对于任何项目来说，安全认证总是少不了，同样适用于使用 Spring Boot 的项目。相对来说，Spring Security 现在会比 Apache Shiro 更流行。</p>
<p>Spring Boot 和 Spring Security 的配置方式比较简单：</p>
<ol>
<li>引入 <code>spring-boot-starter-security</code> 的依赖。</li>
<li>继承 WebSecurityConfigurerAdapter ，添加<strong>自定义</strong>的安全配置。</li>
</ol>
<p>当然，每个项目的安全配置是不同的，需要胖友自己选择。更多详细的使用，建议认真阅读如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.didispace.com/springbootsecurity/">《Spring Boot中 使用 Spring Security 进行安全控制》</a> ，快速上手。</li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Security/good-collection/">《Spring Security 实现原理与源码解析系统 —— 精品合集》</a> ，深入源码。</li>
</ul>
<p>另外，安全是一个很大的话题，感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.jdon.com/49653">《Spring Boot 十种安全措施》</a> 一文。</p>
<h3 id="如何集成-Spring-Boot-和-Spring-Security-OAuth2-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-OAuth2-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security OAuth2 ？"></a>如何集成 Spring Boot 和 Spring Security OAuth2 ？</h3><p>参见 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Security/OAuth2-learning/">《Spring Security OAuth2 入门》</a> 文章，内容有点多。</p>
<h3 id="如何集成-Spring-Boot-和-JPA-？"><a href="#如何集成-Spring-Boot-和-JPA-？" class="headerlink" title="如何集成 Spring Boot 和 JPA ？"></a>如何集成 Spring Boot 和 JPA ？</h3><ol>
<li>引入 <code>spring-boot-starter-data-jpa</code> 的依赖。</li>
<li>在 application 配置文件中，加入 JPA 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a></li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>Spring Boot 2 默认使用的数据库连接池是 <a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> ，目前最好的性能的数据库连接池的实现。</li>
<li><code>spring-boot-starter-data-jpa</code> 的依赖，使用的默认 JPA 实现是 Hibernate 5.X 。</li>
</ul>
<h3 id="如何集成-Spring-Boot-和-MyBatis-？"><a href="#如何集成-Spring-Boot-和-MyBatis-？" class="headerlink" title="如何集成 Spring Boot 和 MyBatis ？"></a>如何集成 Spring Boot 和 MyBatis ？</h3><ol>
<li>引入 <code>mybatis-spring-boot-starter</code> 的依赖。</li>
<li>在 application 配置文件中，加入 MyBatis 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-mybatis/">《一起来学 SpringBoot 2.x | 第七篇：整合 Mybatis》</a></li>
</ul>
<h3 id="如何集成-Spring-Boot-和-RabbitMQ-？"><a href="#如何集成-Spring-Boot-和-RabbitMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RabbitMQ ？"></a>如何集成 Spring Boot 和 RabbitMQ ？</h3><ol>
<li>引入 <code>spring-boot-starter-amqp</code> 的依赖</li>
<li>在 application 配置文件中，加入 RabbitMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq/">《一起来学 SpringBoot 2.x | 第十二篇：初探 RabbitMQ 消息队列》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq-delay/">《一起来学 SpringBoot 2.x | 第十三篇：RabbitMQ 延迟队列》</a></li>
</ul>
<h3 id="如何集成-Spring-Boot-和-Kafka-？"><a href="#如何集成-Spring-Boot-和-Kafka-？" class="headerlink" title="如何集成 Spring Boot 和 Kafka ？"></a>如何集成 Spring Boot 和 Kafka ？</h3><ol>
<li>引入 <code>spring-kafka</code> 的依赖。</li>
<li>在 application 配置文件中，加入 Kafka 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/">《Spring Boot系列文章（一）：SpringBoot Kafka 整合使用》</a></li>
</ul>
<h3 id="如何集成-Spring-Boot-和-RocketMQ-？"><a href="#如何集成-Spring-Boot-和-RocketMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RocketMQ ？"></a>如何集成 Spring Boot 和 RocketMQ ？</h3><ol>
<li>引入 <code>rocketmq-spring-boot</code> 的依赖。</li>
<li>在 application 配置文件中，加入 RocketMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/RocketMQ/start/spring-boot-example">《我用这种方法在 Spring 中实现消息的发送和消费》</a></li>
</ul>
<h3 id="Spring-Boot-支持哪些日志框架？"><a href="#Spring-Boot-支持哪些日志框架？" class="headerlink" title="Spring Boot 支持哪些日志框架？"></a>Spring Boot 支持哪些日志框架？</h3><p>Spring Boot 支持的日志框架有：</p>
<ul>
<li>Logback</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>Java Util Logging</li>
</ul>
<p>默认使用的是 Logback 日志框架，也是目前较为推荐的，具体配置，可以参见 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring-Boot/battcn/v2-config-logs/">《一起来学 SpringBoot 2.x | 第三篇：SpringBoot 日志配置》</a> 。</p>
<p>因为 Log4j2 的性能更加优秀，也有人在生产上使用，可以参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f18a9cff351d">《Spring Boot Log4j2 日志性能之巅》</a> 配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：11:50:21" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring-整体"><a href="#Spring-整体" class="headerlink" title="Spring 整体"></a>Spring 整体</h2><h3 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h3><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<ul>
<li><p>它是轻量级、松散耦合的。</p>
<blockquote>
<p>它的轻量级主要是相对于 EJB 。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</p>
</blockquote>
</li>
<li><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
</li>
<li><p>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</p>
</li>
</ul>
<h3 id="Spring-Framework-中各模块介绍？"><a href="#Spring-Framework-中各模块介绍？" class="headerlink" title="Spring Framework 中各模块介绍？"></a>Spring Framework 中各模块介绍？</h3><p>如下是一张比较早期版本的 Spring Framework 的模块图：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/01.jpg" alt="Spring Framework"></p>
<p><strong>Spring 核心容器</strong></p>
<blockquote>
<p>对应图中，Core Container 。</p>
</blockquote>
<p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li><p>Spring Core</p>
</li>
<li><p>Spring Bean</p>
<blockquote>
<p>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>
</blockquote>
</li>
<li><p>Spring Context</p>
<blockquote>
<p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。</p>
</blockquote>
</li>
<li><p>SpEL (Spring Expression Language)</p>
<blockquote>
<p>Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2 中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置 Bean 定义。</p>
</blockquote>
</li>
</ul>
<p>或者说，这块就是 Spring IoC 。</p>
<p><strong>数据访问</strong></p>
<blockquote>
<p>对应图中，Data Access 。</p>
</blockquote>
<p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
<blockquote>
<p>Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</p>
</blockquote>
</li>
<li><p>ORM (Object Relational Mapping)</p>
<blockquote>
<p>Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。</p>
<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</blockquote>
</li>
<li><p>OXM (Object XML Mappers)</p>
<blockquote>
<p>Spring 提供了一套类似 ORM 的映射机制，用来将 Java 对象和 XML 文件进行映射。这就是 Spring 的对象 XML 映射功能，有时候也成为 XML 的序列化和反序列化。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
<li><p>Transaction</p>
<blockquote>
<p>Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。</p>
</blockquote>
</li>
</ul>
<p><strong>Web</strong></p>
<p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>WebMVC</p>
<blockquote>
<p>MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p>
</blockquote>
</li>
<li><p>WebFlux</p>
<blockquote>
<p>基于 Reactive 库的响应式的 Web 开发框架</p>
<p>不了解的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html">《使用 Spring 5 的 WebFlux 开发反应式 Web 应用》</a></p>
</blockquote>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>Spring 4.0 的一个最大更新是增加了对 Websocket 的支持。</p>
<p>Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</p>
<p>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</p>
</blockquote>
</li>
<li><p><del>Portlet</del> 已经废弃</p>
</li>
</ul>
<p><strong>AOP</strong></p>
<p>该层支持面向切面编程。它包含以下模块：</p>
<ul>
<li><p>AOP</p>
<blockquote>
<p>通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</p>
<p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
</blockquote>
</li>
<li><p>Aspects</p>
<blockquote>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</blockquote>
</li>
<li><p>Instrumentation</p>
<blockquote>
<p>该层为类检测和类加载器实现提供支持。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><p>JMS (Java Messaging Service)</p>
<blockquote>
<p>提供了一个 JMS 集成框架，简化了 JMS API 的使用。</p>
<p>可能有胖友不太了解 JMS ，可以看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpi/p/5559349.html">《JMS(Java消息服务)入门教程》</a> 。</p>
</blockquote>
</li>
<li><p>Test</p>
<blockquote>
<p>该模块为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</blockquote>
</li>
<li><p>Messaging</p>
<blockquote>
<p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
</blockquote>
</li>
</ul>
<h3 id="使用-Spring-框架能带来哪些好处？"><a href="#使用-Spring-框架能带来哪些好处？" class="headerlink" title="使用 Spring 框架能带来哪些好处？"></a>使用 Spring 框架能带来哪些好处？</h3><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<ul>
<li><strong>DI</strong> ：**<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/">Dependency Injection(DI)</a>** 方法，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li><strong>轻量级</strong>：与 EJB 容器相比较，IoC 容器更加趋向于<strong>轻量级</strong>。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li><strong>面向切面编程(AOP)**： Spring 支持面向</strong>切面编程**，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li><strong>集成主流框架</strong>：Spring 并没有闭门造车，Spring <strong>集成</strong>了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照<strong>模块</strong>的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li><strong>便捷的测试</strong>：要 <a target="_blank" rel="noopener" href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/">测试一项用Spring开发的应用程序</a> 十分简单，因为<strong>测试</strong>相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li><strong>Web 框架</strong>：Spring 的 <strong>Web 框架</strong>亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li><strong>事务管理</strong>：Spring 提供了一个便捷的<strong>事务管理</strong>接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
<li><strong>异常处理</strong>：Spring 提供一个方便的 API ，将特定技术的异常(由JDBC, Hibernate, 或 JDO 抛出)转化为一致的、Unchecked 异常。</li>
</ul>
<p>当然，Spring 代码优点的同时，一定会带来相应的缺点：</p>
<ul>
<li>每个框架都有的问题，调试阶段不直观，后期的 bug 对应阶段，不容易判断问题所在。要花一定的时间去理解它。</li>
<li>把很多 JavaEE 的东西封装了，在满足快速开发高质量程序的同时，隐藏了实现细节。</li>
</ul>
<h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h3><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 <a target="_blank" rel="noopener" href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/">RestTemplate</a>、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>视图帮助(View Helper) — Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
<p>当然，感兴趣的胖友，觉得不过瘾，可以看看艿艿基友知秋写的几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-1">《Spring 框架中的设计模式(一)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-2">《Spring 框架中的设计模式(二)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-3">《Spring 框架中的设计模式(三)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-4">《Spring 框架中的设计模式(四)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-5">《Spring 框架中的设计模式(五)》</a></li>
</ul>
<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><blockquote>
<p>下面，我们会将分成 IoC 和 Bean 两部分来分享 Spring 容器的内容。</p>
<ul>
<li>IoC ，侧重在于容器。</li>
<li>Bean ，侧重在于被容器管理的 Bean 。</li>
</ul>
</blockquote>
<h3 id="什么是-Spring-IoC-容器？"><a href="#什么是-Spring-IoC-容器？" class="headerlink" title="什么是 Spring IoC 容器？"></a>什么是 Spring IoC 容器？</h3><blockquote>
<p>注意，正确的拼写是 IoC 。</p>
</blockquote>
<p>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</p>
<ul>
<li>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的<strong>配置元数据</strong> Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码<strong>提供</strong>。</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/02.jpg" alt="Spring IoC"></p>
<h3 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h3><p>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。</p>
<ul>
<li>你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
<p>另外，依赖注入的英文缩写是 Dependency Injection ，简称 DI 。</p>
<h3 id="IoC-和-DI-有什么区别？"><a href="#IoC-和-DI-有什么区别？" class="headerlink" title="IoC 和 DI 有什么区别？"></a>IoC 和 DI 有什么区别？</h3><p><strong>Dependency Injection</strong>原来，它叫 IoC 。</p>
<p>Martin Flower 发话了，是个框架都有 IoC ，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection 。</p>
<p>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob 管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同 Spring 相比，它更早进入我的大脑。一切都是那么朦胧，直至 Spring 出现。</p>
<p>慢慢的，我知道了它还分为三种：</p>
<ul>
<li>Interface Injection（type 1）</li>
<li>Setter Injection（type 2）</li>
<li>Constructor Injection（type 3）。</li>
</ul>
<p>Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。</p>
<p>在 Spring 中，它是一切的基础。Spring 的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>
<h3 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过<strong>三种</strong>方式完成，即：</p>
<blockquote>
<p>上面一个问题的三种方式的英文，下面是三种方式的中文。</p>
</blockquote>
<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
<p>目前，在 Spring Framework 中，仅使用构造函数和 setter 注入这<strong>两种</strong>方式。</p>
<p>那么这两种方式各有什么优缺点呢？</p>
<p>可以简单阅读 <a target="_blank" rel="noopener" href="https://my.oschina.net/itblog/blog/203746">《Spring两种依赖注入方式的比较》</a>，不用太较真。综述来说：</p>
<table>
<thead>
<tr>
<th align="left">构造函数注入</th>
<th align="left">setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">没有部分注入</td>
<td align="left">有部分注入</td>
</tr>
<tr>
<td align="left">不会覆盖 setter 属性</td>
<td align="left">会覆盖 setter 属性</td>
</tr>
<tr>
<td align="left">任意修改都会创建一个新实例</td>
<td align="left">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="left">适用于设置很多属性</td>
<td align="left">适用于设置少量属性</td>
</tr>
</tbody></table>
<ul>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
<h3 id="Spring-中有多少种-IoC-容器？"><a href="#Spring-中有多少种-IoC-容器？" class="headerlink" title="Spring 中有多少种 IoC 容器？"></a>Spring 中有多少种 IoC 容器？</h3><p>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext 。</p>
<p><strong>BeanFactory</strong></p>
<blockquote>
<p>BeanFactory 在 <code>spring-beans</code> 项目提供。</p>
</blockquote>
<p>BeanFactory ，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</p>
<p><strong>ApplicationContext</strong></p>
<blockquote>
<p>ApplicationContext 在 <code>spring-context</code> 项目提供。</p>
</blockquote>
<p>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：</p>
<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
</ul>
<p>另外，ApplicationContext 会自动初始化非懒加载的 Bean 对象们。</p>
<p>详细的内容，感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 一文。源码之前无秘密。简单总结下 BeanFactory 与 ApplicationContext 两者的差异：</p>
<table>
<thead>
<tr>
<th align="left">BeanFactory</th>
<th align="left">ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left">它使用懒加载</td>
<td align="left">它使用即时加载</td>
</tr>
<tr>
<td align="left">它使用语法显式提供资源对象</td>
<td align="left">它自己创建和管理资源对象</td>
</tr>
<tr>
<td align="left">不支持国际化</td>
<td align="left">支持国际化</td>
</tr>
<tr>
<td align="left">不支持基于依赖的注解</td>
<td align="left">支持基于依赖的注解</td>
</tr>
</tbody></table>
<p>另外，BeanFactory 也被称为<strong>低级</strong>容器，而 ApplicationContext 被称为<strong>高级</strong>容器。</p>
<h3 id="请介绍下常用的-BeanFactory-容器？"><a href="#请介绍下常用的-BeanFactory-容器？" class="headerlink" title="请介绍下常用的 BeanFactory 容器？"></a>请介绍下常用的 BeanFactory 容器？</h3><p>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h3 id="请介绍下常用的-ApplicationContext-容器？"><a href="#请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="请介绍下常用的 ApplicationContext 容器？"></a>请介绍下常用的 ApplicationContext 容器？</h3><p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<ul>
<li><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
</li>
</ul>
<p>当然，目前我们更多的是使用 Spring Boot 为主，所以使用的是第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h3 id="列举一些-IoC-的一些好处？"><a href="#列举一些-IoC-的一些好处？" class="headerlink" title="列举一些 IoC 的一些好处？"></a>列举一些 IoC 的一些好处？</h3><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
<h3 id="简述-Spring-IoC-的实现机制？"><a href="#简述-Spring-IoC-的实现机制？" class="headerlink" title="简述 Spring IoC 的实现机制？"></a>简述 Spring IoC 的实现机制？</h3><p>简单来说，Spring 中的 IoC 的实现原理，就是<strong>工厂模式</strong>加<strong>反射机制</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;        </span><br><span class="line">        Fruit f = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            f = (Fruit) Class.forName(className).newInstance();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;            </span><br><span class="line">            e.printStackTrace();        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> f;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        Fruit f = Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);        </span><br><span class="line">        <span class="keyword">if</span>(f != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            f.eat();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Fruit 接口，有 Apple 和 Orange 两个实现类。</li>
<li>Factory 工厂，通过反射机制，创建 <code>className</code> 对应的 Fruit 对象。</li>
<li>Client 通过 Factory 工厂，获得对应的 Fruit 对象。</li>
<li>😈 实际情况下，Spring IoC 比这个复杂很多很多，例如单例 Bean 对象，Bean 的属性注入，相互依赖的 Bean 的处理，以及等等。</li>
</ul>
<p>在基友 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">《面试问烂的 Spring IoC 过程》</a> 的文章中，把 Spring IoC 相关的内容，讲的非常不错。</p>
<h3 id="Spring-框架中有哪些不同类型的事件？"><a href="#Spring-框架中有哪些不同类型的事件？" class="headerlink" title="Spring 框架中有哪些不同类型的事件？"></a>Spring 框架中有哪些不同类型的事件？</h3><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 Bean 用来监听在 ApplicationContext 中发布的事件。如果一个 Bean 实现了 ApplicationListener 接口，当一个ApplicationEvent 被发布以后，Bean 会自动被通知。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllApplicationEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// process event  </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供了以下五种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的 <code>#refresh()</code> 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext 的 <code>#start()</code> 方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 <code>#stop()</code> 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
</ol>
<hr>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发<strong>自定义</strong>的事件。</p>
<p>① 示例自定义的事件的类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomApplicationEvent</span><span class="params">(Object source, <span class="keyword">final</span> String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 为了监听这个事件，还需要创建一个监听器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomApplicationEvent applicationEvent)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// handle event  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 之后通过 ApplicationContext 接口的 <code>#publishEvent(Object event)</code> 方法，来发布自定义事件。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 CustomApplicationEvent 事件</span></span><br><span class="line">CustomApplicationEvent customEvent = <span class="keyword">new</span> CustomApplicationEvent(</span><br><span class="line">    applicationContext, <span class="string">&quot;Test message&quot;</span>);</span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">applicationContext.publishEvent(customEvent);</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
<p>这个问题，胖友可以在回过头看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「什么是 Spring IoC 容器？」</a> 问题，相互对照。</p>
<h3 id="Spring-有哪些配置方式"><a href="#Spring-有哪些配置方式" class="headerlink" title="Spring 有哪些配置方式?"></a>Spring 有哪些配置方式?</h3><p>单纯从 Spring Framework 提供的方式，一共有三种：</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line">&lt;!-- bean definitions go here --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 `` 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class StudentConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public StudentBean myStudent() &#123;</span><br><span class="line">        return new StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h3 id="Spring-支持几种-Bean-Scope-？"><a href="#Spring-支持几种-Bean-Scope-？" class="headerlink" title="Spring 支持几种 Bean Scope ？"></a>Spring 支持几种 Bean Scope ？</h3><blockquote>
<p>这个是一个比较小众的题目，简单了解即可。</p>
</blockquote>
<p>Spring Bean 支持 5 种 Scope ，分别如下：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。<strong>默认</strong></li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
<blockquote>
<p>另外，网络上很多文章说有 Global-session 级别，它是 Portlet 模块独有，目前已经废弃，在 Spring5 中是找不到的。</p>
</blockquote>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，<strong>最后三个才可用</strong>。</p>
<p>再补充一点，开发者是可以<strong>自定义</strong> Bean Scope ，具体可参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/elim168/article/details/75581670">《Spring（10）—— Bean 作用范围（二）—— 自定义 Scope》</a> 。</p>
<p>不错呢，还是那句话，这个题目简单了解下即可，实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。</p>
<h3 id="Spring-Bean-在容器的生命周期是什么样的？"><a href="#Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 在容器的生命周期是什么样的？"></a>Spring Bean 在容器的生命周期是什么样的？</h3><blockquote>
<p>这是一个比较高级的 Spring 的面试题，非常常见，并且答对比较加分。当然，如果实际真正弄懂，需要对 Spring Bean 的源码，有比较好的理解，所以 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码》</a> 系列，该读还是读吧。</p>
</blockquote>
<p>Spring Bean 的<strong>初始化</strong>流程如下：</p>
<ul>
<li><p>实例化 Bean 对象</p>
<ul>
<li><p>Spring 容器根据配置中的 Bean Definition(定义)中<strong>实例化</strong> Bean 对象。</p>
<blockquote>
<p>Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</p>
</blockquote>
</li>
<li><p>Spring 使用依赖注入<strong>填充</strong>所有属性，如 Bean 中所定义的配置。</p>
</li>
</ul>
</li>
<li><p>Aware 相关的属性，注入到 Bean 对象</p>
<ul>
<li>如果 Bean 实现 <strong>BeanNameAware</strong> 接口，则工厂通过传递 Bean 的 beanName 来调用 <code>#setBeanName(String name)</code> 方法。</li>
<li>如果 Bean 实现 <strong>BeanFactoryAware</strong> 接口，工厂通过传递自身的实例来调用 <code>#setBeanFactory(BeanFactory beanFactory)</code> 方法。</li>
</ul>
</li>
<li><p>调用相应的方法，进一步初始化 Bean 对象</p>
<ul>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则调用 <code>#preProcessBeforeInitialization(Object bean, String beanName)</code> 方法。</li>
<li>如果 Bean 实现 <strong>InitializingBean</strong> 接口，则会调用 <code>#afterPropertiesSet()</code> 方法。</li>
<li>如果为 Bean 指定了 <strong>init</strong> 方法（例如 `` 的 <code>init-method</code> 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则将调用 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</li>
</ul>
</li>
</ul>
<p>Spring Bean 的<strong>销毁</strong>流程如下：</p>
<ul>
<li>如果 Bean 实现 <strong>DisposableBean</strong> 接口，当 spring 容器关闭时，会调用 <code>#destroy()</code> 方法。</li>
<li>如果为 bean 指定了 <strong>destroy</strong> 方法（例如 `` 的 <code>destroy-method</code> 属性），那么将调用该方法。</li>
</ul>
<p>整体如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/03.jpg" alt="流程图"></p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/08.png" alt="流程图"></p>
<h3 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h3><p>只有将 Bean <strong>仅</strong>用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<ul>
<li>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <code>或 </code> 中提供了 ``元素的使用。</li>
<li>内部 Bean 总是<strong>匿名</strong>的，并且它们总是作为<strong>原型 Prototype</strong> 。</li>
</ul>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.edureka.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.edureka.Person&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">“Scott</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="什么是-Spring-装配？"><a href="#什么是-Spring-装配？" class="headerlink" title="什么是 Spring 装配？"></a>什么是 Spring 装配？</h3><p>当 Bean 在 Spring 容器中组合在一起时，它被称为<strong>装配</strong>或 <strong>Bean 装配</strong>。Spring 容器需要知道需要什么 Bean 以及容器应该如何使用依赖注入来将 Bean 绑定在一起，同时装配 Bean 。</p>
<blockquote>
<p>装配，和上文提到的 DI 依赖注入，实际是一个东西。</p>
</blockquote>
<p><strong>自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】<strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>自动装配有什么局限？</strong></p>
<blockquote>
<p>艿艿：这个题目，了解下即可，也不是很准确。</p>
</blockquote>
<ul>
<li><p>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
<blockquote>
<p>这种，严格来说，也不能称为局限。因为可以通过配置文件来解决。</p>
</blockquote>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
</li>
</ul>
<h3 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h3><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p>
<ul>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li>
<li>而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
<h3 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h3><p>Spring 框架并没有对<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">单例</a> Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例 Bean 的<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/">线程安全</a>和并发问题，需要开发者自行去搞定。</li>
<li>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Service 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p>
<p>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p>
<h3 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h3><blockquote>
<p>艿艿说：能回答出这个问题的，一般是比较厉害的。</p>
</blockquote>
<p>这是个比较复杂的问题，有能力的胖友，建议看下 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a></p>
<p>感觉，不通过源码，很难解释清楚这个问题。如果看不懂的胖友，可以在认真看完，在星球里，我们一起多交流下。好玩的。</p>
<h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><p>这块内容，实际写在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring Bean」</a> 中比较合适，考虑到后续的问题，都是关于注解的，所以单独起一个大的章节。</p>
<h3 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解，扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 `` 元素在 Spring 配置文件中启用它。</p>
<p>当然，如果胖友是使用 Spring Boot ，默认情况下已经开启。</p>
<h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li>
<li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li>
<li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li>
<li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
<h3 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h3><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。</p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>T T 貌似平时很少用这个注解噢。</li>
</ul>
<h3 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h3><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p>
<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h3><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，您可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p>
<p>例如，应用中有两个类型为 Employee 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(emp1)</span></span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><blockquote>
<p>Spring AOP 的面试题中，大多数都是概念题，主要是对切面的理解。概念点主要有：</p>
<ul>
<li>AOP</li>
<li>Aspect</li>
<li>JoinPoint</li>
<li>PointCut</li>
<li>Advice</li>
<li>Target</li>
<li>AOP Proxy</li>
<li>Weaving</li>
</ul>
</blockquote>
<ul>
<li>在阅读完 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring AOP」</a> 的面试题后，在回过头思考下这些概念点，到底理解了多少。注意，不是背，理解！</li>
</ul>
<p>非常推荐阅读如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a></li>
</ul>
<h3 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h3><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p>
<ul>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以**切面( Aspect )**作为基本单元。</li>
</ul>
<h3 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h3><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p>
<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
</ul>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/04.jpg" alt="流程图"></p>
<h3 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h3><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p>
<ul>
<li>一个方法的执行。</li>
<li>或者是一个异常的处理。</li>
</ul>
<p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h3 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h3><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p>
<blockquote>
<p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p>
</blockquote>
<ul>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
<p>是不是觉得有点绕，实际场景下，其实也不会弄的这么清楚~~</p>
<h3 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h3><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p>
<ul>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ul>
<p>或者，我们在换一种说法：</p>
<ol>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ol>
<h3 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h3><p>Advice ，<strong>通知</strong>。</p>
<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li>
</ul>
<p><strong>有哪些类型的 Advice？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<p>看起来，是不是和拦截器的执行时间，有几分相似。实际上，用于拦截效果的各种实现，大体都是类似的。</p>
<h3 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h3><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p>
<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
<h3 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><p>① <strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
<blockquote>
<p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p>
<p>感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.kailing.pub/article/index/arcid/178.html">《SkyWalking 源码分析之 JavaAgent 工具 ByteBuddy 的应用》</a> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>② <strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p>
<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<p>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; From 《Spring 源码深度解析》P172</span><br><span class="line">&#x2F;&#x2F; Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）</span><br><span class="line">&#x2F;&#x2F; 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。</span><br><span class="line">&#x2F;&#x2F; 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。</span><br><span class="line">&#x2F;&#x2F; 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：</span><br><span class="line">&#x2F;&#x2F;      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。</span><br><span class="line">&#x2F;&#x2F;      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。</span><br><span class="line">&#x2F;&#x2F; 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：</span><br><span class="line">&#x2F;&#x2F;      1&gt; 使用 JDK 原生支持，减少三方依赖</span><br><span class="line">&#x2F;&#x2F;      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;haiq&#x2F;p&#x2F;4304615.html</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，Spring AOP 的代码量不大，与其在窗户外面不清不楚，不如捅破它！感兴趣的胖友，可以撸一撸 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/aop-simple-intro/">《精尽 Spring 源码分析 —— AOP 源码简单导读》</a> 。</li>
</ul>
<p>或者，我们来换一个解答答案：</p>
<p>Spring AOP 中的动态代理主要有两种方式，</p>
<ul>
<li><p>JDK 动态代理</p>
<p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p>
</li>
<li><p>CGLIB 动态代理</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong>使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。</p>
</li>
</ul>
<h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h3><ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h3 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h3><p>Weaving ，<strong>编织</strong>。</p>
<ul>
<li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li>
<li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg" alt="Proxy"></p>
<h3 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h3><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<ul>
<li>基于 <strong>XML</strong> 方式的切面实现。</li>
<li>基于 <strong>注解</strong> 方式的切面实现。</li>
</ul>
<p>目前，主流喜欢使用 <strong>注解</strong> 方式。胖友可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a> 。</p>
<h2 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h2><p>非常推荐阅读如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd">《可能是最漂亮的 Spring 事务管理详解》</a></li>
</ul>
<h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h3 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h3><p>指的是 <strong>ACID</strong> ，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/06.png" alt="事务的特性"></p>
<ol>
<li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h3><p>目前 Spring 提供两种类型的事务管理：</p>
<ul>
<li><strong>声明式</strong>事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li><strong>编程式</strong>事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<p>实际场景下，我们一般使用 Spring Boot + 注解的<strong>声明式</strong>事务。具体的示例，胖友可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cddeca2c9245">《Spring Boot 事务注解详解》</a> 。</p>
<p>另外，也推荐看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xktxoo/article/details/77919508">《Spring 事务管理 － 编程式事务、声明式事务》</a> 一文。</p>
<h3 id="Spring-事务如何和不同的数据持久层框架做集成？"><a href="#Spring-事务如何和不同的数据持久层框架做集成？" class="headerlink" title="Spring 事务如何和不同的数据持久层框架做集成？"></a>Spring 事务如何和不同的数据持久层框架做集成？</h3><p>① 首先，我们先明确下，这里数据持久层框架，指的是 Spring JDBC、Hibernate、Spring JPA、MyBatis 等等。</p>
<p>② 然后，Spring 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PlatformTransactionManager.java</span><br><span class="line"></span><br><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 </span><br><span class="line">    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据情况，提交事务</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据情况，回滚事务</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。</p>
</li>
<li><p>#getTransaction(TransactionDefinition definition)方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。</p>
<ul>
<li>为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。</li>
<li>为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。😈 下面，也会详细解析 TransactionStatus 。</li>
<li>事务 TransactionDefinition 是什么？😈 下面，也会详细解析 TransactionStatus 。</li>
</ul>
</li>
<li><p>#commit(TransactionStatus status)方法，根据 TransactionStatus 情况，提交事务。</p>
<ul>
<li><p>为什么根据 TransactionStatus 情况，进行提交？例如说，带@Transactional注解的的 A 方法，会调用</p>
<p> @Transactional注解的的 B 方法。</p>
<ul>
<li>在 B 方法结束调用后，会执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，此处事务<strong>是不能</strong>、<strong>也不会</strong>提交的。</li>
<li>而是在 A 方法结束调用后，执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，提交事务。</li>
</ul>
</li>
</ul>
</li>
<li><p>#rollback(TransactionStatus status)方法，根据 TransactionStatus 情况，回滚事务。</p>
<ul>
<li>为什么根据 TransactionStatus 情况，进行回滚？原因同 <code>#commit(TransactionStatus status)</code> 方法。</li>
</ul>
</li>
</ul>
<p>③ 再之后，PlatformTransactionManager 有<strong>抽象子</strong>类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 <a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/54910518">模板方法模式</a> ，实现事务整体逻辑的骨架，而抽象 <code>#doCommit(DefaultTransactionStatus status)</code>、<code>#doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现。</p>
<blockquote>
<p>前方高能，即将进入关键的 ④ 步骤。</p>
</blockquote>
<p>④ 最后，不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/07.png" alt="事务的特性"></p>
<ul>
<li>所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。</li>
<li>HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。</li>
<li>DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。</li>
<li>JpaTransactionManager ，和 JPA 的事务管理做集成。</li>
</ul>
<p>如下，是一个比较常见的 XML 方式来配置的事务管理器，使用的是 DataSourceTransactionManager 。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>正如上文所说，它适用于 MyBatis、Spring JDBC 等等。</li>
</ul>
<hr>
<p>😈 是不是很有趣，更多详细的解析，可见如下几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码分析 —— Transaction 源码简单导读》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/transaction-package/">《精尽 MyBatis 源码分析 —— 事务模块》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/Spring-Integration-4/">《精尽 MyBatis 源码解析 —— Spring 集成（四）之事务》</a></li>
</ul>
<h3 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h3><p>做过 Spring 多数据源的胖友，都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p>
<p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p>
<p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p>
<h3 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h3><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">String</td>
<td align="left">可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td align="left">propagation</td>
<td align="left">enum: Propagation</td>
<td align="left">可选的事务传播行为设置</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">enum: Isolation</td>
<td align="left">可选的事务隔离级别设置</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td align="left">boolean</td>
<td align="left">读写或只读事务，默认读写</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">int (in seconds granularity)</td>
<td align="left">事务超时时间设置</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td align="left">Class对象数组，必须继承自Throwable</td>
<td align="left">导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">rollbackForClassName</td>
<td align="left">类名数组，必须继承自Throwable</td>
<td align="left">导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td align="left">noRollbackFor</td>
<td align="left">Class对象数组，必须继承自Throwable</td>
<td align="left">不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">noRollbackForClassName</td>
<td align="left">类名数组，必须继承自Throwable</td>
<td align="left">不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<ul>
<li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li>
</ul>
<p>具体<strong>用法</strong>如下：</p>
<ul>
<li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
<li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。</li>
</ul>
<hr>
<p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p>
<p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 事务的隔离级别</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>; <span class="comment">// 事务的超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 事务的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能会胖友有以后，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li>
<li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li>
<li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li>
</ul>
<h3 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h3><p>关于这个问题，涉及的内容会比较多，胖友直接看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25419593">《数据库四大特性以及事务隔离级别》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4e3edbedb9a8">《五分钟搞清楚 MySQL 事务隔离级别》</a></li>
</ul>
<p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p>
<p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【Spring 独有】使用后端数据库默认的隔离级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MySQL 默认采用的 REPEATABLE_READ隔离级别</span></span><br><span class="line"><span class="comment"> * Oracle 默认采用的 READ_COMMITTED隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;</span><br></pre></td></tr></table></figure>



<h3 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h3><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p>
<ul>
<li>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</li>
<li>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</li>
</ul>
<p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 不支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的事务。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 其他情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则等价于 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_REQUIRED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p>
</li>
<li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而</p>
<p> PROPAGATION_NESTED是 Spring 所特有的。</p>
<ul>
<li>以 <code>PROPAGATION_NESTED</code> 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li>
<li>当然，虽然上面 <code>PROPAGATION_NESTED</code> 文字很长，实际我们基本没用过。或者说，去掉基本，我们根本没用过。</li>
</ul>
</li>
</ul>
<h3 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p>
<p>当然，这个属性，貌似我们基本也没用过。</p>
<h3 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p>
<ul>
<li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li>
<li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/uniquejava/blog/80954">《不使用事务和使用只读事务的区别 》</a> 。</li>
</ul>
<p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p>
<h3 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h3><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p>
<ul>
<li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。</li>
<li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li>
</ul>
<p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p>
<h3 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h3><blockquote>
<p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p>
</blockquote>
<p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionStatus.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是新创建的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有 Savepoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 flush 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否事务已经完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li>
<li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？答案结合 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring 事务如何和不同的数据持久层框架做集成？」</a> 问题，我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li>
</ul>
<h3 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h3><ol>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ol>
<p>从倾向上来说，艿艿比较喜欢<strong>注解</strong> + 声明式事务。</p>
<h2 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h2><h3 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>JPA</li>
<li>MyBatis</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html">JDO</a></li>
<li><a target="_blank" rel="noopener" href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html">OJB</a></li>
</ul>
<p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p>
<h3 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h3><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p>
<p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>没有使用过的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.tianmaying.com/tutorial/spring-jdbc-data-accessing">《Spring JDBC 访问关系型数据库》</a> 文章。</p>
<h3 id="Spring-数据数据访问层有哪些异常？"><a href="#Spring-数据数据访问层有哪些异常？" class="headerlink" title="Spring 数据数据访问层有哪些异常？"></a>Spring 数据数据访问层有哪些异常？</h3><p>通过使用 Spring 数据数据访问层，它统一了各个数据持久层框架的不同异常，统一进行提供 <code>org.springframework.dao.DataAccessException</code> 异常及其子类。如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/09.jpg" alt="流程图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Seif Zheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Seif Zheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fatefrank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fatefrank" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:astutenicol@gmail.com" title="E-Mail → mailto:astutenicol@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seif Zheng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
