<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fatefrank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Seif Zheng&#39;s blog">
<meta property="og:url" content="http://fatefrank.github.io/index.html">
<meta property="og:site_name" content="Seif Zheng&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Seif Zheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fatefrank.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Seif Zheng's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seif Zheng's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日积月累，水滴石穿</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fatefrank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-04 11:08:09" itemprop="dateCreated datePublished" datetime="2020-08-04T11:08:09+08:00">2020-08-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/01/Java%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/Java%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【并发】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-01T00:00:00+08:00">2020-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 16:48:39" itemprop="dateModified" datetime="2020-08-05T16:48:39+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简述线程、进程、程序的基本概念？"><a href="#简述线程、进程、程序的基本概念？" class="headerlink" title="简述线程、进程、程序的基本概念？"></a>简述线程、进程、程序的基本概念？</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序，是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程，是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程，与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>另外，Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的。感兴趣的胖友，可以看 <a target="_blank" rel="noopener" href="http://landcareweb.com/questions/33900/javazhong-de-qing-liang-ji-xian-cheng">《Java 中的轻量级线程？》</a> 的讨论，没准未来 Java 也有内置的协程（Coroutine）。</p>
</blockquote>
<h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul>
<li>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
<h3 id="线程有什么优缺点？"><a href="#线程有什么优缺点？" class="headerlink" title="线程有什么优缺点？"></a>线程有什么优缺点？</h3><p>1）好处</p>
<ul>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载。</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好。</li>
</ul>
<p>2）坏处</p>
<ul>
<li>大量的线程降低代码的可读性。</li>
<li>更多的线程需要更多的内存空间。</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<h3 id="你了解守护线程吗？它和非守护线程有什么区别？"><a href="#你了解守护线程吗？它和非守护线程有什么区别？" class="headerlink" title="你了解守护线程吗？它和非守护线程有什么区别？"></a>你了解守护线程吗？它和非守护线程有什么区别？</h3><p>Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p>
<ul>
<li>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread#setDaemon(boolean on)</code> 设置。<code>true</code> 则把该线程设置为守护线程，反之则为用户线程。</li>
<li><code>Thread#setDaemon(boolean on)</code> 方法，必须在<code>Thread#start()</code> 方法之前调用，否则运行时会抛出异常。</li>
</ul>
<p>唯一的区别是：</p>
<blockquote>
<p>程序运行完毕，JVM 会等待非守护线程完成后关闭，但是 JVM 不会等待守护线程。</p>
</blockquote>
<ul>
<li>判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。</li>
<li>也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程。比如，JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
<p>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程。可能会有：服务守护进程、编译守护进程、Windows 下的监听 Ctrl + break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<p>关于守护线程的各种骚操作，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/50392298">《Java 守护线程概述》</a> 。</p>
<h3 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<blockquote>
<p>简单的说，ThreadGroup 为了方便线程的管理。</p>
</blockquote>
<p>为什么不推荐使用？ThreadGroup API 比较薄弱，它并没有比 Thread 提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(uncaught exception handler)。但在 Java5 中 Thread 类也添加了 <code>#setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code> 方法，所以 ThreadGroup 是已经过时的，不建议继续使用。</p>
<h2 id="什么是多线程上下文切换？"><a href="#什么是多线程上下文切换？" class="headerlink" title="什么是多线程上下文切换？"></a>什么是多线程上下文切换？</h2><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p>
<p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。</p>
<ul>
<li>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</li>
<li>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>
<h3 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h3><p>假设计算机只有一个 CPU ，则在任意时刻只能执行一条机器指令，每个线程只有获得 CPU 的使用权才能执行指令。</p>
<ul>
<li>所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。</li>
<li>在运行池中，会有多个处于就绪状态的线程在等待 CPU ，Java 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</li>
</ul>
<p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li><p>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
</li>
<li><p>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</p>
<blockquote>
<p>如非特别需要，尽量不要用，防止线程饥饿。</p>
</blockquote>
</li>
</ul>
<h3 id="什么是线程饥饿？"><a href="#什么是线程饥饿？" class="headerlink" title="什么是线程饥饿？"></a>什么是线程饥饿？</h3><p>饥饿，一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。</p>
<ul>
<li>我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h2 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h2><p>线程一共有五个状态，分别如下：</p>
<ul>
<li><p>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：<code>Thread t1 = new Thread()</code> 。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：<code>t1.start()</code> 。</p>
<blockquote>
<p>有些文章，会称可运行(runnable)为就绪，意思是一样的。</p>
</blockquote>
</li>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（<code>#run()</code> 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<ul>
<li>自然终止：正常运行完 <code>#run()</code>方法，终止。</li>
<li>异常终止：调用 <code>#stop()</code> 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>堵塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
<ul>
<li><p>正在睡眠：调用 <code>#sleep(long t)</code> 方法，可使线程进入睡眠方式。</p>
<blockquote>
<p>一个睡眠着的线程在指定的时间过去可进入可运行(runnable)状态。</p>
</blockquote>
</li>
<li><p>正在等待：调用 <code>#wait()</code> 方法。</p>
<blockquote>
<p>调用 <code>notify()</code> 方法，回到就绪状态。</p>
</blockquote>
</li>
<li><p>被另一个线程所阻塞：调用 <code>#suspend()</code> 方法。</p>
<blockquote>
<p>调用 <code>#resume()</code> 方法，就可以恢复。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>整体如下图所示：</p>
<p><img src="http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c" alt="img"></p>
<ul>
<li>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</li>
<li>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。****</li>
<li>理解线程的状态，可以用早起坐地铁来比喻这个过程：<ul>
<li>还没起床：sleeping 。</li>
<li>起床收拾好了，随时可以坐地铁出发：Runnable 。</li>
<li>等地铁来：Waiting 。</li>
<li>地铁来了，但要排队上地铁：I/O 阻塞 。</li>
<li>上了地铁，发现暂时没座位：synchronized 阻塞。</li>
<li>地铁上找到座位：Running 。</li>
<li>到达目的地：Dead 。</li>
</ul>
</li>
</ul>
<p>如下是另外一个图，把阻塞的情况，放在了一起，也可以作为参考：</p>
<p><img src="http://static2.iocoder.cn/3281138331173cdd53d1364f9c56d594" alt="img"></p>
<p>无意中，又看到一张画的更牛逼的，如下图：</p>
<p><img src="http://static2.iocoder.cn/5eeec5f68f4fc412246efd4111d6fdec" alt="img"></p>
<h3 id="如何结束一个一直运行的线程？"><a href="#如何结束一个一直运行的线程？" class="headerlink" title="如何结束一个一直运行的线程？"></a>如何结束一个一直运行的线程？</h3><p>一般来说，有两种方式：</p>
<ul>
<li><p>方式一，使用退出标志，这个 flag 变量要多线程可见。</p>
<blockquote>
<p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p>
</blockquote>
</li>
<li><p>方式二，使用 interrupt 方法，结合 isInterrupted 方法一起使用。</p>
<blockquote>
<p>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 <code>Thread#join()</code> 方法，或者 <code>Thread#sleep(...)</code> 方法，在网络中调用<code>ServerSocket#accept()</code> 方法，或者调用了<code>DatagramSocket#receive()</code> 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时。即使主程序中将该线程的共享变量设置为 <code>true</code> ，但该线程此时根本无法检查循环标志，当然也就无法立即中断。</p>
<p>这里我们给出的建议是，不要使用 <code>Thread#stop()· 方法，而是使用 Thread 提供的</code>#interrupt()` 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p>
</blockquote>
</li>
</ul>
<p>所以，方式一和方式二，并不是冲突的两种方式，而是可能根据实际场景下，进行结合。</p>
<h3 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h3><p>如果这个异常没有被捕获的话，这个线程就停止执行了。</p>
<p>另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p>
<h2 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h2><p>Java 中创建线程主要有三种方式：</p>
<blockquote>
<p>具体的每种方式的代码实现，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012973218/article/details/51280044">《Java创建线程的四种方式》</a> 。</p>
<p>关于文章中的方式四，实际是基于线程池的方式，使用下面的三种方式，也是生产实践中，最为推荐和常用的方式。</p>
</blockquote>
<ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li><p>使用方式一</p>
<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 <code>Thread#currentThread()</code> 方法，直接使用 <code>this</code> 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li><p>使用方式二、或方式三</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p>
</li>
<li><p>在这种方式下，多个线程可以共享同一个 <code>target</code> 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable runner &#x3D; new Runnable()&#123; ... &#125;;</span><br><span class="line">&#x2F;&#x2F; 通过new Thread(target, name) 方法创建新线程</span><br><span class="line">new Thread(runna,&quot;新线程1&quot;).start();</span><br><span class="line">new Thread(runna,&quot;新线程2&quot;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>当然，实际比较少这么用。</li>
</ul>
</li>
<li><p>【最重要】<strong>可以使用线程池</strong>。</p>
</li>
</ul>
</li>
<li><p>缺点：编程稍微复杂，如果要访问当前线程，则必须使用<code>Thread#currentThread()</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="start-和-run-方法有什么区别？"><a href="#start-和-run-方法有什么区别？" class="headerlink" title="start 和 run 方法有什么区别？"></a>start 和 run 方法有什么区别？</h3><ul>
<li>当你调用 start 方法时，你将创建新的线程，并且执行在 run 方法里的代码。</li>
<li>但是如果你直接调用 run 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。</li>
</ul>
<h3 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h3><p>如果异常没有被捕获该线程将会停止执行。<code>Thread.UncaughtExceptionHandler</code> 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 <code>Thread#getUncaughtExceptionHandler()</code> 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 <code>#uncaughtException(exception)</code> 方法进行处理。</p>
<p>具体的使用，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/50417822">《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》</a> 。</p>
<h2 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h2><blockquote>
<p>wait + notify 对于大多数胖友，一开始理解可能会比较困难，多看多理解吧。</p>
</blockquote>
<p>在 Java 发展史上，曾经使用 suspend、resume 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p>
<p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait 和 notify方法实现线程阻塞。</p>
<ul>
<li>首先，wait、notify 方法是针对对象的，调用任意对象的 wait 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行。</li>
<li>其次，wait、notify 方法必须在 <code>synchronized</code> 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li>
</ul>
<p>具体的实现，看看 <a target="_blank" rel="noopener" href="https://juejin.im/entry/5a2bb783f265da43163cff74">《Wait / Notify通知机制解析》</a> 文章。</p>
<p>通过 wait + notify 的组合，可以通知机制，不过我们也可以使用其它工具，胖友可以思考下。例如如下的每一个方式：</p>
<ul>
<li>Condition</li>
<li>CountDownLatch</li>
<li>Queue</li>
<li>Future</li>
<li>…</li>
</ul>
<blockquote>
<p>艿艿：这个问题可以衍生下，Java 如何实现多线程之间的通讯和协作？具体的可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoucheng05_13/article/details/78311179">《Java多线程——线程间协作方式总结及使用示例》</a> 文章，当然不仅限于该文章所提供的方式。😈 胖友可以认真思索下。</p>
</blockquote>
<h3 id="Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？"></a>Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？</h3><blockquote>
<p>关于这个问题，可以结合 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「线程的生命周期？」</a> 问题的图，一起瞅瞅。</p>
</blockquote>
<ul>
<li>sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li>
<li>wait 方法，是 Object 类的方法。调用对象的 <code>#wait()</code> 方法，会导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 <code>#notify()</code> 方法（或<code>#notifyAll()</code>方法）时，才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<h3 id="请说出与线程同步以及线程调度相关的方法？"><a href="#请说出与线程同步以及线程调度相关的方法？" class="headerlink" title="请说出与线程同步以及线程调度相关的方法？"></a>请说出与线程同步以及线程调度相关的方法？</h3><ul>
<li>wait 方法，使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁。</li>
<li>sleep 方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常。</li>
<li>notify 方法，唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</li>
<li>notityAll 方法，唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</li>
</ul>
<h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify 和 notifyAll 有什么区别？"></a>notify 和 notifyAll 有什么区别？</h3><p>当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。</p>
<ul>
<li>使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。</li>
<li>如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。</li>
</ul>
<p>关于 notify 的信息丢失，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91d95bb5a4bd">《wait 和 notify 的坑》</a> 文章。</p>
<h3 id="为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？"><a href="#为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？" class="headerlink" title="为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？"></a>为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？</h3><p>一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。</p>
<h3 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h3><ul>
<li>Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</li>
</ul>
<h3 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>所以，我们不能写 <code>if (condition)</code> 而应该是 <code>while (condition)</code> ，特别是 CAS 竞争的时候。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The standard idiom for using the wait method</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (condition does not hold) &#123;</span><br><span class="line">        obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外，也可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35181209/article/details/77362297">《wait 必须放在 while 循环里面的原因探析》</a></li>
</ul>
<h2 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h2><p>1）sleep 方法</p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有<code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 <code>synchronized</code>)，一个线程优先级为<code>MAX_PRIORITY</code> ，另一个为 <code>MIN_PRIORITY</code> 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 <code>#sleep(5000)</code> 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p>2）yield 方法</p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p>3）join 方法</p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 的尾部。在线程 A 执行完毕之前，线程 B 不能工作。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t &#x3D; new MyThread();</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 <code>t</code> 完成为止。然而，如果它加入的线程 <code>t</code> 没有存活，则当前线程不需要停止。</li>
</ul>
<h3 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep 方法和 yield 方法有什么区别？"></a>线程的 sleep 方法和 yield 方法有什么区别？</h3><ul>
<li>sleep 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。yield 方法只会给相同优先级或更高优先级的线程以运行的机会。</li>
<li>线程执行 sleep 方法后转入阻塞（blocked）状态，而执行 yield 方法后转入就绪（ready）状态。</li>
<li>sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。</li>
<li>sleep 方法比 yield 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</li>
</ul>
<blockquote>
<p>艿艿：实际场景下，我们很少使用 yield 方法噢。</p>
</blockquote>
<h3 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep 和 yield 方法是静态的？"></a>为什么 Thread 类的 sleep 和 yield 方法是静态的？</h3><p>Thread 类的 sleep 和 yield 方法，将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h3 id="sleep-0-有什么用途？"><a href="#sleep-0-有什么用途？" class="headerlink" title="sleep(0) 有什么用途？"></a>sleep(0) 有什么用途？</h3><p><code>Thread#sleep(0)</code> 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 <code>Thread#sleep(0)</code> 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。<code>Thread#sleep(0)</code> 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个<strong>让位动作</strong>。</p>
<p>感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaoquan3/article/details/56281092">《Sleep(0) 的妙用》</a> 的示例。</p>
<h3 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</h3><blockquote>
<p>考点，就是 join 方法。</p>
</blockquote>
<p>我们可以使用 Thread 类的 <code>#join()</code> 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h2 id="interrupted-和-isInterrupted-方法的区别？"><a href="#interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="interrupted 和 isInterrupted 方法的区别？"></a>interrupted 和 isInterrupted 方法的区别？</h2><p>1）interrupt 方法</p>
<p><code>Thread#interrupt()</code> 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>2）interrupted</p>
<p><code>Thread#interrupted()</code> <strong>静态</strong>方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 <code>#interrupted()</code> 方法则返回 <code>true</code> ，第二次和后面的就返回 <code>false</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true); &#x2F;&#x2F; 清理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>

<p>3）interrupted</p>
<p><code>Thread#isInterrupted()</code> 方法，查询指定线程的中断状态，不会清除原状态。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return isInterrupted(false); &#x2F;&#x2F; 不清楚</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>



<h2 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h2><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="Servlet-是线程安全吗？"><a href="#Servlet-是线程安全吗？" class="headerlink" title="Servlet 是线程安全吗？"></a>Servlet 是线程安全吗？</h3><p>Servlet 不是线程安全的，Servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<h3 id="Struts2-是线程安全吗？"><a href="#Struts2-是线程安全吗？" class="headerlink" title="Struts2 是线程安全吗？"></a>Struts2 是线程安全吗？</h3><p>Struts2 的 Action 是多实例多线程的，是线程安全的，每个请求过来都会 <code>new</code> 一个新的 Action 分配给这个请求，请求完成后销毁。</p>
<h3 id="SpringMVC-是线程安全吗？"><a href="#SpringMVC-是线程安全吗？" class="headerlink" title="SpringMVC 是线程安全吗？"></a>SpringMVC 是线程安全吗？</h3><p>不是的，和 Servlet 类似的处理流程。</p>
<h3 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h3><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：非线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
<h2 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h2><p>1）<strong>线程同步</strong></p>
<p>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：<ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p>2）<strong>线程互斥</strong></p>
<p>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<h3 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h3><p>在两个线程间<strong>共享变量</strong>，即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>调用 <code>Thread#holdsLock(Object obj)</code> <strong>静态</strong>方法，它返回 <code>true</code> 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public static native boolean holdsLock(Object obj);</span><br></pre></td></tr></table></figure>

<h3 id="10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>10 个线程和 2 个线程的同步代码，哪个更容易写？</h3><p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。</p>
<p>但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h2 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h2><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<p>它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。</p>
<ul>
<li>首先，通过复用减少了代价高昂的对象的创建个数。</li>
<li>其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</li>
</ul>
<p>😈 所以，ThreadLocal 很适合实现线程级的单例。</p>
<p>详细的，可以看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920407.html">《Java并发编程：深入剖析ThreadLocal》</a> 文章。</p>
<p>关于源码，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadLocal/?vip">《【死磕 Java 并发】—– 深入分析 ThreadLocal》</a> 。</p>
<h3 id="什么是-InheritableThreadLocal-？"><a href="#什么是-InheritableThreadLocal-？" class="headerlink" title="什么是 InheritableThreadLocal ？"></a>什么是 InheritableThreadLocal ？</h3><p>InheritableThreadLocal 类，是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，<strong>InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值</strong>。</p>
<ul>
<li>具体的实现原理，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ni357103403/article/details/51970748">《Java 多线程：InheritableThreadLocal 实现原理》</a> 文章。</li>
<li>具体的使用示例，可以看看 <a target="_blank" rel="noopener" href="http://blog.didispace.com/Spring-Cloud%E4%B8%ADHystrix-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%AF%BC%E8%87%B4ThreadLocal%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/">《Spring Cloud中Hystrix 线程隔离导致ThreadLocal数据丢失》</a> 。</li>
</ul>
<h3 id="在多线程环境下，SimpleDateFormat-是线程安全的吗？"><a href="#在多线程环境下，SimpleDateFormat-是线程安全的吗？" class="headerlink" title="在多线程环境下，SimpleDateFormat 是线程安全的吗？"></a>在多线程环境下，SimpleDateFormat 是线程安全的吗？</h3><p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，<strong>如将 SimpleDateFormat 限制在 ThreadLocal 中</strong>。</p>
<p>如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h2 id="如何在-Java-中获取线程堆栈？"><a href="#如何在-Java-中获取线程堆栈？" class="headerlink" title="如何在 Java 中获取线程堆栈？"></a>如何在 Java 中获取线程堆栈？</h2><ul>
<li><p><code>kill -3 [java pid]</code></p>
<p>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如， <code>kill -3 tomcat pid</code> , 输出堆栈到 log 目录下。</p>
</li>
<li><p><code>Jstack [java pid]</code></p>
<p>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a3b92def265da4319567218"><code>JVisualVM：Thread Dump</code></a></p>
<p>不做说明，打开 JVisualVM 后，都是界面操作，过程还是很简单的。</p>
</li>
</ul>
<h2 id="什么是Java-Timer-类？"><a href="#什么是Java-Timer-类？" class="headerlink" title="什么是Java Timer 类？"></a>什么是Java Timer 类？</h2><p><code>java.util.Timer</code> ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。</p>
<p><code>java.util.TimerTask</code> ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。</p>
<p>目前有开源的 Qurtz 可以用来创建定时任务。</p>
<h2 id="你有哪些多线程开发良好的实践？"><a href="#你有哪些多线程开发良好的实践？" class="headerlink" title="你有哪些多线程开发良好的实践？"></a>你有哪些多线程开发良好的实践？</h2><ul>
<li><p>1、给线程命名。</p>
<blockquote>
<p>这样可以方便找 bug 或追踪。OrderProcessor、QuoteProcessor、TradeProcessor 这种名字比 Thread-1、Thread-2、Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
</blockquote>
</li>
<li><p>2、最小化同步范围。</p>
<blockquote>
<p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
</blockquote>
</li>
<li><p>3、优先使用 <code>volatile</code> ，而不是 <code>synchronized</code> 。</p>
</li>
<li><p>4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。</p>
<blockquote>
<p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。</p>
<p>其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
</blockquote>
</li>
<li><p>5、优先使用并发容器，而非同步容器。</p>
<blockquote>
<p>这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。</p>
</blockquote>
</li>
<li><p>6、考虑使用线程池。</p>
</li>
</ul>
<h2 id="并发编程和并行编程有什么区别？"><a href="#并发编程和并行编程有什么区别？" class="headerlink" title="并发编程和并行编程有什么区别？"></a>并发编程和并行编程有什么区别？</h2><p>并发（Concurrency）和并行（Parallellism）是：</p>
<ul>
<li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。</li>
<li>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。</li>
</ul>
<p>所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="同步和异步有何异同，在什么情况下分别使用他们？"><a href="#同步和异步有何异同，在什么情况下分别使用他们？" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？"></a>同步和异步有何异同，在什么情况下分别使用他们？</h2><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行<strong>同步</strong>存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用<strong>异步</strong>编程，在很多情况下采用异步途径往往更有效率。</p>
<blockquote>
<p>当然，如果我们对效率没有特别大的要求，也不一定需要使用异步编程，因为它会带来编码的复杂性。总之，合适才是正确的。</p>
</blockquote>
<h2 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a>synchronized 的原理是什么?</h2><p><code>synchronized</code>是 Java 内置的关键字，它提供了一种独占的加锁方式。</p>
<ul>
<li><code>synchronized</code>的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</li>
<li>然而，synchronized 也有一定的局限性。<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li>
</ul>
</li>
</ul>
<p>关于原理，直接阅读 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/synchronized/?vip">《【死磕 Java 并发】—– 深入分析 synchronized 的实现原理》</a> 文章，有几个重点要注意看。</p>
<ul>
<li>实现原理</li>
<li>Java 对象头、Monitor</li>
<li>锁优化<ul>
<li>自旋锁<ul>
<li>适应自旋锁</li>
</ul>
</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>锁的升级<ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个 <code>synchronized</code> 的实例方法后，其它线程是否可进入此对象的其它方法？</h3><ul>
<li>如果其他方法没有 <code>synchronized</code> 的话，其他线程是可以进入的。</li>
<li>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</li>
</ul>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h3><p>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。<strong>线程在获取锁之前不允许执行同步代码</strong>。</p>
<h3 id="Java-如何实现“自旋”（spin）"><a href="#Java-如何实现“自旋”（spin）" class="headerlink" title="Java 如何实现“自旋”（spin）"></a>Java 如何实现“自旋”（spin）</h3><p>参考 <a target="_blank" rel="noopener" href="http://ifeve.com/java_lock_see1/">《Java 锁的种类以及辨析（一）：自旋锁》</a></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign &#x3D;new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123; &#x2F;&#x2F; &lt;1&gt;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        while(!sign .compareAndSet(null, current)) &#123;</span><br><span class="line">            &#x2F;&#x2F; &lt;1.1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock () &#123; &#x2F;&#x2F; &lt;2&gt;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 处，<code>#lock()</code> 方法，如果获得不到锁，就会“死循环”，直到或得到锁为止。考虑到“死循环”会持续占用 CPU ，可能导致其它线程无法获得到 CPU 执行，可以在 <code>&lt;1.1&gt;</code> 处增加 <code>Thread.yiead()</code> 代码段，出让下 CPU 。</li>
<li><code>&lt;2&gt;</code> 处，<code>#unlock()</code> 方法，释放锁。</li>
</ul>
<h2 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h2><p><code>volatile</code> 涉及的内容，其实蛮多的，所以胖友直接看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/volatile/?vip">《【死磕 Java 并发】—– 深入分析 volatile 的实现原理》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ftf-java-volatile">聊聊并发（一）——深入分析Volatile的实现原理</a></li>
</ul>
<h3 id="volatile-有什么用？"><a href="#volatile-有什么用？" class="headerlink" title="volatile 有什么用？"></a>volatile 有什么用？</h3><p><code>volatile</code> 保证内存可见性和禁止指令重排。</p>
<blockquote>
<p>同时，<code>volatile</code> 可以提供部分原子性。</p>
</blockquote>
<p>简单来说，<code>volatile</code> 用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><ul>
<li><code>volatile</code> 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 <code>volatile</code> 修饰 <code>count</code> 变量，那么 <code>count++</code> 操作就不是原子性的。</li>
<li>AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 <code>#getAndIncrement()</code> 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h3 id="可以创建-volatile-数组吗"><a href="#可以创建-volatile-数组吗" class="headerlink" title="可以创建 volatile 数组吗?"></a>可以创建 volatile 数组吗?</h3><p>Java 中可以创建 <code>volatile</code> 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 <code>volatile</code> 的保护，但是如果多个线程同时改变数组的元素，<code>volatile</code> 标示符就不能起到之前的保护作用了。</p>
<p>同理，对于 Java POJO 类，使用 <code>volatile</code> 修饰，只能保证这个引用的可见性，不能保证其内部的属性。</p>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗"><a href="#volatile-能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗?"></a>volatile 能使得一个非原子操作变成原子操作吗?</h3><p>一个典型的例子是在类中有一个 <code>long</code> 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 <code>volatile</code> 。为什么？因为 Java 中读取 <code>long</code> 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 <code>long</code> 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子。</p>
<blockquote>
<p>如下的内容，可以作为上面的内容的补充。</p>
<p>一种实践是用 <code>volatile</code> 修饰 <code>long</code> 和 <code>double</code> 变量，使其能按原子类型来读写。<code>double</code> 和 <code>long</code> 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子的。</p>
</blockquote>
<h3 id="volatile-类型变量提供什么保证？"><a href="#volatile-类型变量提供什么保证？" class="headerlink" title="volatile 类型变量提供什么保证？"></a>volatile 类型变量提供什么保证？</h3><p><code>volatile</code> 主要有两方面的作用：</p>
<ol>
<li>避免指令重排</li>
<li>可见性保证</li>
</ol>
<p>例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 <code>volatile</code> 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。</p>
<ul>
<li><code>volatile</code> 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。</li>
<li>某些情况下，<code>volatile</code> 还能提供原子性，如读 64 位数据类型，像 <code>long</code> 和 <code>double</code> 都不是原子的(低 32 位和高 32 位)，但 <code>volatile</code> 类型的 <code>double</code> 和 <code>long</code> 就是原子的。<strong>不过需要在 64 位的 JVM 虚拟机上</strong>。详细的分析，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/u/1753415/blog/724242">《Java中 long 和 double 的原子性》</a> 。</li>
</ul>
<h3 id="volatile-和-synchronized-的区别？"><a href="#volatile-和-synchronized-的区别？" class="headerlink" title="volatile 和 synchronized 的区别？"></a>volatile 和 synchronized 的区别？</h3><ol>
<li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别。<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性。而<code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li>
<li><code>volatile</code> 不会造成线程的阻塞。<code>synchronized</code> 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化。<code>synchronized</code>标记的变量可以被编译器优化。</li>
</ol>
<blockquote>
<p>另外，会有面试官会问 <code>volatile</code> 能否取代 <code>synchronized</code> 呢？答案肯定是不能，虽然说 <code>volatile</code> 被称之为轻量级锁，但是和 <code>synchronized</code> 是有本质上的区别，原因就是上面的几点落。</p>
</blockquote>
<h3 id="什么场景下可以使用-volatile-替换-synchronized-？"><a href="#什么场景下可以使用-volatile-替换-synchronized-？" class="headerlink" title="什么场景下可以使用 volatile 替换 synchronized ？"></a>什么场景下可以使用 volatile 替换 synchronized ？</h3><ol>
<li>只需要保证共享资源的可见性的时候可以使用 <code>volatile</code> 替代，<code>synchronized</code> 保证可操作的原子性一致性和可见性。</li>
<li><code>volatile</code> 适用于新值不依赖于旧值的情形。</li>
<li>1 写 N 读。</li>
<li>不与其他变量构成不变性条件时候使用 <code>volatile</code> 。</li>
</ol>
<h2 id="什么是死锁、活锁？"><a href="#什么是死锁、活锁？" class="headerlink" title="什么是死锁、活锁？"></a>什么是死锁、活锁？</h2><p>死锁，是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<h3 id="死锁与活锁的区别？"><a href="#死锁与活锁的区别？" class="headerlink" title="死锁与活锁的区别？"></a>死锁与活锁的区别？</h3><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，聪慧的胖友是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h2 id="什么是悲观锁、乐观锁？"><a href="#什么是悲观锁、乐观锁？" class="headerlink" title="什么是悲观锁、乐观锁？"></a>什么是悲观锁、乐观锁？</h2><p>1）悲观锁</p>
<p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 <code>synchronized</code> 关键字的实现也是悲观锁。</li>
</ul>
<p>2）乐观锁</p>
<p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li><p>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。</p>
<blockquote>
<p>例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</p>
</blockquote>
</li>
<li><p>在 Java 中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
</li>
</ul>
<p>乐观锁的实现方式：</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h2 id="Java-AQS"><a href="#Java-AQS" class="headerlink" title="Java AQS"></a>Java AQS</h2><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。事实上<code>concurrent</code> 包内许多类都是基于 AQS 构建。例如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。AQS 解决了在实现同步容器时设计的大量细节问题。</p>
<p>AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 <code>waitStatus</code> 。</p>
<p>可能这么说，胖友会一脸懵逼，最好的方式，还是直接去撸源码，可见如下的四篇文章。</p>
<blockquote>
<p>可能胖友在阅读时，会有一定的挫败感，没关系，大家都是如此，包括艿艿，还有我认识的各种大佬。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-0-intro?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：AQS 简介》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-1-clh?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：CLH 同步队列》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-2?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-3?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：阻塞和唤醒线程》</a></li>
</ul>
<h2 id="什么是-Java-Lock-接口？"><a href="#什么是-Java-Lock-接口？" class="headerlink" title="什么是 Java Lock 接口？"></a>什么是 Java Lock 接口？</h2><p><code>java.util.concurrent.locks.Lock</code> 接口，比 <code>synchronized</code> 提供更具拓展行的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>
<ul>
<li>可以使锁更公平。</li>
<li>可以使线程在等待锁的时候响应中断。</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁。</li>
</ul>
<h2 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h2><p>举例来说明锁的可重入性。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UnReentrant&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">    public void outer() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inner() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#outer()</code> 方法中调用了 <code>#inner()</code> 方法，<code>#outer()</code> 方法先锁住了 <code>lock</code> ，这样 <code>#inner()</code> 就不能再获取 <code>lock</code> 。</li>
<li>其实调用 <code>#outer()</code> 方法的线程已经获取了 <code>lock</code> 锁，但是不能在 <code>#inner()</code> 方法中重复利用已经获取的锁资源，这种锁即称之为不可重入。</li>
<li>可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</li>
</ul>
<p><code>synchronized</code>、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p>
<p>关于 ReentrantLock 类，详细的源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ReentrantLock/?vip">《【死磕 Java 并发】—– J.U.C 之重入锁：ReentrantLock》</a> 。</p>
<blockquote>
<p>简单来说，ReenTrantLock 的实现是一种自旋锁，通过循环调用 CAS 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
</blockquote>
<h3 id="synchronized-和-ReentrantLock-异同？"><a href="#synchronized-和-ReentrantLock-异同？" class="headerlink" title="synchronized 和 ReentrantLock 异同？"></a>synchronized 和 ReentrantLock 异同？</h3><ul>
<li>相同点<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
</li>
<li>不同点<ul>
<li>同步实现机制不同<ul>
<li><code>synchronized</code> 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。<br>*</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li><code>synchronized</code> 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 <code>volatile state</code> 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li><code>synchronized</code> 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 <code>finally</code> 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li><code>synchronized</code> 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>synchronized</code> 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 <code>synchronized</code> 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 <code>synchronized</code> 。</p>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。</p>
</blockquote>
<h2 id="ReadWriteLock-是什么？"><a href="#ReadWriteLock-是什么？" class="headerlink" title="ReadWriteLock 是什么？"></a>ReadWriteLock 是什么？</h2><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<p>ReadWriteLock 的源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/">《【死磕 Java 并发】—– J.U.C 之读写锁：ReentrantReadWriteLock》</a> 。</p>
<h2 id="Condition-是什么？"><a href="#Condition-是什么？" class="headerlink" title="Condition 是什么？"></a>Condition 是什么？</h2><p>在没有 Lock 之前，我们使用 <code>synchronized</code> 来控制同步，配合 Object 的 <code>#wait()</code>、<code>#notify()</code> 等一系列方法可以实现<strong>等待 / 通知模式</strong>。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 <code>synchronized</code> 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）：</p>
<p><img src="http://static2.iocoder.cn/e7e7bb0837bbe68a4364366d4ec9c5db" alt="img"></p>
<ul>
<li>Condition 的使用，可以看看 <a target="_blank" rel="noopener" href="http://www.importnew.com/9281.html">《怎么理解 Condition》</a></li>
<li>Condition 的源码，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Condition/">《【死磕 Java 并发】—– J.U.C 之 Condition》</a> 。</li>
</ul>
<h3 id="用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？"><a href="#用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？" class="headerlink" title="用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？"></a>用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？</h3><ul>
<li>使用 Lock + Condition 来实现。具体代码，参看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Big_Blogger/article/details/65629204">《用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc》</a> 。</li>
<li>使用 <code>synchronized</code> + await/notifyAll 来实现，参看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41704428/article/details/80482928">《Java用三个线程按顺序循环打印 abc 三个字母,比如 abcabcabc》</a> 。</li>
</ul>
<h2 id="LockSupport-是什么？"><a href="#LockSupport-是什么？" class="headerlink" title="LockSupport 是什么？"></a>LockSupport 是什么？</h2><p>LockSupport 是 JDK 中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。</p>
<ul>
<li>Java 锁和同步器框架的核心 AQS(AbstractQueuedSynchronizer)，就是通过调用 <code>LockSupport#park()</code>和 <code>LockSupport#unpark()</code> 方法，来实现线程的阻塞和唤醒的。</li>
<li>LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</li>
</ul>
<p>对于 LockSupport 了解即可，面试一般问的不多。感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hvicen/p/6217303.html">《多线程同步工具 —— LockSupport》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tianshouzhi.com/api/tutorials/mutithread/303">《Java 并发编程 —— LockSupport》</a> 带部分源码解析。</li>
</ul>
<h2 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h2><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在<strong>工作内存</strong>中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如下图：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/01.png" alt="线程、主内存、工作内存"></p>
<blockquote>
<p> 艿艿：当然，有个面试官会把 Java 内存模型，和 JVM 内存结构搞混淆。所以，在回答之前，可以先和面试官确认下说的是哪个。</p>
<p>关于 JVM 内存结构的面试题，我们在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview">《精尽 Java【虚拟机】面试题》</a> 中在详细分享。</p>
</blockquote>
<h2 id="两个线程之间是如何通信的呢？"><a href="#两个线程之间是如何通信的呢？" class="headerlink" title="两个线程之间是如何通信的呢？"></a>两个线程之间是如何通信的呢？</h2><p>线程之间的通信方式，目前有共享内存和消息传递两种。</p>
<p><strong>1）共享内存</strong></p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/02.png" alt="共享内存"></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</li>
</ol>
<p><strong>2）消息传递</strong></p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 <code>#wait()</code> 和 <code>#notify()</code> ，或者 BlockingQueue 。</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/03.png" alt="消息传递"></p>
<h2 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h2><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p><strong>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义</strong>。</p>
<h2 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h2><p>详细看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/happens-before/?vip">《【死磕 Java 并发】—– Java 内存模型之 happens-before》</a> 文章。</p>
<h2 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h2><p>内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<h3 id="内存屏障为何重要？"><a href="#内存屏障为何重要？" class="headerlink" title="内存屏障为何重要？"></a>内存屏障为何重要？</h3><p>对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。</p>
<p>当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据写入的顺序不一致。适当的放置内存屏障，通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><p>何为同步容器？可以简单地理解为通过 <code>synchronized</code>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p>
<ul>
<li>比如 Vector，Hashtable，以及 <code>Collections#synchronizedSet()</code>，<code>Collections#synchronizedList()</code> 等方法返回的容器。</li>
<li>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 <code>synchronized</code> 。</li>
</ul>
<p>并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。</p>
<ul>
<li>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map ，所以它可以在并发环境下实现更高的吞吐量。</li>
<li>再例如，CopyOnWriteArrayList 。</li>
</ul>
<h2 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><ul>
<li>SynchronizedMap<ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</li>
<li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 <code>new</code> 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li>
</ul>
</li>
</ul>
<p>关于 ConcurrentHashMap 的源码解析，推荐胖友看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/?vip">《【死磕 Java 并发】—– J.U.C 之 Java并发容器：ConcurrentHashMap》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/?vip">《【死磕 Java 并发】—– J.U.C 之 ConcurrentHashMap 红黑树转换分析》</a></li>
</ul>
<h3 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h3><p>在 JDK8 前，ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16 ，这样在多线程情况下就能避免争用。</p>
<p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现，利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>
<h3 id="ConcurrentHashMap-为何读不用加锁？"><a href="#ConcurrentHashMap-为何读不用加锁？" class="headerlink" title="ConcurrentHashMap 为何读不用加锁？"></a>ConcurrentHashMap 为何读不用加锁？</h3><p>在 JDK7 以及以前</p>
<ul>
<li>HashEntry 中的key、hash、next 均为 final型，只能表头插入、删除结点。<ul>
<li>HashEntry 类的 <code>value</code> 域被声明为 <code>volatile</code> 型。</li>
<li>不允许用 <code>null</code> 作为键和值，当读线程读到某个 HashEntry 的 <code>value</code> 域的值为 <code>null</code> 时，便知道产生了冲突——发生了重排序现象（put 方法设置新 <code>value</code> 对象的字节码指令重排序），需要加锁后重新读入这个 <code>value</code> 值。</li>
</ul>
</li>
<li><code>volatile</code> 变量 <code>count</code> 协调读写线程之间的内存可见性，写操作后修改 <code>count</code> ，读操作先读 <code>count</code>，根据 happen-before 传递性原则写操作的修改读操作能够看到。</li>
</ul>
<p>在 JDK8 开始</p>
<ul>
<li>Node 的 <code>val</code> 和 <code>next</code> 均为 <code>volatile</code> 型。</li>
<li><code>#tabAt(..,)</code> 和 <code>#casTabAt(...)</code> 对应的 Unsafe 操作实现了 <code>volatile</code> 语义。</li>
</ul>
<h2 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h2><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException 异常。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 ygc 或者 fgc 。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
</ul>
<p>CopyOnWriteArrayList 透露的思想：</p>
<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
<p>CopyOnWriteArrayList 适用于读操作远远多于写操作的场景。例如，缓存。</p>
<p>关于 CopyOnWriteArrayList 的源码，可以看看 <a target="_blank" rel="noopener" href="http://www.importnew.com/12773.html">《CopyOnWriteArrayList 实现原理及源码分析》</a> 文章。</p>
<h2 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<ul>
<li>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程</li>
<li>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</li>
</ul>
<blockquote>
<p>艿艿：如下的内容，和上面是相对重复的，或者是换一个说法，重新描述。</p>
</blockquote>
<p>BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：</p>
<ul>
<li>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。</li>
<li>当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。</li>
<li>正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。</li>
</ul>
<p>阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：</p>
<ul>
<li>读取数据的线程不断将数据放入队列。</li>
<li>然后，解析线程不断从队列取数据解析。</li>
</ul>
<h2 id="Java-提供了哪些阻塞队列的实现？"><a href="#Java-提供了哪些阻塞队列的实现？" class="headerlink" title="Java 提供了哪些阻塞队列的实现？"></a>Java 提供了哪些阻塞队列的实现？</h2><p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<blockquote>
<p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait、notify、notifyAll、<code>sychronized</code> 这些关键字。</p>
<p>而在 Java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
</blockquote>
<ul>
<li><p>【最常用】ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p>
</blockquote>
</li>
<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先出先进的原则对元素进行排序</p>
</blockquote>
</li>
<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<blockquote>
<p>每一个 put 必须等待一个 take 操作，否则不能继续添加元素。并且他支持公平访问队列。</p>
</blockquote>
</li>
<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
<blockquote>
<p>相对于其他阻塞队列，多了 tryTransfer 和 transfer 方法。</p>
<ul>
<li>transfer 方法：如果当前有消费者正在等待接收元素（take 或者待时间限制的 poll 方法），transfer 可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</li>
<li>tryTransfer 方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回 false 。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</li>
</ul>
</blockquote>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<blockquote>
<p>优势在于多线程入队时，减少一半的竞争。</p>
</blockquote>
</li>
</ul>
<p>具体的源码解析，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ArrayBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：ArrayBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/PriorityBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：PriorityBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/SynchronousQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：SynchronousQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/LinkedTransferQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedTransferQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/LinkedBlockingDeque?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedBlockingDeque》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/BlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：BlockingQueue 总结》</a></li>
</ul>
<p>🦅 <strong>阻塞队列提供哪些重要方法？</strong></p>
<table>
<thead>
<tr>
<th align="left">方法处理方式</th>
<th align="left">抛出异常</th>
<th align="left">返回特殊值</th>
<th align="left">一直阻塞</th>
<th align="left">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入方法</td>
<td align="left">add(e)</td>
<td align="left">offer(e)</td>
<td align="left">put(e)</td>
<td align="left">offer(e, time, unit)</td>
</tr>
<tr>
<td align="left">移除方法</td>
<td align="left">remove()</td>
<td align="left">poll()</td>
<td align="left">take()</td>
<td align="left">poll(time, unit)</td>
</tr>
<tr>
<td align="left">检查方法</td>
<td align="left">element()</td>
<td align="left">peek()</td>
<td align="left">不可用</td>
<td align="left">不可用</td>
</tr>
</tbody></table>
<p>🦅 <strong>ArrayBlockingQueue 与 LinkedBlockingQueue 的区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">Queue</th>
<th align="left">阻塞与否</th>
<th align="left">是否有界</th>
<th align="left">线程安全保障</th>
<th align="left">适用场景</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">有界</td>
<td align="left">一把全局锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）</td>
</tr>
<tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">可配置</td>
<td align="left">存取采用 2 把锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加 JVM 垃圾回收的负担。</td>
</tr>
</tbody></table>
<p>感兴趣的胖友，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b85c1794351">《ArrayBlockingQueue 与 LinkedBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://hellojava.info/?p=464">《从一个故障说说 Java 的三个 BlockingQueue》</a></li>
</ul>
<h2 id="什么是双端队列？"><a href="#什么是双端队列？" class="headerlink" title="什么是双端队列？"></a>什么是双端队列？</h2><p>在上面，我们看到的 LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等，都是阻塞队列。</p>
<p>而 ArrayDeque、LinkedBlockingDeque 就是双端队列，类名以 Deque 结尾。</p>
<ul>
<li>正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。<ul>
<li>如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。</li>
<li>在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。</li>
</ul>
</li>
<li>适用于：网页爬虫等任务中</li>
</ul>
<blockquote>
<p>😈 实际场景下，双端队列，我们使用比较少。艿艿根本没用过。</p>
</blockquote>
<h2 id="延迟队列的实现方式，DelayQueue-和时间轮算法的异同？"><a href="#延迟队列的实现方式，DelayQueue-和时间轮算法的异同？" class="headerlink" title="延迟队列的实现方式，DelayQueue 和时间轮算法的异同？"></a>延迟队列的实现方式，DelayQueue 和时间轮算法的异同？</h2><p>JDK 的 Timer 和 DelayQueue 插入和删除操作的平均时间复杂度为 <code>O(nlog(n))</code> ，而基于时间轮可以将插入和删除操作的时间复杂度都降为 <code>O(1)</code> 。</p>
<ul>
<li>关于 DelayQueue 的实现方式，在 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》》</a> 。</li>
<li>关于实践论的实现方法，在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/80697456">《Kafka解惑之时间轮（TimingWheel）》</a> 。</li>
</ul>
<h2 id="简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？"><a href="#简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？" class="headerlink" title="简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？"></a>简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？</h2><p>参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1a49293294aa">《LinkedBlockingQueue 和 ConcurrentLinkedQueue的用法及区别》</a> 。</p>
<p>在 Java 多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列(先进先出)。</p>
<p>Java 提供的线程安全的 Queue 可以分为</p>
<ul>
<li><p>阻塞队列，典型例子是 LinkedBlockingQueue 。</p>
<blockquote>
<p>适用阻塞队列的好处：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。</p>
</blockquote>
</li>
<li><p>非阻塞队列，典型例子是 ConcurrentLinkedQueue 。</p>
<blockquote>
<p>当许多线程共享访问一个公共集合时，<code>ConcurrentLinkedQueue</code> 是一个恰当的选择。</p>
</blockquote>
</li>
</ul>
<p>具体的选择，如下：</p>
<ul>
<li>LinkedBlockingQueue 多用于任务队列。<ul>
<li>单生产者，单消费者</li>
<li>多生产者，单消费者</li>
</ul>
</li>
<li>ConcurrentLinkedQueue 多用于消息队列。<ul>
<li>单生产者，多消费者</li>
<li>多生产者，多消费者</li>
</ul>
</li>
</ul>
<h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。</p>
<ul>
<li>处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。</li>
<li>在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。CAS操作 —— Compare &amp; Set ，或是 Compare &amp; Swap ，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</li>
</ul>
<p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<ul>
<li><code>int++</code> 并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原子的，在 JDK5 之前我们可以使用同步技术来做到这一点。到 JDK5 后，<code>java.util.concurrent.atomic</code> 包提供了 <code>int</code> 和 <code>long</code> 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</li>
</ul>
<p><code>java.util.concurrent</code> 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p>
<ul>
<li>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 。</li>
<li>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 。</li>
<li>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 。</li>
<li>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个<code>boolean</code> 来反映中间有没有变过），AtomicStampedReference（通过引入一个 <code>int</code> 来累加来反映中间有没有变过）。</li>
</ul>
<p>关于 CAS 的内容，建议胖友在看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CAS/">《【死磕 Java 并发】—- 深入分析 CAS》</a> 。</p>
<h2 id="CAS-操作有什么缺点？"><a href="#CAS-操作有什么缺点？" class="headerlink" title="CAS 操作有什么缺点？"></a>CAS 操作有什么缺点？</h2><p>1）<strong>ABA 问题</strong></p>
<p>比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。</p>
<p>从 Java5 开始 JDK 的 <code>atomic</code>包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2）<strong>循环时间长开销大</strong></p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 <code>synchronized</code> 。</p>
<p>3）<strong>只能保证一个共享变量的原子操作</strong></p>
<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<h2 id="Semaphore-是什么？"><a href="#Semaphore-是什么？" class="headerlink" title="Semaphore 是什么？"></a>Semaphore 是什么？</h2><p>Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。</p>
<ul>
<li>如有必要，在许可可用前会阻塞每一个 <code>#acquire()</code> 方法，然后再获取该许可。</li>
<li>每个 <code>#release()</code> 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。</li>
</ul>
<p>信号量常常用于多线程的代码中，比如数据库连接池。</p>
<ul>
<li>使用方式，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/cloudcoder/blog/362974">《JAVA多线程 – 信号量(Semaphore)》</a> 。</li>
<li>源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Semaphore/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Semaphore》</a> 。</li>
</ul>
<h2 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h2><p>CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。</p>
<p>CountDownLatch 默认的构造方法是 <code>CountDownLatch(int count)</code> ，其参数表示需要减少的计数，主线程调用 <code>#await()</code> 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，然后其它线程调用 CountDownLatch 的 <code>#countDown()</code> 方法，减小计数(不会阻塞)。等待计数被减少到零，主线程结束阻塞等待，继续往下执行。</p>
<ul>
<li>CountDownLatch 的使用示例，请看 <a target="_blank" rel="noopener" href="https://zk1878.iteye.com/blog/1002652">《Java 多线程 CountDownLatch 用法》</a> 。</li>
<li>CountDownLatch 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CountDownLatch/?vip">《【死磕 Java 并发】—– J.U.C 之并发工具类：CountDownLatch》</a></li>
</ul>
<h2 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h2><p>CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，其参数表示屏障拦截的线程数量，每个线程调用 <code>#await()</code> 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞，直到 <code>parties</code> 个线程到达，结束阻塞。</p>
<ul>
<li>CyclicBarrier 的使用示例，请看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuling/p/2013-8-21-01.html">《CyclicBarrier 的用法》</a></li>
<li>CyclicBarrier 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CyclicBarrier/?vip">《【死磕 Java 并发】—- J.U.C 之并发工具类：CyclicBarrier》</a> 。</li>
</ul>
<h2 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h2><p>实际场景下，问了一圈朋友，Exchanger 基本没在业务中使用过。</p>
<ul>
<li>Exchanger 的使用示例，请看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/eson_15/article/details/51581842">《【Java并发】线程同步工具Exchanger的使用》</a> 。</li>
<li>Exchanger 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Exchanger/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Exchanger》</a></li>
</ul>
<h2 id="CyclicBarrier-和-CountdownLatch-有什么区别？"><a href="#CyclicBarrier-和-CountdownLatch-有什么区别？" class="headerlink" title="CyclicBarrier 和 CountdownLatch 有什么区别？"></a>CyclicBarrier 和 CountdownLatch 有什么区别？</h2><p>CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</p>
<ul>
<li>CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。<ul>
<li>你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 <code>#await()</code> 方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier 。</li>
<li>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 <code>#await()</code> 方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 <code>#countDown()</code> 方法，这个调用 <code>#await()</code> 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。</li>
</ul>
</li>
<li>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier 。</li>
</ul>
<p>整理表格如下：</p>
<table>
<thead>
<tr>
<th align="left">CountDownLatch</th>
<th align="left">CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td align="left">减计数方式</td>
<td align="left">加计数方式</td>
</tr>
<tr>
<td align="left">计算为 0 时释放所有等待的线程</td>
<td align="left">计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td align="left">计数为 0 时，无法重置</td>
<td align="left">计数达到指定值时，计数置为 0 重新开始</td>
</tr>
<tr>
<td align="left">调用 <code>#countDown()</code> 方法计数减一，调用 <code>#await()</code> 方法只进行阻塞，对计数没任何影响</td>
<td align="left">调用 <code>#await()</code> 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td align="left">不可重复利用</td>
<td align="left">可重复利用</td>
</tr>
</tbody></table>
<h2 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h2><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<h3 id="为什么使用-Executor-框架？"><a href="#为什么使用-Executor-框架？" class="headerlink" title="为什么使用 Executor 框架？"></a>为什么使用 Executor 框架？</h3><ol>
<li>每次执行任务创建线程 <code>new Thread()</code> 比较消耗性能，创建一个线程是比较耗时、耗资源的。</li>
<li>调用 <code>new Thread()</code> 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li>
<li>接使用 <code>new Thread()</code> 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li>
</ol>
<h3 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h3><ul>
<li>Executors 是 Executor 的工具类，不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象，能执行我们的线程任务。<ul>
<li>ExecutorService 接口，继承了 Executor 接口，并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。<ul>
<li>使用 ThreadPoolExecutor ，可以创建自定义线程池。</li>
</ul>
</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 <code>#get()</code> 方法，获取计算的结果。</li>
</ul>
</li>
</ul>
<h2 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3932921.html">《Java并发编程：线程池的使用》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadPool-core/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：线程池的基础架构》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ThreadPoolExecutor》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ScheduledThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ScheduledThreadPoolExecutor》</a></li>
</ul>
<h2 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h2><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<blockquote>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
</blockquote>
<ul>
<li>普通任务线程池<ul>
<li>1、#newFixedThreadPool(int nThreads)方法，创建一个固定长度的线程池。<ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
<li>2、#newCachedThreadPool()方法，创建一个可缓存的线程池。<ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
<li>3、#newSingleThreadExecutor()方法，创建一个单线程的线程池。<ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
</li>
<li>定时任务线程池<ul>
<li>4、<code>#newScheduledThreadPool(int corePoolSize)</code> 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li>5、<code>#newSingleThreadExecutor()</code> 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
</li>
</ul>
<h3 id="如何使用-ThreadPoolExecutor-创建线程池？"><a href="#如何使用-ThreadPoolExecutor-创建线程池？" class="headerlink" title="如何使用 ThreadPoolExecutor 创建线程池？"></a>如何使用 ThreadPoolExecutor 创建线程池？</h3><p>Executors 提供了创建线程池的常用模板，实际场景下，我们可能需要自动以更灵活的线程池，此时就需要使用 ThreadPoolExecutor 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ThreadPoolExecutor.java</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 参数，核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行任务。</li>
<li>maximumPoolSize参数，最大线程数， 当线程数 &gt;= corePoolSize 的时候，会把任务放入workQueue 队列中。</li>
<li>keepAliveTime 参数，保持存活时间，当线程数大于 <code>corePoolSize</code> 的空闲线程能保持的最大时间。</li>
<li>unit 参数，时间单位。</li>
<li>workQueue 参数，保存任务的阻塞队列。</li>
<li>handler 参数，超过阻塞队列的大小时，使用的拒绝策略。</li>
<li>threadFactory 参数，创建线程的工厂。</li>
</ul>
<h3 id="ThreadPoolExecutor-有哪些拒绝策略？"><a href="#ThreadPoolExecutor-有哪些拒绝策略？" class="headerlink" title="ThreadPoolExecutor 有哪些拒绝策略？"></a>ThreadPoolExecutor 有哪些拒绝策略？</h3><p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy()</code> ，直接抛出异常 RejectedExecutionException 。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy()</code> ，直接调用 run 方法并且阻塞执行。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy()</code> ，直接丢弃后来的任务。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy()</code> ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。</p>
<h2 id="线程池的关闭方式有几种？"><a href="#线程池的关闭方式有几种？" class="headerlink" title="线程池的关闭方式有几种？"></a>线程池的关闭方式有几种？</h2><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：</p>
<ul>
<li><code>#shutdown()</code> 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li><code>#shutdownNow()</code> 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
<p>实际场景下，一般会结合这两个方法，一起实现线程池的优雅关闭。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void shutdownAndAwaitTermination(ExecutorService pool) &#123;</span><br><span class="line">  pool.shutdown(); &#x2F;&#x2F; Disable new tasks from being submitted</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; Wait a while for existing tasks to terminate</span><br><span class="line">    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) &#123;</span><br><span class="line">      pool.shutdownNow(); &#x2F;&#x2F; Cancel currently executing tasks</span><br><span class="line">      &#x2F;&#x2F; Wait a while for tasks to respond to being cancelled</span><br><span class="line">      if (!pool.awaitTermination(60, TimeUnit.SECONDS))</span><br><span class="line">          System.err.println(&quot;Pool did not terminate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">    &#x2F;&#x2F; (Re-)Cancel if current thread also interrupted</span><br><span class="line">    pool.shutdownNow();</span><br><span class="line">    &#x2F;&#x2F; Preserve interrupt status</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-线程池大小为何会大多被设置成-CPU-核心数-1-？"><a href="#Java-线程池大小为何会大多被设置成-CPU-核心数-1-？" class="headerlink" title="Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？"></a>Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？</h2><p>详细的可以看看 <a target="_blank" rel="noopener" href="http://ifeve.com/how-to-calculate-threadpool-size/">《如何合理地估算线程池大小？》</a> 。如下是简单的总结和整理：</p>
<p>一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数）</p>
<ul>
<li><p>如果是 CPU 密集型应用，则线程池大小设置为 N+1</p>
<blockquote>
<p>因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</p>
</blockquote>
</li>
<li><p>如果是 IO 密集型应用，则线程池大小设置为 2N+1</p>
<blockquote>
<p>IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。</p>
</blockquote>
</li>
<li><p>如果是混合型应用，那么分别创建线程池</p>
<blockquote>
<p>可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。</p>
<p>因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
</blockquote>
</li>
</ul>
<p>如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p>
<p>但是，IO 优化中，这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间 + 线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目<br><strong>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>
<p>下面举个例子：比如平均每个线程 CPU 运行时间为 0.5s ，而线程等待时间（非 CPU 运行时间，比如 IO）为 1.5s ，CPU 核心数为 8 。<br>那么根据上面这个公式估算得到：<code>((0.5 + 1.5) / 0.5) * 8 = 32</code>。这个公式进一步转化为：最佳线程数目 = （线程等待时间与线程 CPU 时间之比 + 1）* CPU数目。</p>
<h3 id="线程池容量的动态调整？"><a href="#线程池容量的动态调整？" class="headerlink" title="线程池容量的动态调整？"></a>线程池容量的动态调整？</h3><p>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：</p>
<ul>
<li>setCorePoolSize：设置核心池大小。</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
<p>当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h2 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h2><p>1）<strong>Callable</strong></p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<blockquote>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
</blockquote>
<p>2）<strong>Future</strong></p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p>3）<strong>FutureTask</strong></p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h2 id="线程池执行任务的过程？"><a href="#线程池执行任务的过程？" class="headerlink" title="线程池执行任务的过程？"></a>线程池执行任务的过程？</h2><p>刚创建时，里面没有线程调用 execute() 方法，添加任务时：</p>
<ol>
<li>如果正在运行的线程数量小于核心参数 corePoolSize，继续创建线程运行这个任务<ul>
<li>否则，如果正在运行的线程数量大于或等于 <code>corePoolSize</code> ，将任务加入到阻塞队列中。</li>
<li>否则，如果队列已满，同时正在运行的线程数量小于核心参数 <code>maximumPoolSize</code> ，继续创建线程运行这个任务。</li>
<li>否则，如果队列已满，同时正在运行的线程数量大于或等于 <code>maximumPoolSize</code> ，根据设置的拒绝策略处理。</li>
</ul>
</li>
<li>完成一个任务，继续取下一个任务处理。<ul>
<li>没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。</li>
<li>否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 <code>corePoolSize</code> 。</li>
</ul>
</li>
</ol>
<h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit 和 execute 方法有什么区别？"></a>线程池中 submit 和 execute 方法有什么区别？</h3><p>两个方法都可以向线程池提交任务。</p>
<ul>
<li><code>#execute(...)</code> 方法，返回类型是 <code>void</code> ，它定义在 Executor 接口中。</li>
<li><code>#submit(...)</code> 方法，可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
<h3 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h3><blockquote>
<p>艿艿：重点在于线程池的队列是有界还是无界的。</p>
</blockquote>
<ul>
<li>如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。</li>
<li>如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 。</li>
</ul>
<h2 id="Fork-Join-框架是什么？"><a href="#Fork-Join-框架是什么？" class="headerlink" title="Fork/Join 框架是什么？"></a>Fork/Join 框架是什么？</h2><blockquote>
<p>艿艿：这是，可能了解的人不多，我也是。大体知道就好。</p>
</blockquote>
<p>Oracle 的官方给出的定义是：Fork/Join 框架是一个实现了 ExecutorService接口 的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。</p>
<p>我们再通过 Fork 和 Join 这两个单词来理解下 Fork/Join 框架。</p>
<ul>
<li>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li>比如计算 <code>1+2+...＋10000</code> ，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</li>
</ul>
<p>感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/index.html">《JDK 7 中的 Fork/Join 模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/fork-join-introduction">《聊聊并发（八） —— Fork/Join 框架介绍》</a></li>
</ul>
<h2 id="如何让一段程序并发的执行，并最终汇总结果？"><a href="#如何让一段程序并发的执行，并最终汇总结果？" class="headerlink" title="如何让一段程序并发的执行，并最终汇总结果？"></a>如何让一段程序并发的执行，并最终汇总结果？</h2><ul>
<li><p>1、CountDownLatch：允许一个或者多个线程等待前面的一个或多个线程完成，构造一个 CountDownLatch 时指定需要 countDown 的点的数量，每完成一点就 countDown 一下。当所有点都完成，CountDownLatch 的 <code>#await()</code> 就解除阻塞。</p>
</li>
<li><p>2、CyclicBarrier：可循环使用的 Barrier ，它的作用是让一组线程到达一个 Barrier 后阻塞，直到所有线程都到达 Barrier 后才能继续执行。</p>
<blockquote>
<p>CountDownLatch 的计数值只能使用一次，CyclicBarrier 可以通过使用 reset 重置，还可以指定到达栅栏后优先执行的任务。</p>
</blockquote>
</li>
<li><p>3、Fork/Join 框架，fork 把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/07/26/Java%E3%80%90%E9%9B%86%E5%90%88%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/Java%E3%80%90%E9%9B%86%E5%90%88%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【集合】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-26T00:00:00+08:00">2020-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 16:48:30" itemprop="dateModified" datetime="2020-08-05T16:48:30+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java-集合框架有哪些？"><a href="#Java-集合框架有哪些？" class="headerlink" title="Java 集合框架有哪些？"></a>Java 集合框架有哪些？</h2><h3 id="说出一些集合框架的优点？"><a href="#说出一些集合框架的优点？" class="headerlink" title="说出一些集合框架的优点？"></a>说出一些集合框架的优点？</h3><p>集合框架的部分优点如下：</p>
<ul>
<li>1、使用核心集合类降低开发成本，而非实现我们自己的集合类。</li>
<li>2、随着使用经过严格测试的集合框架类，代码质量会得到提高。</li>
<li>3、通过使用 JDK 附带的集合类，可以降低代码维护成本。</li>
<li>4、复用性和可操作性。</li>
</ul>
<h3 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h3><p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。</p>
<p>泛型也使得代码整洁，我们不需要使用显式转换和 <code>instanceOf</code> 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h2 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h2><ul>
<li>Collection ，为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。<ul>
<li>Set ，是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</li>
<li>List ，是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</li>
</ul>
</li>
<li>Map ，是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</li>
<li>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。</li>
</ul>
<h3 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h3><p>Collection 接口指定一组对象，对象即为它的元素。</p>
<ul>
<li>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。</li>
<li>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</li>
</ul>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制，<strong>特定的实现应该决定它是否可以被克隆和序列化</strong>。</p>
<h3 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h3><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。</p>
<p>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合“一组对象”规范。</p>
<h3 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h3><ul>
<li>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。</li>
<li>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h3 id="集合框架里实现的通用算法有哪些？"><a href="#集合框架里实现的通用算法有哪些？" class="headerlink" title="集合框架里实现的通用算法有哪些？"></a>集合框架里实现的通用算法有哪些？</h3><p>Java 集合框架提供常用的算法实现，比如排序和搜索。</p>
<p>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p>1）List</p>
<ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
<p>2）Map</p>
<ul>
<li>HashMap ：<ul>
<li>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
<li>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
</li>
<li>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a> 。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ul>
<p>3）Set</p>
<ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
<h2 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h2><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 <code>#remove(Object Obj)</code> 方法删除，可以通过迭代器的 <code>#remove()</code> 方法删除。</p>
<h3 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h3><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h3 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h3><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 <code>java.util</code> 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 <code>java.util.concurrent</code> 包下的全是安全失败的。</li>
</ul>
<h3 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h3><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<p>Enumeration 和 Iterator 接口有什么不同？</p>
<ul>
<li>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。</li>
<li>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</li>
</ul>
<p>对于很多胖友，可能并未使用过 Enumeration 类，所以可以看看 <a target="_blank" rel="noopener" href="http://www.runoob.com/java/java-enumeration-interface.html">《Java Enumeration 接口》</a> 文章。</p>
<h3 id="为何-Iterator-接口没有具体的实现？"><a href="#为何-Iterator-接口没有具体的实现？" class="headerlink" title="为何 Iterator 接口没有具体的实现？"></a>为何 Iterator 接口没有具体的实现？</h3><p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。</p>
<p>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p>
<h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h2><ul>
<li>Comparable 接口，在 <code>java.lang</code> 包下，用于当前对象和其它对象的比较，所以它有一个 <code>#compareTo(Object obj)</code> 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 <code>java.util</code> 包下，用于传入的两个对象的比较，所以它有一个 <code>#compare(Object obj1, Object obj2)</code> 方法用来排序，该方法有两个参数。</li>
</ul>
<p>详细的，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/whing123/article/details/77851737">《Java 自定义比较器》</a> 文章，重点是如何自己实现 Comparable 和 Comparator 的方法。</p>
<h3 id="compareTo-方法的返回值表示的意思？"><a href="#compareTo-方法的返回值表示的意思？" class="headerlink" title="compareTo 方法的返回值表示的意思？"></a>compareTo 方法的返回值表示的意思？</h3><ul>
<li>大于 0 ，表示对象大于参数对象。</li>
<li>小于 0 ，表示对象小于参数对象</li>
<li>等于 0 ，表示两者相等。</li>
</ul>
<h3 id="如何对-Object-的-List-排序？"><a href="#如何对-Object-的-List-排序？" class="headerlink" title="如何对 Object 的 List 排序？"></a>如何对 Object 的 List 排序？</h3><ul>
<li>对 <code>Object[]</code> 数组进行排序时，我们可以用 <code>Arrays#sort(...)</code> 方法。</li>
<li>对 <code>List</code> 数组进行排序时，我们可以用 <code>Collections#sort(...)</code> 方法。</li>
</ul>
<h2 id="有哪些关于-Java-集合框架的最佳实践？"><a href="#有哪些关于-Java-集合框架的最佳实践？" class="headerlink" title="有哪些关于 Java 集合框架的最佳实践？"></a>有哪些关于 Java 集合框架的最佳实践？</h2><ul>
<li>基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array ，而不是 ArrayList 。</li>
<li>一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。</li>
<li>总是使用泛型来保证类型安全，可靠性和健壮性。同时，使用泛型还可以避免运行时的 ClassCastException 异常。</li>
<li>在 Map 中使用 JDK 提供的不可变类作为一个 key，这样可以避免 hashcode 的实现和我们自定义类的 equals 方法。</li>
<li>应该依照接口而不是实现来编程。</li>
<li>返回零长度的集合或者数组，而不是返回一个 <code>null</code> ，这样可以防止底层集合是空的。</li>
</ul>
<h2 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h2><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</li>
</ul>
<blockquote>
<p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。</p>
<p>另外 List 支持 <code>for</code> 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
</blockquote>
<p>Set 和 List 对比：</p>
<ul>
<li>Set：检索指定的元素效率高，删除和插入效率高，插入和删除<strong>可能会</strong>引起元素位置改变。</li>
<li>List：和数组类似，List 可以动态增长，查找<strong>指定的</strong>元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。</li>
</ul>
<p>当然，如果是随机访问（指定下标），则 List 会快于 Set 。总之，什么场景下使用 Set ，什么场景下使用 List ，还是比较明确的。</p>
<h2 id="List-和-Map-区别？"><a href="#List-和-Map-区别？" class="headerlink" title="List 和 Map 区别？"></a>List 和 Map 区别？</h2><ul>
<li>List 是对象集合，允许对象重复。</li>
<li>Map 是键值对的集合，不允许 key 重复。</li>
</ul>
<h2 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h2><ul>
<li>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</li>
<li>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。</li>
<li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li>
</ul>
<p>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p>
<ul>
<li>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们</li>
<li>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</li>
<li>3、如果你要使用多维数组，使用 <code>[][]</code> 比 List 会方便。</li>
</ul>
<h2 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h3 id="适用场景分析"><a href="#适用场景分析" class="headerlink" title="适用场景分析"></a>适用场景分析</h3><ul>
<li><p>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</p>
</li>
<li><p>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</p>
<blockquote>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList 。</p>
</blockquote>
</li>
<li><p>当然，绝大数业务的场景下，使用 ArrayList 就够了。主要是，注意好避免 ArrayList 的扩容，以及非顺序的插入。</p>
</li>
</ul>
<h3 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h3><p>直接看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuoAT/p/6771653.html">《ArrayList 动态扩容详解》</a> 文章，很详细。主要结论如下：</p>
<ul>
<li>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 <strong>1.5</strong> 倍（位运算）的比率通过 copeOf 的方式扩容。</li>
<li>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 <strong>1.5</strong> 倍。</li>
</ul>
<blockquote>
<p>重点是 1.5 倍扩容，这是和 HashMap 2 倍扩容不同的地方。</p>
</blockquote>
<h3 id="ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><a href="#ArrayList-集合加入-1-万条数据，应该怎么提高效率？" class="headerlink" title="ArrayList 集合加入 1 万条数据，应该怎么提高效率？"></a>ArrayList 集合加入 1 万条数据，应该怎么提高效率？</h3><p>ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！</p>
<p>这样就可以提高效率了~</p>
<h2 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h2><p>ArrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p>
<ul>
<li><p>1、Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 <code>synchronized</code> 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比。</p>
<blockquote>
<p>Vector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>
</blockquote>
</li>
<li><p>2、两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</p>
</li>
<li><p>3、Vector 可以设置增长因子，而 ArrayList 不可以。</p>
</li>
</ul>
<p>适用场景分析：</p>
<ul>
<li><p>1、Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。</p>
<blockquote>
<p>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。</p>
</blockquote>
</li>
<li><p>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</p>
<blockquote>
<p>这种情况下，使用 LinkedList 更合适。</p>
</blockquote>
</li>
</ul>
<h2 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h2><blockquote>
<p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。</p>
</blockquote>
<ul>
<li>Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li>
<li>2、HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li>
<li>3、HashMap 允许空键值，而 Hashtable 不允许。</li>
<li>【重点】4、HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>5、HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li>
<li>6、HashTable 中数组默认大小是 11 ，扩容方法是 <code>old * 2 + 1</code> ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。</li>
</ul>
<p>一般现在不建议用 HashTable 。主要原因是两点：</p>
<ul>
<li>一是，HashTable 是遗留类，内部实现很多没优化和冗余。</li>
<li>二是，即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable 。</li>
</ul>
<p>Hashtable 的 <code>#size()</code> 方法中明明只有一条语句 <code>&quot;return count;&quot;</code> ，为什么还要做同步？</p>
<p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 <code>#size()</code> 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 <code>count++</code> ，线程 B 就已经读取 <code>count</code> 了，那么对于线程 B 来说读取到的 <code>count</code> 一定是不准确的。</p>
<p><strong>而给 <code>#size()</code> 方法加了同步之后，意味着线程 B 调用 <code>#size()</code> 方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性</strong>。</p>
<h2 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h2><ul>
<li><p>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。</p>
</li>
<li><p>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构。</p>
<blockquote>
<p>因为不同的 key 值，可能有相同的 hashcode ，所以 value 值需要是链表结构。</p>
</blockquote>
</li>
</ul>
<p>他们的共同点都是 hash 算法实现的唯一性，他们都不能持有基本类型，只能持有对象。</p>
<blockquote>
<p>为了更好的性能，Netty 自己实现了 key 为基本类型的 HashMap ，例如 <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/collection/IntObjectHashMap.html">IntObjectHashMap</a> 。</p>
</blockquote>
<h2 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h2><ul>
<li>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 <code>O(1)</code> 。</li>
<li>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 <code>O(logn)</code> 。</li>
</ul>
<h3 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h3><ul>
<li>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。</li>
<li>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。</li>
</ul>
<p>基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，再将 HashMap 换为 TreeMap 进行有序 key 的遍历。</p>
<h2 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h2><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<ul>
<li><p>1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。</p>
<blockquote>
<p>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。</p>
</blockquote>
</li>
<li><p>2、HashMap 的键值对允许有 <code>null</code> ，但是 ConCurrentHashMap 都不允许。</p>
</li>
</ul>
<h2 id="队列和栈是什么，列出它们的区别？"><a href="#队列和栈是什么，列出它们的区别？" class="headerlink" title="队列和栈是什么，列出它们的区别？"></a>队列和栈是什么，列出它们的区别？</h2><p>栈和队列两者都被用来预存储数据。</p>
<ul>
<li>java.util.Queue是一个接口，它的实现类在Java并发包中。<ul>
<li>队列允许先进先出（FIFO）检索元素，但并非总是这样。</li>
<li>Deque 接口允许从两端检索元素。</li>
</ul>
</li>
<li>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。<ul>
<li>Stack 是一个扩展自 Vector 的类，而 Queue 是一个接口。</li>
</ul>
</li>
</ul>
<h2 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h2><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个<strong>“链表散列”</strong>。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<ul>
<li>我们使用 <code>#put(key, value)</code> 方法来存储对象到 HashMap 中，使用 <code>get(key)</code> 方法从 HashMap 中获取对象。</li>
<li>当我们给 <code>#put(key, value)</code> 方法传递键和值时，我们先对键调用 <code>#hashCode()</code> 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。</li>
</ul>
<h3 id="当两个对象的-hashCode-相同会发生什么？"><a href="#当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="当两个对象的 hashCode 相同会发生什么？"></a>当两个对象的 hashCode 相同会发生什么？</h3><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。</p>
<p>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
<h3 id="hashCode-和-equals-方法有何重要性？"><a href="#hashCode-和-equals-方法有何重要性？" class="headerlink" title="hashCode 和 equals 方法有何重要性？"></a>hashCode 和 equals 方法有何重要性？</h3><p>HashMap 使用 key 对象的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。</p>
<ul>
<li>如果这两个方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</li>
</ul>
<p>同样的，所有不允许存储重复数据的集合类都使用 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 去查找重复，所以正确实现它们非常重要。<code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法的实现，应该遵循以下规则：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> ，那么 <code>o1.hashCode() == o2.hashCode()</code> 总是为 <code>true</code> 的。</li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code> ，并不意味 <code>o1.equals(o2)</code> 会为 <code>true</code> 。</li>
</ul>
<h3 id="HashMap-默认容量是多少？"><a href="#HashMap-默认容量是多少？" class="headerlink" title="HashMap 默认容量是多少？"></a>HashMap 默认容量是多少？</h3><p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（<code>16 * 0.75 = 12</code>），一般为原内存的 2 倍。</p>
<h3 id="有哪些顺序的-HashMap-实现类？"><a href="#有哪些顺序的-HashMap-实现类？" class="headerlink" title="有哪些顺序的 HashMap 实现类？"></a>有哪些顺序的 HashMap 实现类？</h3><ul>
<li>LinkedHashMap ，是基于元素进入集合的顺序或者被访问的先后顺序排序。</li>
<li>TreeMap ，是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。</li>
</ul>
<h3 id="我们能否使用任何类作为-Map-的-key？"><a href="#我们能否使用任何类作为-Map-的-key？" class="headerlink" title="我们能否使用任何类作为 Map 的 key？"></a>我们能否使用任何类作为 Map 的 key？</h3><p>我们可以使用任何类作为 Map 的 key ，然而在使用它们之前，需要考虑以下几点：</p>
<ul>
<li><p>1、如果类重写了 equals 方法，它也应该重写 hashcode 方法。</p>
</li>
<li><p>2、类的所有实例需要遵循与 equals 和 hashcode 相关的规则。</p>
</li>
<li><p>3、如果一个类没有使用 equals ，你不应该在 hashcode 中使用它。</p>
</li>
<li><p>4、用户自定义 key 类的最佳实践是使之为不可变的，这样，hashcode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashcode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<blockquote>
<p>比如，我有一个 类MyKey ，在 HashMap 中使用它。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传递给MyKey的name参数被用于equals()和hashCode()中</span><br><span class="line">MyKey key &#x3D; new MyKey(&#39;Pankaj&#39;); &#x2F;&#x2F;assume hashCode&#x3D;1234</span><br><span class="line">myHashMap.put(key, &#39;Value&#39;);</span><br><span class="line">&#x2F;&#x2F; 以下的代码会改变key的hashCode()和equals()值</span><br><span class="line">key.setName(&#39;Amit&#39;); &#x2F;&#x2F;assume new hashCode&#x3D;7890</span><br><span class="line">&#x2F;&#x2F;下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null</span><br><span class="line">myHashMap.get(new MyKey(&#39;Pankaj&#39;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>那就是为何 String 和 Integer 被作为 HashMap 的 key 大量使用。</p>
</li>
</ul>
<h3 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 <code>%</code> 取余的操作来实现。但是，重点来了：</p>
<ul>
<li>取余(<code>%</code>)操作中如果除数是 2 的幂次则等价于与其除数减一的与(<code>&amp;</code>)操作（也就是说 <code>hash % length == hash &amp; (length - 1)</code> 的前提是 length 是 2 的 n 次方；）。</li>
<li>并且，采用二进制位操作 <code>&amp;</code>，相对于 <code>%</code> 能够提高运算效率，</li>
</ul>
<p>这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h2 id="HashSet-的工作原理是什么？"><a href="#HashSet-的工作原理是什么？" class="headerlink" title="HashSet 的工作原理是什么？"></a>HashSet 的工作原理是什么？</h2><p>HashSet 是构建在 HashMap 之上的 Set hashing 实现类。让我们直接撸下源码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet.java</span><br><span class="line"></span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>map</code> 属性，当我们创建一个 HashMap 对象时，其内部也会创建一个 <code>map</code> 对象。后续 HashSet 所有的操作，实际都是基于这个 <code>map</code> 之上的封装。</p>
</li>
<li><p><code>PRESENT</code> 静态属性，所有 <code>map</code> 中 KEY 对应的值，都是它，避免重复创建。</p>
</li>
<li><p>OK ，再来看一眼 add 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet.java</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT) &#x3D;&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是不是一目了然。</p>
</li>
</ul>
<h3 id="HashSet-如何检查重复？"><a href="#HashSet-如何检查重复？" class="headerlink" title="HashSet 如何检查重复？"></a>HashSet 如何检查重复？</h3><blockquote>
<p>艿艿：正如我们上面看到 HashSet 的实现原理，我们自然可以推导出，HashMap 也是如何检查重复滴。</p>
</blockquote>
<p>如下摘取自 《Head First Java》 第二版：</p>
<p>当你把对象加入 HashSet 时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较。</p>
<ul>
<li>如果没有相符的 hashcode ，HashSet会假设对象没有重复出现。</li>
<li>但是如果发现有相同 hashcode 值的对象，这时会调用 equals 方法来检查 hashcode 相等的对象是否真的相同。<ul>
<li>如果两者相同，HashSet 就不会让加入操作成功。</li>
<li><strong>如果两者不同，HashSet 就会让加入操作成功</strong>。</li>
</ul>
</li>
</ul>
<h2 id="EnumSet-是什么？"><a href="#EnumSet-是什么？" class="headerlink" title="EnumSet 是什么？"></a>EnumSet 是什么？</h2><p><code>java.util.EnumSet</code> ，是使用枚举类型的集合实现。</p>
<ul>
<li>当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet 是不同步的，不允许值为 <code>null</code> 的元素。</li>
<li>它也提供了一些有用的方法，比如 <code>#copyOf(Collection c)</code>、<code>#of(E first, E... rest)</code> 和 <code>#complementOf(EnumSet s)</code> 方法。</li>
</ul>
<p>关于 EnumSet 的源码解析，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010887744/article/details/50834738">《EnumSet 源码分析》</a> 文章。</p>
<h2 id="TreeMap-原理"><a href="#TreeMap-原理" class="headerlink" title="TreeMap 原理"></a>TreeMap 原理</h2><p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p>TODO TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</p>
<p>等到源码解析后，在进行补充。</p>
<h2 id="Java-Priority-Queue-是什么"><a href="#Java-Priority-Queue-是什么" class="headerlink" title="Java Priority Queue 是什么?"></a>Java Priority Queue 是什么?</h2><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素都以他们的自然顺序有序排列。</p>
<ul>
<li>在它创建的时候，我们可以可以提供一个比较器 Comparator 来负责PriorityQueue 中元素的排序。</li>
<li>PriorityQueue 不允许 `` null元素，不允许不提供自然排序的对象，也不允许没有任何关联 Comparator 的对象。</li>
<li>最后，PriorityQueue 不是线程安全的，在执行入队和出队操作它需要 <code>O(log(n))</code> 的时间复杂度。</li>
</ul>
<h3 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll 方法和 remove 方法的区别？"></a>poll 方法和 remove 方法的区别？</h3><p>poll 和 remove 方法，都是从队列中取出一个元素，差别在于：</p>
<ul>
<li>poll 方法，在获取元素失败的时候会返回空</li>
<li>remove() 方法，失败的时候会抛出异常。</li>
</ul>
<h3 id="LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>LinkedHashMap 和 PriorityQueue 的区别是什么？</h3><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，LinkedHashMap 维持的顺序是元素插入的顺序。</li>
<li>当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/07/25/Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/25/Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【基础】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-25T00:00:00+08:00">2020-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 16:48:23" itemprop="dateModified" datetime="2020-08-05T16:48:23+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<h3 id="面向对象的特征？"><a href="#面向对象的特征？" class="headerlink" title="面向对象的特征？"></a>面向对象的特征？</h3><p>封装、继承、多态、抽象</p>
<h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><ul>
<li>面向过程<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如，单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展。</li>
</ul>
</li>
<li>面向对象<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li>
<li>缺点：性能比面向过程低。</li>
</ul>
</li>
</ul>
<h3 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h3><p>1）重写 <code>override</code></p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 <code>final</code> 不能被重写。</li>
</ul>
<p>2）重载 <code>overload</code></p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<h3 id="什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"><a href="#什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？" class="headerlink" title="什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"></a>什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</h3><p>1）构造方法</p>
<p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
<p>2）构造方法重载</p>
<p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>3）拷贝构造方法</p>
<p>Java 不支持像 C++ 中那样的<a target="_blank" rel="noopener" href="http://www.runoob.com/cplusplus/cpp-copy-constructor.html">拷贝构造方法</a>，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p>
<h3 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h3><ul>
<li><p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p>
<ul>
<li><p>用于编译 Java 程序的 javac 命令。</p>
</li>
<li><p>用于启动 JVM 运行 Java 程序的 Java 命令。</p>
</li>
<li><p>用于生成文档的 Javadoc 命令。</p>
</li>
<li><p>用于打包的 jar 命令等等。</p>
</li>
</ul>
</li>
<li><p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
</li>
<li><p>JVM 即为 Java 虚拟机，提供了字节码文件(<code>.class</code>)的运行环境支持。</p>
<blockquote>
<p>简单说，就是 JDK 包含 JRE 包含 JVM。</p>
</blockquote>
</li>
</ul>
<h3 id="为什么-Java-被称作是“平台无关的编程语言”？"><a href="#为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="为什么 Java 被称作是“平台无关的编程语言”？"></a>为什么 Java 被称作是“平台无关的编程语言”？</h3><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。</p>
<ul>
<li><p>Java 源文件( <code>.java</code> )被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。</p>
</li>
<li><p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
</li>
</ul>
<h2 id="什么是字节码？采用字节码的好处？"><a href="#什么是字节码？采用字节码的好处？" class="headerlink" title="什么是字节码？采用字节码的好处？"></a>什么是字节码？采用字节码的好处？</h2><h3 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h3><p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就是解释了 Java 的编译与解释并存的特点</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 源代码 </span><br><span class="line">&#x3D;&gt; 编译器 &#x3D;&gt; JVM 可执行的 Java 字节码(即虚拟指令)</span><br><span class="line">&#x3D;&gt; JVM &#x3D;&gt; JVM 中解释器 &#x3D;&gt; 机器可执行的二进制机器码 &#x3D;&gt; 程序运行</span><br></pre></td></tr></table></figure>

<h3 id="采用字节码的好处？"><a href="#采用字节码的好处？" class="headerlink" title="采用字节码的好处？"></a>采用字节码的好处？</h3><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h2 id="Java-中的几种基本数据类型是什么？各自占用多少字节？"><a href="#Java-中的几种基本数据类型是什么？各自占用多少字节？" class="headerlink" title="Java 中的几种基本数据类型是什么？各自占用多少字节？"></a>Java 中的几种基本数据类型是什么？各自占用多少字节？</h2><p>Java 支持的数据类型包括基本数据类型和引用类型。</p>
<p><strong>基本数据</strong>类型如下：</p>
<ul>
<li>整数值型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>字符型：<code>char</code></li>
<li>浮点类型：<code>float</code>、<code>double</code></li>
<li>布尔型：<code>boolean</code></li>
<li>整数型：默认 <code>int</code> 型，小数默认是 <code>double</code> 型。Float 和 Long 类型的必须加后缀。如：<code>float f = 100f</code> </li>
</ul>
<p><strong>引用类型</strong>声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<ul>
<li>引用类型包括类、接口、数组等。</li>
<li>特别注意，String 是引用类型不是基本类型。</li>
</ul>
<h3 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h3><ul>
<li>值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</li>
</ul>
<p>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</p>
<h3 id="是否可以在-static-环境中访问非-static-变量？"><a href="#是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="是否可以在 static 环境中访问非 static 变量？"></a>是否可以在 static 环境中访问非 static 变量？</h3><p><code>static</code> 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 <code>static</code> 变量进行初始化。</p>
<p>如果你的代码尝试不用实例来访问非 <code>static</code> 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h3 id="char-型变量中能不能存贮一个中文汉字？为什么？"><a href="#char-型变量中能不能存贮一个中文汉字？为什么？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字？为什么？"></a>char 型变量中能不能存贮一个中文汉字？为什么？</h3><ul>
<li><p>在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。</p>
</li>
<li><p>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。</p>
</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p>
<ul>
<li><p>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
</blockquote>
</li>
<li><p>StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 <code>synchronized</code> 修饰，因此它的效率也比 StringBuffer 要高。</p>
<blockquote>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
</li>
</ul>
<h3 id="对于三者使用的总结？"><a href="#对于三者使用的总结？" class="headerlink" title="对于三者使用的总结？"></a>对于三者使用的总结？</h3><ul>
<li><p>操作少量的数据 = String 。</p>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder 。</p>
<blockquote>
<p>甚至有时，我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。具体可以参考 <a target="_blank" rel="noopener" href="http://nathanchen.github.io/14596982516208.html">《StringBuilder 在高性能场景下的正确用法》</a> 文章。</p>
</blockquote>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p>
<blockquote>
<p>实际场景下，我们基本不太会出现，多线程操作同一个 StringBuffer 对象。</p>
</blockquote>
</li>
</ul>
<h3 id="String-s-new-String-“xyz”-会创建几个对象？"><a href="#String-s-new-String-“xyz”-会创建几个对象？" class="headerlink" title="String s = new String(“xyz”) 会创建几个对象？"></a>String s = new String(“xyz”) 会创建几个对象？</h3><ul>
<li>首先，在 String 池内找，找到 <code>&quot;xyz&quot;</code> 字符串，不创建 <code>&quot;xyz&quot;</code> 对应的 String 对象，否则创建一个对象。</li>
<li>然后，遇到 <code>new</code> 关键字，在内存上创建 String 对象，并将其返回给 <code>s</code> ，又一个对象。</li>
</ul>
<p>所以，总共是 1 个或者 2 个对象。</p>
<p>具体的，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/tzs_1041218129/article/details/69367423">《关于String s = new String(“xyz”); 创建几个对象的问题》</a> 文章的测试代码。</p>
<h3 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h3><p>简单的来说，String 类中使用 <code>final</code> 关键字字符数组保存字符串。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; String.java</span><br><span class="line"></span><br><span class="line">private final char[] value;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以 String 对象是不可变的。</li>
</ul>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 <code>char[] value</code> ，但是没有用 <code>final</code> 关键字修饰。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AbstractStringBuilder.java</span><br><span class="line"></span><br><span class="line">char[] value;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以这两种对象都是可变的。</li>
</ul>
<h3 id="StringTokenizer-是什么？"><a href="#StringTokenizer-是什么？" class="headerlink" title="StringTokenizer 是什么？"></a>StringTokenizer 是什么？</h3><p>StringTokenizer ，是一个用来分割字符串的工具类。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringTokenizer st &#x3D; new StringTokenizer(”Hello World”);</span><br><span class="line">while (st.hasMoreTokens()) &#123;</span><br><span class="line">    System.out.println(st.nextToken());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>



<h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<h3 id="为什么要转换？"><a href="#为什么要转换？" class="headerlink" title="为什么要转换？"></a>为什么要转换？</h3><p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p>
<ul>
<li>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。</li>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
<li>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</li>
</ul>
<h3 id="int-和-Integer-有什么区别？"><a href="#int-和-Integer-有什么区别？" class="headerlink" title="int 和 Integer 有什么区别？"></a>int 和 Integer 有什么区别？</h3><ul>
<li><code>int</code> 是基本数据类型。</li>
<li>Integer 是其包装类，注意是一个类。</li>
</ul>
<p>当然，要注意下 Integer 的缓存策略，可以看看 <a target="_blank" rel="noopener" href="http://www.importnew.com/18884.html">《理解Java Integer 的缓存策略》</a> 文章。</p>
<h2 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a>equals 与 == 的区别？</h2><ul>
<li><p>值类型（int,char,long,boolean等）的话</p>
<ul>
<li>都是用 == 判断相等性。</li>
</ul>
</li>
<li><p>对象引用的话</p>
<ul>
<li><p>== 判断引用所指的对象是否是同一个。</p>
</li>
<li><p>equals 方法，是 Object 的成员函数，有些类会覆盖(<code>override</code>) 这个方法，用于判断对象的等价性。</p>
<blockquote>
<p>如 String 类，两个引用所指向的 String 都是 <code>&quot;abc&quot;</code> ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals 方法判断一定是相等的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？"><a href="#如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？" class="headerlink" title="如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？"></a>如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？</h3><p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。</p>
<ul>
<li>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals 方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals 方法满足不了当前的需求，所以我们要重写 equals 方法。</li>
<li>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<h3 id="这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系"><a href="#这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系" class="headerlink" title="这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?"></a>这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?</h3><ol>
<li><p>equals 方法，用于比较对象的内容是否相等。</p>
<blockquote>
<p>当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p>
</blockquote>
</li>
<li><p>hashCode 方法，大多在集合中用到。</p>
<blockquote>
<p>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</p>
<p>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p>
</blockquote>
</li>
</ol>
<h3 id="有没有可能-2-个不相等的对象有相同的-hashCode？"><a href="#有没有可能-2-个不相等的对象有相同的-hashCode？" class="headerlink" title="有没有可能 2 个不相等的对象有相同的 hashCode？"></a>有没有可能 2 个不相等的对象有相同的 hashCode？</h3><p>不相等的对象可能有相同的hashCode，这个被称为<strong>哈希碰撞</strong>。</p>
<p>相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 的情况 。</p>
<p>所以说，equals 和 hashCode 的关系会是：</p>
<ul>
<li>equals 不相等，hashCode 可能相等。</li>
<li>equals 相等，请重写 hashCode 方法，保证 hashCode 相等。</li>
</ul>
<p>一般来说，hashCode 方法的重写，可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010799123">《科普：为什么 String hashCode 方法选择数字31作为乘子》</a> </p>
<h2 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h2><p>1）final</p>
<p><code>final</code> ，是修饰符关键字。</p>
<ul>
<li>如果一个类被声明为 <code>final</code> ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 <code>abstract</code> 的，又被声明为 <code>final</code> 的。</li>
<li>将变量或方法声明为 <code>final</code> ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 <code>final</code> 的方法也同样只能使用，不能重写。</li>
</ul>
<blockquote>
<p>另外，在早期的 Java 实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 <code>final</code> 方法进行这些优化了）。类中所有的<code>private</code> 方法都隐式地指定为 <code>final</code> 。</p>
</blockquote>
<p>2）finally</p>
<p>在异常处理时提供 <code>finally</code> 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 <code>catch</code> 子句就会执行，然后控制就会进入 <code>finally</code> 块（如果有的话）。</p>
<p>在以下 4 种特殊情况下，finally块不会被执行：</p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU 。</li>
</ul>
<p>3）finalize</p>
<p><code>finalize</code> ，是方法名。</p>
<p>Java 允许使用 <code>#finalize()</code> 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</p>
<ul>
<li>它是在 Object 类中定义的，因此所有的类都继承了它。</li>
<li>子类覆盖 <code>finalize()</code> 方法，以整理系统资源或者执行其他清理工作。</li>
<li><code>#finalize()</code> 方法，是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<p>一般情况下，我们在业务中不会自己实现这个方法，更多是在一些框架中使用，例如 <a target="_blank" rel="noopener" href="https://github.com/netty/netty/issues/4145">《Netty Using finalize() to release ByteBufs》</a> 。</p>
<h3 id="String-类能被继承吗，为什么？"><a href="#String-类能被继承吗，为什么？" class="headerlink" title="String 类能被继承吗，为什么？"></a>String 类能被继承吗，为什么？</h3><p>不能，因为 String 是 <code>final</code> 修饰。</p>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<ul>
<li>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java 接口中声明的变量默认都是 <code>final</code> 的。抽象类可以包含非 <code>final</code> 的变量。</li>
<li>Java 接口中的成员函数默认是 <code>public</code> 的。抽象类的成员函数可以是 <code>private</code>，<code>protected</code> 或者是 <code>public</code> </li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 <code>#main(String[] args)</code> 方法的话是可以被调用的。</li>
</ul>
<h3 id="继承和组合的区别在哪？"><a href="#继承和组合的区别在哪？" class="headerlink" title="继承和组合的区别在哪？"></a>继承和组合的区别在哪？</h3><ul>
<li>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 <code>extends</code> 明确标识，在设计时一般没有争议性。</li>
<li>组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。<ul>
<li>比如，计算机与 CPU 、公司与员工的关系等。</li>
<li>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li>
</ul>
</li>
</ul>
<p>因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21862257">《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》</a> 文章。</p>
<h3 id="请详细讲述一下-RandomAccess-接口有什么作用？"><a href="#请详细讲述一下-RandomAccess-接口有什么作用？" class="headerlink" title="请详细讲述一下 RandomAccess 接口有什么作用？"></a>请详细讲述一下 RandomAccess 接口有什么作用？</h3><p>RandomAccess 用来当标记的，是一种<strong>标记</strong>接口，接口的非典型用法。</p>
<p>意思是，随机访问任意下标元素都比较快。</p>
<p>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法。</p>
<h2 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h2><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<p>感兴趣的胖友，可以详细看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Vencc__/article/details/52222628">《Java 类的实例化顺序》</a> 文章，提供的示例。</p>
<h2 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h2><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155">《Java 内部类总结（吐血之作）》</a> 文章。</p>
<h3 id="内部类的作用是什么？"><a href="#内部类的作用是什么？" class="headerlink" title="内部类的作用是什么？"></a>内部类的作用是什么？</h3><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<h3 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。</p>
<h3 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h2 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h2><p>Java IO 相关的类，在 <code>java.io</code> 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。</p>
<p>如下图所示：</p>
<p><img src="http://static2.iocoder.cn/eb408ac849a679b09941be7ebd734768" alt="类图"></p>
<h2 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。</li>
</ul>
<p>反序列化的过程，则是和序列化相反的过程。</p>
<blockquote>
<p>另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。</p>
</blockquote>
<h3 id="如何实现-Java-序列化？"><a href="#如何实现-Java-序列化？" class="headerlink" title="如何实现 Java 序列化？"></a>如何实现 Java 序列化？</h3><blockquote>
<p>如下的方式，就是 Java 内置的序列化方案，实际场景下，我们可以自定义序列化的方案，例如说 Google Protobuf 。</p>
</blockquote>
<p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，<code>implements Serializable</code> 只是为了标注该对象是可被序列化的。</p>
<ul>
<li>序列化<ul>
<li>然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象</li>
<li>接着，使用 ObjectOutputStream 对象的 <code>#writeObject(Object obj)</code> 方法，就可以将参数为 <code>obj</code> 的对象写出(即保存其状态)。</li>
</ul>
</li>
<li>反序列化<ul>
<li>要恢复的话则用输入流。</li>
</ul>
</li>
</ul>
<h3 id="Java-序列话中，如果有些字段不想进行序列化怎么办？"><a href="#Java-序列话中，如果有些字段不想进行序列化怎么办？" class="headerlink" title="Java 序列话中，如果有些字段不想进行序列化怎么办？"></a>Java 序列话中，如果有些字段不想进行序列化怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</li>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
</ul>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>一般来说，有两种方式：</p>
<ul>
<li>1、实现 Cloneable 接口，并重写 Object 类中的 <code>#clone()</code> 方法。可以实现<strong>浅克隆</strong>，也可以实现<strong>深克隆</strong>。</li>
<li>2、实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的<strong>深克隆</strong>。</li>
</ul>
<blockquote>
<p>艿艿：这个问题，也可以变种来问，什么是<strong>浅克隆</strong>和<strong>深克隆</strong>。</p>
</blockquote>
<p>具体的代码实现，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/caomiao2006/article/details/52590622">《Java 对象的浅克隆和深克隆》</a> 文章。</p>
<p>实际场景下，我们使用的克隆比较少，更多是对象之间的属性克隆。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/tison/p/7840647.html">《浅谈 BeanUtils 的拷贝，深度克隆》</a> 文章。</p>
<h2 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h2><p>Java 的异常体系，基于共同的祖先 <code>java.lang.Throwable</code> 类。如下图所示：</p>
<ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<h3 id="异常的使用的注意地方？"><a href="#异常的使用的注意地方？" class="headerlink" title="异常的使用的注意地方？"></a>异常的使用的注意地方？</h3><ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 <code>catch</code> 中忽略掉捕获到的异常。</li>
</ul>
<h3 id="Throwable-类常用方法？"><a href="#Throwable-类常用方法？" class="headerlink" title="Throwable 类常用方法？"></a>Throwable 类常用方法？</h3><ul>
<li><code>#getMessage()</code> 方法：返回异常发生时的详细信息。</li>
<li><code>#getCause()</code> 方法：获得导致当前 Throwable 异常的 Throwable 异常。</li>
<li><code>#getStackTrace()</code>方法：获得 Throwable 对象封装的异常信息。</li>
<li><code>#printStackTrace()</code> 方法：在控制台上打印。</li>
</ul>
<h3 id="请列出-5-个运行时异常？"><a href="#请列出-5-个运行时异常？" class="headerlink" title="请列出 5 个运行时异常？"></a>请列出 5 个运行时异常？</h3><ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>ArrayStoreException</li>
<li>BufferOverflowException</li>
</ul>
<h3 id="throw-与-throws-的区别-？"><a href="#throw-与-throws-的区别-？" class="headerlink" title="throw 与 throws 的区别 ？"></a>throw 与 throws 的区别 ？</h3><ul>
<li><code>throw</code> ，用于在程序中显式地抛出一个异常。</li>
<li><code>throws</code> ，用于指出在该方法中没有处理的异常。<strong>每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常</strong>。最后，多个异常用逗号分隔。</li>
</ul>
<h3 id="异常处理中-finally-语句块的重要性"><a href="#异常处理中-finally-语句块的重要性" class="headerlink" title="异常处理中 finally 语句块的重要性?"></a>异常处理中 finally 语句块的重要性?</h3><p>不管程序是否发生了异常, <code>finally</code> 语句块都会被执行，甚至当没有<code>catch</code> 声明但抛出了一个异常时, <code>finally</code> 语句块也会被执行。</p>
<p><code>finally</code> 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等。</p>
<h3 id="异常被处理后异常对象会发生什么"><a href="#异常被处理后异常对象会发生什么" class="headerlink" title="异常被处理后异常对象会发生什么?"></a>异常被处理后异常对象会发生什么?</h3><p>异常对象会在下次 GC 执行时被回收。</p>
<h2 id="反射的用途及实现？"><a href="#反射的用途及实现？" class="headerlink" title="反射的用途及实现？"></a>反射的用途及实现？</h2><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 <code>Class#forName(String className)</code> 方法，也是使用反射。</li>
</ul>
<p>不了解 Java 反射的同学，可以看看 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhaopei/p/reflection.html">《什么是反射、反射可以做些什么》</a> 。</p>
<h3 id="反射中，Class-forName-和-ClassLoader-区别？"><a href="#反射中，Class-forName-和-ClassLoader-区别？" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别？"></a>反射中，Class.forName 和 ClassLoader 区别？</h3><p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li><p><code>Class#forName(...)</code> 方法，除了将类的 <code>.class</code> 文件加载到JVM 中之外，还会对类进行解释，执行类中的 <code>static</code> 块。</p>
</li>
<li><p>ClassLoader 只干一件事情，就是将 <code>.class</code> 文件加载到 JVM 中，不会执行 <code>static</code> 中的内容，只有在 newInstance 才会去执行 <code>static</code> 块。</p>
<blockquote>
<p><code>Class#forName(name, initialize, loader)</code> 方法，带参函数也可控制是否加载 <code>static</code> 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</p>
</blockquote>
</li>
</ul>
<p>详细的测试，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/52262340">《Java 反射中，Class.forName 和ClassLoader 的区别(代码说话)》</a> 文章。</p>
<h3 id="UnsupportedOperationException-是什么？"><a href="#UnsupportedOperationException-是什么？" class="headerlink" title="UnsupportedOperationException 是什么？"></a>UnsupportedOperationException 是什么？</h3><p>UnsupportedOperationException ，是用于表明操作不支持的异常。</p>
<p>在 JDK 类中已被大量运用，在集合框架<code>java.util.Collections.UnmodifiableCollection</code> 将会在所有 add 和 remove 操作中抛出这个异常。</p>
<h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><p>直接看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5cac4cb9be54">《深入浅出 Java 注解》</a> 。</p>
<p>如果胖友没有自己实现自定义的注解，千万一定马上去尝试写下。酱紫，我们会对注解，有更好且清晰的认识。</p>
<h2 id="什么时候用断言-assert-？"><a href="#什么时候用断言-assert-？" class="headerlink" title="什么时候用断言(assert)？"></a>什么时候用断言(assert)？</h2><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<ul>
<li><p>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。</p>
</li>
<li><p>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为<code>true</code>；如果表达式的值为 <code>false</code> ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言可以有两种形式：</p>
<ul>
<li><code>assert Expression1;</code> 。</li>
<li><code>assert Expression1 : Expression2;</code> 。</li>
<li>Expression1 应该总是产生一个布尔值。</li>
<li>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</li>
</ul>
</li>
<li><p>要在运行时启用断言，可以在启动 JVM 时使用 <code>-enableassertions</code> 或者 <code>-ea</code> 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 <code>-da</code> 或者 <code>-disableassertions</code> 标记。要在系统类中启用或禁用断言，可使用 <code>-esa</code> 或 <code>-dsa</code> 标记。还可以在包的基础上启用或者禁用断言。</p>
</li>
</ul>
<p>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。</p>
<p>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p>
<h2 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h2><ul>
<li><p>使用 <code>new</code> 关键字创建对象。</p>
</li>
<li><p>使用 Class 类的 newInstance 方法(反射机制)。</p>
</li>
<li><p>使用 Constructor 类的 newInstance 方法(反射机制)。</p>
</li>
<li><p>使用 clone 方法创建对象。</p>
</li>
<li><p>使用(反)序列化机制创建对象。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/07/21/05-memory-allocation-gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/21/05-memory-allocation-gc/" class="post-title-link" itemprop="url">JVM 系列(五) - 内存分配与回收策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-21T00:00:00+08:00">2020-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-04 15:56:20" itemprop="dateModified" datetime="2020-08-04T15:56:20+08:00">2020-08-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>对象的内存分配，就是在堆上分配（也可能经过 JIT 编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的 Eden 区上，少数情况下可能直接分配在老年代，<strong>分配规则不固定</strong>，取决于当前使用的垃圾收集器组合以及相关的参数配置。</p>
<p>以下列举几条最普遍的内存分配规则，供大家学习。</p>
<h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<p>👇<strong>Minor GC</strong> vs <strong>Major GC</strong>/<strong>Full GC</strong>：</p>
<ul>
<li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。 </li>
</ul>
<blockquote>
<p>在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。</p>
</blockquote>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或数据。</p>
<p>一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p>
<p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（还记得吗，新生代采用复制算法回收垃圾）</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>JVM 给每个对象定义了一个对象年龄计数器。当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p>
<p>使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果当前新生代的 Survivor 中，低于或等于某年龄的所有对象的大小总和大于 Survivor 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>JDK 6 Update 24 之前的规则是这样的：<br>在发生 Minor GC 之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>， 如果这个条件成立，Minor GC 可以确保是安全的； 如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。</p>
<p>JDK 6 Update 24 之后的规则变为：<br>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<p>通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。</p>
<p>这个过程就是分配担保。</p>
<hr>
<p>👇总结一下有哪些情况可能会触发 JVM 进行 Full GC。</p>
<ol>
<li><p>System.gc() 方法的调用<br><br>此方法的调用是建议 JVM 进行 Full GC，注意这<strong>只是建议而非一定</strong>，但在很多情况下它会触发 Full GC，从而增加 Full GC 的频率。通常情况下我们只需要让虚拟机自己去管理内存即可，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。</p>
</li>
<li><p>老年代空间不足<br><br>老年代空间不足会触发 Full GC操作，若进行该操作后空间依然不足，则会抛出如下错误：<br><br><code>java.lang.OutOfMemoryError: Java heap space</code></p>
</li>
<li><p>永久代空间不足(JDK 8之后使用元空间)<br><br>JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：<br><br><code>java.lang.OutOfMemoryError: PermGen space </code></p>
</li>
<li><p>CMS GC 时出现 promotion failed 和 concurrent mode failure<br><br>promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</p>
</li>
<li><p>统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Seif Zheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Seif Zheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fatefrank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fatefrank" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:astutenicol@gmail.com" title="E-Mail → mailto:astutenicol@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seif Zheng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
