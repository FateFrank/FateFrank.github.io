<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fatefrank.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Seif Zheng&#39;s blog">
<meta property="og:url" content="http://fatefrank.github.io/page/2/index.html">
<meta property="og:site_name" content="Seif Zheng&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Seif Zheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fatefrank.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Seif Zheng's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Seif Zheng's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日积月累，水滴石穿</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fatefrank" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/06/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Spring 面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-06 00:00:00 / 修改时间：11:50:21" itemprop="dateCreated datePublished" datetime="2020-08-06T00:00:00+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Spring-整体"><a href="#Spring-整体" class="headerlink" title="Spring 整体"></a>Spring 整体</h2><h3 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h3><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<ul>
<li><p>它是轻量级、松散耦合的。</p>
<blockquote>
<p>它的轻量级主要是相对于 EJB 。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</p>
</blockquote>
</li>
<li><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
</li>
<li><p>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</p>
</li>
</ul>
<h3 id="Spring-Framework-中各模块介绍？"><a href="#Spring-Framework-中各模块介绍？" class="headerlink" title="Spring Framework 中各模块介绍？"></a>Spring Framework 中各模块介绍？</h3><p>如下是一张比较早期版本的 Spring Framework 的模块图：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/01.jpg" alt="Spring Framework"></p>
<p><strong>Spring 核心容器</strong></p>
<blockquote>
<p>对应图中，Core Container 。</p>
</blockquote>
<p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li><p>Spring Core</p>
</li>
<li><p>Spring Bean</p>
<blockquote>
<p>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p>
</blockquote>
</li>
<li><p>Spring Context</p>
<blockquote>
<p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。</p>
</blockquote>
</li>
<li><p>SpEL (Spring Expression Language)</p>
<blockquote>
<p>Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2 中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置 Bean 定义。</p>
</blockquote>
</li>
</ul>
<p>或者说，这块就是 Spring IoC 。</p>
<p><strong>数据访问</strong></p>
<blockquote>
<p>对应图中，Data Access 。</p>
</blockquote>
<p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
<blockquote>
<p>Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</p>
</blockquote>
</li>
<li><p>ORM (Object Relational Mapping)</p>
<blockquote>
<p>Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。</p>
<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</blockquote>
</li>
<li><p>OXM (Object XML Mappers)</p>
<blockquote>
<p>Spring 提供了一套类似 ORM 的映射机制，用来将 Java 对象和 XML 文件进行映射。这就是 Spring 的对象 XML 映射功能，有时候也成为 XML 的序列化和反序列化。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
<li><p>Transaction</p>
<blockquote>
<p>Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。</p>
</blockquote>
</li>
</ul>
<p><strong>Web</strong></p>
<p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>WebMVC</p>
<blockquote>
<p>MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p>
</blockquote>
</li>
<li><p>WebFlux</p>
<blockquote>
<p>基于 Reactive 库的响应式的 Web 开发框架</p>
<p>不了解的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html">《使用 Spring 5 的 WebFlux 开发反应式 Web 应用》</a></p>
</blockquote>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>Spring 4.0 的一个最大更新是增加了对 Websocket 的支持。</p>
<p>Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</p>
<p>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</p>
</blockquote>
</li>
<li><p><del>Portlet</del> 已经废弃</p>
</li>
</ul>
<p><strong>AOP</strong></p>
<p>该层支持面向切面编程。它包含以下模块：</p>
<ul>
<li><p>AOP</p>
<blockquote>
<p>通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</p>
<p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p>
</blockquote>
</li>
<li><p>Aspects</p>
<blockquote>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</blockquote>
</li>
<li><p>Instrumentation</p>
<blockquote>
<p>该层为类检测和类加载器实现提供支持。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><p>JMS (Java Messaging Service)</p>
<blockquote>
<p>提供了一个 JMS 集成框架，简化了 JMS API 的使用。</p>
<p>可能有胖友不太了解 JMS ，可以看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpi/p/5559349.html">《JMS(Java消息服务)入门教程》</a> 。</p>
</blockquote>
</li>
<li><p>Test</p>
<blockquote>
<p>该模块为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</blockquote>
</li>
<li><p>Messaging</p>
<blockquote>
<p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
</blockquote>
</li>
</ul>
<h3 id="使用-Spring-框架能带来哪些好处？"><a href="#使用-Spring-框架能带来哪些好处？" class="headerlink" title="使用 Spring 框架能带来哪些好处？"></a>使用 Spring 框架能带来哪些好处？</h3><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<ul>
<li><strong>DI</strong> ：**<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/">Dependency Injection(DI)</a>** 方法，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li><strong>轻量级</strong>：与 EJB 容器相比较，IoC 容器更加趋向于<strong>轻量级</strong>。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li><strong>面向切面编程(AOP)**： Spring 支持面向</strong>切面编程**，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li><strong>集成主流框架</strong>：Spring 并没有闭门造车，Spring <strong>集成</strong>了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照<strong>模块</strong>的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li><strong>便捷的测试</strong>：要 <a target="_blank" rel="noopener" href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/">测试一项用Spring开发的应用程序</a> 十分简单，因为<strong>测试</strong>相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li><strong>Web 框架</strong>：Spring 的 <strong>Web 框架</strong>亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li><strong>事务管理</strong>：Spring 提供了一个便捷的<strong>事务管理</strong>接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
<li><strong>异常处理</strong>：Spring 提供一个方便的 API ，将特定技术的异常(由JDBC, Hibernate, 或 JDO 抛出)转化为一致的、Unchecked 异常。</li>
</ul>
<p>当然，Spring 代码优点的同时，一定会带来相应的缺点：</p>
<ul>
<li>每个框架都有的问题，调试阶段不直观，后期的 bug 对应阶段，不容易判断问题所在。要花一定的时间去理解它。</li>
<li>把很多 JavaEE 的东西封装了，在满足快速开发高质量程序的同时，隐藏了实现细节。</li>
</ul>
<h3 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h3><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 <a target="_blank" rel="noopener" href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/">RestTemplate</a>、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>视图帮助(View Helper) — Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
<p>当然，感兴趣的胖友，觉得不过瘾，可以看看艿艿基友知秋写的几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-1">《Spring 框架中的设计模式(一)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-2">《Spring 框架中的设计模式(二)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-3">《Spring 框架中的设计模式(三)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-4">《Spring 框架中的设计模式(四)》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/Spring/DesignPattern-5">《Spring 框架中的设计模式(五)》</a></li>
</ul>
<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><blockquote>
<p>下面，我们会将分成 IoC 和 Bean 两部分来分享 Spring 容器的内容。</p>
<ul>
<li>IoC ，侧重在于容器。</li>
<li>Bean ，侧重在于被容器管理的 Bean 。</li>
</ul>
</blockquote>
<h3 id="什么是-Spring-IoC-容器？"><a href="#什么是-Spring-IoC-容器？" class="headerlink" title="什么是 Spring IoC 容器？"></a>什么是 Spring IoC 容器？</h3><blockquote>
<p>注意，正确的拼写是 IoC 。</p>
</blockquote>
<p>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</p>
<ul>
<li>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的<strong>配置元数据</strong> Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码<strong>提供</strong>。</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/02.jpg" alt="Spring IoC"></p>
<h3 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h3><p>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。</p>
<ul>
<li>你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
<p>另外，依赖注入的英文缩写是 Dependency Injection ，简称 DI 。</p>
<h3 id="IoC-和-DI-有什么区别？"><a href="#IoC-和-DI-有什么区别？" class="headerlink" title="IoC 和 DI 有什么区别？"></a>IoC 和 DI 有什么区别？</h3><p><strong>Dependency Injection</strong>原来，它叫 IoC 。</p>
<p>Martin Flower 发话了，是个框架都有 IoC ，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection 。</p>
<p>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob 管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同 Spring 相比，它更早进入我的大脑。一切都是那么朦胧，直至 Spring 出现。</p>
<p>慢慢的，我知道了它还分为三种：</p>
<ul>
<li>Interface Injection（type 1）</li>
<li>Setter Injection（type 2）</li>
<li>Constructor Injection（type 3）。</li>
</ul>
<p>Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。</p>
<p>在 Spring 中，它是一切的基础。Spring 的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>
<h3 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过<strong>三种</strong>方式完成，即：</p>
<blockquote>
<p>上面一个问题的三种方式的英文，下面是三种方式的中文。</p>
</blockquote>
<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
<p>目前，在 Spring Framework 中，仅使用构造函数和 setter 注入这<strong>两种</strong>方式。</p>
<p>那么这两种方式各有什么优缺点呢？</p>
<p>可以简单阅读 <a target="_blank" rel="noopener" href="https://my.oschina.net/itblog/blog/203746">《Spring两种依赖注入方式的比较》</a>，不用太较真。综述来说：</p>
<table>
<thead>
<tr>
<th align="left">构造函数注入</th>
<th align="left">setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">没有部分注入</td>
<td align="left">有部分注入</td>
</tr>
<tr>
<td align="left">不会覆盖 setter 属性</td>
<td align="left">会覆盖 setter 属性</td>
</tr>
<tr>
<td align="left">任意修改都会创建一个新实例</td>
<td align="left">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="left">适用于设置很多属性</td>
<td align="left">适用于设置少量属性</td>
</tr>
</tbody></table>
<ul>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
<h3 id="Spring-中有多少种-IoC-容器？"><a href="#Spring-中有多少种-IoC-容器？" class="headerlink" title="Spring 中有多少种 IoC 容器？"></a>Spring 中有多少种 IoC 容器？</h3><p>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext 。</p>
<p><strong>BeanFactory</strong></p>
<blockquote>
<p>BeanFactory 在 <code>spring-beans</code> 项目提供。</p>
</blockquote>
<p>BeanFactory ，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</p>
<p><strong>ApplicationContext</strong></p>
<blockquote>
<p>ApplicationContext 在 <code>spring-context</code> 项目提供。</p>
</blockquote>
<p>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：</p>
<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
</ul>
<p>另外，ApplicationContext 会自动初始化非懒加载的 Bean 对象们。</p>
<p>详细的内容，感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 一文。源码之前无秘密。简单总结下 BeanFactory 与 ApplicationContext 两者的差异：</p>
<table>
<thead>
<tr>
<th align="left">BeanFactory</th>
<th align="left">ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left">它使用懒加载</td>
<td align="left">它使用即时加载</td>
</tr>
<tr>
<td align="left">它使用语法显式提供资源对象</td>
<td align="left">它自己创建和管理资源对象</td>
</tr>
<tr>
<td align="left">不支持国际化</td>
<td align="left">支持国际化</td>
</tr>
<tr>
<td align="left">不支持基于依赖的注解</td>
<td align="left">支持基于依赖的注解</td>
</tr>
</tbody></table>
<p>另外，BeanFactory 也被称为<strong>低级</strong>容器，而 ApplicationContext 被称为<strong>高级</strong>容器。</p>
<h3 id="请介绍下常用的-BeanFactory-容器？"><a href="#请介绍下常用的-BeanFactory-容器？" class="headerlink" title="请介绍下常用的 BeanFactory 容器？"></a>请介绍下常用的 BeanFactory 容器？</h3><p>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h3 id="请介绍下常用的-ApplicationContext-容器？"><a href="#请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="请介绍下常用的 ApplicationContext 容器？"></a>请介绍下常用的 ApplicationContext 容器？</h3><p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<ul>
<li><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
</li>
</ul>
<p>当然，目前我们更多的是使用 Spring Boot 为主，所以使用的是第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h3 id="列举一些-IoC-的一些好处？"><a href="#列举一些-IoC-的一些好处？" class="headerlink" title="列举一些 IoC 的一些好处？"></a>列举一些 IoC 的一些好处？</h3><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
<h3 id="简述-Spring-IoC-的实现机制？"><a href="#简述-Spring-IoC-的实现机制？" class="headerlink" title="简述 Spring IoC 的实现机制？"></a>简述 Spring IoC 的实现机制？</h3><p>简单来说，Spring 中的 IoC 的实现原理，就是<strong>工厂模式</strong>加<strong>反射机制</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;        </span><br><span class="line">        Fruit f = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            f = (Fruit) Class.forName(className).newInstance();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;            </span><br><span class="line">            e.printStackTrace();        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> f;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        Fruit f = Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);        </span><br><span class="line">        <span class="keyword">if</span>(f != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            f.eat();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Fruit 接口，有 Apple 和 Orange 两个实现类。</li>
<li>Factory 工厂，通过反射机制，创建 <code>className</code> 对应的 Fruit 对象。</li>
<li>Client 通过 Factory 工厂，获得对应的 Fruit 对象。</li>
<li>😈 实际情况下，Spring IoC 比这个复杂很多很多，例如单例 Bean 对象，Bean 的属性注入，相互依赖的 Bean 的处理，以及等等。</li>
</ul>
<p>在基友 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">《面试问烂的 Spring IoC 过程》</a> 的文章中，把 Spring IoC 相关的内容，讲的非常不错。</p>
<h3 id="Spring-框架中有哪些不同类型的事件？"><a href="#Spring-框架中有哪些不同类型的事件？" class="headerlink" title="Spring 框架中有哪些不同类型的事件？"></a>Spring 框架中有哪些不同类型的事件？</h3><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 Bean 用来监听在 ApplicationContext 中发布的事件。如果一个 Bean 实现了 ApplicationListener 接口，当一个ApplicationEvent 被发布以后，Bean 会自动被通知。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllApplicationEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// process event  </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供了以下五种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的 <code>#refresh()</code> 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext 的 <code>#start()</code> 方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 <code>#stop()</code> 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
</ol>
<hr>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发<strong>自定义</strong>的事件。</p>
<p>① 示例自定义的事件的类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomApplicationEvent</span><span class="params">(Object source, <span class="keyword">final</span> String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 为了监听这个事件，还需要创建一个监听器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CustomApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CustomApplicationEvent applicationEvent)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// handle event  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 之后通过 ApplicationContext 接口的 <code>#publishEvent(Object event)</code> 方法，来发布自定义事件。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 CustomApplicationEvent 事件</span></span><br><span class="line">CustomApplicationEvent customEvent = <span class="keyword">new</span> CustomApplicationEvent(</span><br><span class="line">    applicationContext, <span class="string">&quot;Test message&quot;</span>);</span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">applicationContext.publishEvent(customEvent);</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
<p>这个问题，胖友可以在回过头看 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「什么是 Spring IoC 容器？」</a> 问题，相互对照。</p>
<h3 id="Spring-有哪些配置方式"><a href="#Spring-有哪些配置方式" class="headerlink" title="Spring 有哪些配置方式?"></a>Spring 有哪些配置方式?</h3><p>单纯从 Spring Framework 提供的方式，一共有三种：</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line">&lt;!-- bean definitions go here --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 `` 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class StudentConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public StudentBean myStudent() &#123;</span><br><span class="line">        return new StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h3 id="Spring-支持几种-Bean-Scope-？"><a href="#Spring-支持几种-Bean-Scope-？" class="headerlink" title="Spring 支持几种 Bean Scope ？"></a>Spring 支持几种 Bean Scope ？</h3><blockquote>
<p>这个是一个比较小众的题目，简单了解即可。</p>
</blockquote>
<p>Spring Bean 支持 5 种 Scope ，分别如下：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。<strong>默认</strong></li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
<blockquote>
<p>另外，网络上很多文章说有 Global-session 级别，它是 Portlet 模块独有，目前已经废弃，在 Spring5 中是找不到的。</p>
</blockquote>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，<strong>最后三个才可用</strong>。</p>
<p>再补充一点，开发者是可以<strong>自定义</strong> Bean Scope ，具体可参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/elim168/article/details/75581670">《Spring（10）—— Bean 作用范围（二）—— 自定义 Scope》</a> 。</p>
<p>不错呢，还是那句话，这个题目简单了解下即可，实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。</p>
<h3 id="Spring-Bean-在容器的生命周期是什么样的？"><a href="#Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 在容器的生命周期是什么样的？"></a>Spring Bean 在容器的生命周期是什么样的？</h3><blockquote>
<p>这是一个比较高级的 Spring 的面试题，非常常见，并且答对比较加分。当然，如果实际真正弄懂，需要对 Spring Bean 的源码，有比较好的理解，所以 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码》</a> 系列，该读还是读吧。</p>
</blockquote>
<p>Spring Bean 的<strong>初始化</strong>流程如下：</p>
<ul>
<li><p>实例化 Bean 对象</p>
<ul>
<li><p>Spring 容器根据配置中的 Bean Definition(定义)中<strong>实例化</strong> Bean 对象。</p>
<blockquote>
<p>Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</p>
</blockquote>
</li>
<li><p>Spring 使用依赖注入<strong>填充</strong>所有属性，如 Bean 中所定义的配置。</p>
</li>
</ul>
</li>
<li><p>Aware 相关的属性，注入到 Bean 对象</p>
<ul>
<li>如果 Bean 实现 <strong>BeanNameAware</strong> 接口，则工厂通过传递 Bean 的 beanName 来调用 <code>#setBeanName(String name)</code> 方法。</li>
<li>如果 Bean 实现 <strong>BeanFactoryAware</strong> 接口，工厂通过传递自身的实例来调用 <code>#setBeanFactory(BeanFactory beanFactory)</code> 方法。</li>
</ul>
</li>
<li><p>调用相应的方法，进一步初始化 Bean 对象</p>
<ul>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则调用 <code>#preProcessBeforeInitialization(Object bean, String beanName)</code> 方法。</li>
<li>如果 Bean 实现 <strong>InitializingBean</strong> 接口，则会调用 <code>#afterPropertiesSet()</code> 方法。</li>
<li>如果为 Bean 指定了 <strong>init</strong> 方法（例如 `` 的 <code>init-method</code> 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则将调用 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</li>
</ul>
</li>
</ul>
<p>Spring Bean 的<strong>销毁</strong>流程如下：</p>
<ul>
<li>如果 Bean 实现 <strong>DisposableBean</strong> 接口，当 spring 容器关闭时，会调用 <code>#destroy()</code> 方法。</li>
<li>如果为 bean 指定了 <strong>destroy</strong> 方法（例如 `` 的 <code>destroy-method</code> 属性），那么将调用该方法。</li>
</ul>
<p>整体如下图：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/03.jpg" alt="流程图"></p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/08.png" alt="流程图"></p>
<h3 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h3><p>只有将 Bean <strong>仅</strong>用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<ul>
<li>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <code>或 </code> 中提供了 ``元素的使用。</li>
<li>内部 Bean 总是<strong>匿名</strong>的，并且它们总是作为<strong>原型 Prototype</strong> 。</li>
</ul>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.edureka.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.edureka.Person&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">“Scott</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="什么是-Spring-装配？"><a href="#什么是-Spring-装配？" class="headerlink" title="什么是 Spring 装配？"></a>什么是 Spring 装配？</h3><p>当 Bean 在 Spring 容器中组合在一起时，它被称为<strong>装配</strong>或 <strong>Bean 装配</strong>。Spring 容器需要知道需要什么 Bean 以及容器应该如何使用依赖注入来将 Bean 绑定在一起，同时装配 Bean 。</p>
<blockquote>
<p>装配，和上文提到的 DI 依赖注入，实际是一个东西。</p>
</blockquote>
<p><strong>自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】<strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>自动装配有什么局限？</strong></p>
<blockquote>
<p>艿艿：这个题目，了解下即可，也不是很准确。</p>
</blockquote>
<ul>
<li><p>覆盖的可能性 - 您始终可以使用<constructor-arg>和<property>设置指定依赖项，这将覆盖自动装配。</p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
<blockquote>
<p>这种，严格来说，也不能称为局限。因为可以通过配置文件来解决。</p>
</blockquote>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
</li>
</ul>
<h3 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h3><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p>
<ul>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li>
<li>而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
<h3 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h3><p>Spring 框架并没有对<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">单例</a> Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例 Bean 的<a target="_blank" rel="noopener" href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/">线程安全</a>和并发问题，需要开发者自行去搞定。</li>
<li>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Service 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p>
<p>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p>
<h3 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h3><blockquote>
<p>艿艿说：能回答出这个问题的，一般是比较厉害的。</p>
</blockquote>
<p>这是个比较复杂的问题，有能力的胖友，建议看下 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a></p>
<p>感觉，不通过源码，很难解释清楚这个问题。如果看不懂的胖友，可以在认真看完，在星球里，我们一起多交流下。好玩的。</p>
<h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><p>这块内容，实际写在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring Bean」</a> 中比较合适，考虑到后续的问题，都是关于注解的，所以单独起一个大的章节。</p>
<h3 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h3><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解，扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 `` 元素在 Spring 配置文件中启用它。</p>
<p>当然，如果胖友是使用 Spring Boot ，默认情况下已经开启。</p>
<h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li>
<li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li>
<li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li>
<li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
<h3 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h3><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。</p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>T T 貌似平时很少用这个注解噢。</li>
</ul>
<h3 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h3><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p>
<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h3><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，您可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p>
<p>例如，应用中有两个类型为 Employee 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(emp1)</span></span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><blockquote>
<p>Spring AOP 的面试题中，大多数都是概念题，主要是对切面的理解。概念点主要有：</p>
<ul>
<li>AOP</li>
<li>Aspect</li>
<li>JoinPoint</li>
<li>PointCut</li>
<li>Advice</li>
<li>Target</li>
<li>AOP Proxy</li>
<li>Weaving</li>
</ul>
</blockquote>
<ul>
<li>在阅读完 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring AOP」</a> 的面试题后，在回过头思考下这些概念点，到底理解了多少。注意，不是背，理解！</li>
</ul>
<p>非常推荐阅读如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a></li>
</ul>
<h3 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h3><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p>
<ul>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以**切面( Aspect )**作为基本单元。</li>
</ul>
<h3 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h3><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p>
<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
</ul>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/04.jpg" alt="流程图"></p>
<h3 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h3><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p>
<ul>
<li>一个方法的执行。</li>
<li>或者是一个异常的处理。</li>
</ul>
<p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h3 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h3><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p>
<blockquote>
<p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p>
</blockquote>
<ul>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
<p>是不是觉得有点绕，实际场景下，其实也不会弄的这么清楚~~</p>
<h3 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h3><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p>
<ul>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ul>
<p>或者，我们在换一种说法：</p>
<ol>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ol>
<h3 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h3><p>Advice ，<strong>通知</strong>。</p>
<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li>
</ul>
<p><strong>有哪些类型的 Advice？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<p>看起来，是不是和拦截器的执行时间，有几分相似。实际上，用于拦截效果的各种实现，大体都是类似的。</p>
<h3 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h3><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p>
<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
<h3 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><p>① <strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
<blockquote>
<p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p>
<p>感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="http://www.kailing.pub/article/index/arcid/178.html">《SkyWalking 源码分析之 JavaAgent 工具 ByteBuddy 的应用》</a> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>② <strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p>
<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<p>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; From 《Spring 源码深度解析》P172</span><br><span class="line">&#x2F;&#x2F; Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）</span><br><span class="line">&#x2F;&#x2F; 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。</span><br><span class="line">&#x2F;&#x2F; 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。</span><br><span class="line">&#x2F;&#x2F; 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：</span><br><span class="line">&#x2F;&#x2F;      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。</span><br><span class="line">&#x2F;&#x2F;      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。</span><br><span class="line">&#x2F;&#x2F; 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：</span><br><span class="line">&#x2F;&#x2F;      1&gt; 使用 JDK 原生支持，减少三方依赖</span><br><span class="line">&#x2F;&#x2F;      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;haiq&#x2F;p&#x2F;4304615.html</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，Spring AOP 的代码量不大，与其在窗户外面不清不楚，不如捅破它！感兴趣的胖友，可以撸一撸 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/aop-simple-intro/">《精尽 Spring 源码分析 —— AOP 源码简单导读》</a> 。</li>
</ul>
<p>或者，我们来换一个解答答案：</p>
<p>Spring AOP 中的动态代理主要有两种方式，</p>
<ul>
<li><p>JDK 动态代理</p>
<p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p>
</li>
<li><p>CGLIB 动态代理</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong>使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。</p>
</li>
</ul>
<h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h3><ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h3 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h3><p>Weaving ，<strong>编织</strong>。</p>
<ul>
<li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li>
<li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg" alt="Proxy"></p>
<h3 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h3><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<ul>
<li>基于 <strong>XML</strong> 方式的切面实现。</li>
<li>基于 <strong>注解</strong> 方式的切面实现。</li>
</ul>
<p>目前，主流喜欢使用 <strong>注解</strong> 方式。胖友可以看看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a> 。</p>
<h2 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h2><p>非常推荐阅读如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd">《可能是最漂亮的 Spring 事务管理详解》</a></li>
</ul>
<h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h3 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h3><p>指的是 <strong>ACID</strong> ，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/06.png" alt="事务的特性"></p>
<ol>
<li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h3><p>目前 Spring 提供两种类型的事务管理：</p>
<ul>
<li><strong>声明式</strong>事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li><strong>编程式</strong>事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<p>实际场景下，我们一般使用 Spring Boot + 注解的<strong>声明式</strong>事务。具体的示例，胖友可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cddeca2c9245">《Spring Boot 事务注解详解》</a> 。</p>
<p>另外，也推荐看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/xktxoo/article/details/77919508">《Spring 事务管理 － 编程式事务、声明式事务》</a> 一文。</p>
<h3 id="Spring-事务如何和不同的数据持久层框架做集成？"><a href="#Spring-事务如何和不同的数据持久层框架做集成？" class="headerlink" title="Spring 事务如何和不同的数据持久层框架做集成？"></a>Spring 事务如何和不同的数据持久层框架做集成？</h3><p>① 首先，我们先明确下，这里数据持久层框架，指的是 Spring JDBC、Hibernate、Spring JPA、MyBatis 等等。</p>
<p>② 然后，Spring 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PlatformTransactionManager.java</span><br><span class="line"></span><br><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 </span><br><span class="line">    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据情况，提交事务</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据情况，回滚事务</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。</p>
</li>
<li><p>#getTransaction(TransactionDefinition definition)方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。</p>
<ul>
<li>为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。</li>
<li>为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。😈 下面，也会详细解析 TransactionStatus 。</li>
<li>事务 TransactionDefinition 是什么？😈 下面，也会详细解析 TransactionStatus 。</li>
</ul>
</li>
<li><p>#commit(TransactionStatus status)方法，根据 TransactionStatus 情况，提交事务。</p>
<ul>
<li><p>为什么根据 TransactionStatus 情况，进行提交？例如说，带@Transactional注解的的 A 方法，会调用</p>
<p> @Transactional注解的的 B 方法。</p>
<ul>
<li>在 B 方法结束调用后，会执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，此处事务<strong>是不能</strong>、<strong>也不会</strong>提交的。</li>
<li>而是在 A 方法结束调用后，执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，提交事务。</li>
</ul>
</li>
</ul>
</li>
<li><p>#rollback(TransactionStatus status)方法，根据 TransactionStatus 情况，回滚事务。</p>
<ul>
<li>为什么根据 TransactionStatus 情况，进行回滚？原因同 <code>#commit(TransactionStatus status)</code> 方法。</li>
</ul>
</li>
</ul>
<p>③ 再之后，PlatformTransactionManager 有<strong>抽象子</strong>类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 <a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/54910518">模板方法模式</a> ，实现事务整体逻辑的骨架，而抽象 <code>#doCommit(DefaultTransactionStatus status)</code>、<code>#doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现。</p>
<blockquote>
<p>前方高能，即将进入关键的 ④ 步骤。</p>
</blockquote>
<p>④ 最后，不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/07.png" alt="事务的特性"></p>
<ul>
<li>所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。</li>
<li>HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。</li>
<li>DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。</li>
<li>JpaTransactionManager ，和 JPA 的事务管理做集成。</li>
</ul>
<p>如下，是一个比较常见的 XML 方式来配置的事务管理器，使用的是 DataSourceTransactionManager 。</p>
<p>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>正如上文所说，它适用于 MyBatis、Spring JDBC 等等。</li>
</ul>
<hr>
<p>😈 是不是很有趣，更多详细的解析，可见如下几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码分析 —— Transaction 源码简单导读》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/transaction-package/">《精尽 MyBatis 源码分析 —— 事务模块》</a></li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/Spring-Integration-4/">《精尽 MyBatis 源码解析 —— Spring 集成（四）之事务》</a></li>
</ul>
<h3 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h3><p>做过 Spring 多数据源的胖友，都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p>
<p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p>
<p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p>
<h3 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h3><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">String</td>
<td align="left">可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td align="left">propagation</td>
<td align="left">enum: Propagation</td>
<td align="left">可选的事务传播行为设置</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">enum: Isolation</td>
<td align="left">可选的事务隔离级别设置</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td align="left">boolean</td>
<td align="left">读写或只读事务，默认读写</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">int (in seconds granularity)</td>
<td align="left">事务超时时间设置</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td align="left">Class对象数组，必须继承自Throwable</td>
<td align="left">导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">rollbackForClassName</td>
<td align="left">类名数组，必须继承自Throwable</td>
<td align="left">导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td align="left">noRollbackFor</td>
<td align="left">Class对象数组，必须继承自Throwable</td>
<td align="left">不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td align="left">noRollbackForClassName</td>
<td align="left">类名数组，必须继承自Throwable</td>
<td align="left">不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<ul>
<li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li>
</ul>
<p>具体<strong>用法</strong>如下：</p>
<ul>
<li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
<li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。</li>
</ul>
<hr>
<p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p>
<p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 事务的隔离级别</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>; <span class="comment">// 事务的超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 事务的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能会胖友有以后，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li>
<li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li>
<li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li>
</ul>
<h3 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h3><p>关于这个问题，涉及的内容会比较多，胖友直接看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25419593">《数据库四大特性以及事务隔离级别》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4e3edbedb9a8">《五分钟搞清楚 MySQL 事务隔离级别》</a></li>
</ul>
<p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p>
<p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【Spring 独有】使用后端数据库默认的隔离级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MySQL 默认采用的 REPEATABLE_READ隔离级别</span></span><br><span class="line"><span class="comment"> * Oracle 默认采用的 READ_COMMITTED隔离级别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;</span><br></pre></td></tr></table></figure>



<h3 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h3><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p>
<ul>
<li>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</li>
<li>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</li>
</ul>
<p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 不支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的事务。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 其他情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则等价于 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_REQUIRED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p>
</li>
<li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而</p>
<p> PROPAGATION_NESTED是 Spring 所特有的。</p>
<ul>
<li>以 <code>PROPAGATION_NESTED</code> 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li>
<li>当然，虽然上面 <code>PROPAGATION_NESTED</code> 文字很长，实际我们基本没用过。或者说，去掉基本，我们根本没用过。</li>
</ul>
</li>
</ul>
<h3 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p>
<p>当然，这个属性，貌似我们基本也没用过。</p>
<h3 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p>
<ul>
<li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li>
<li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/uniquejava/blog/80954">《不使用事务和使用只读事务的区别 》</a> 。</li>
</ul>
<p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p>
<h3 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h3><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p>
<ul>
<li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。</li>
<li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li>
</ul>
<p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p>
<h3 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h3><blockquote>
<p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p>
</blockquote>
<p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionStatus.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是新创建的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有 Savepoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 flush 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否事务已经完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li>
<li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？答案结合 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Spring/Interview/#">「Spring 事务如何和不同的数据持久层框架做集成？」</a> 问题，我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li>
</ul>
<h3 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h3><ol>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ol>
<p>从倾向上来说，艿艿比较喜欢<strong>注解</strong> + 声明式事务。</p>
<h2 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h2><h3 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h3><ul>
<li>Hibernate</li>
<li>JPA</li>
<li>MyBatis</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html">JDO</a></li>
<li><a target="_blank" rel="noopener" href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html">OJB</a></li>
</ul>
<p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p>
<h3 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h3><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p>
<p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>没有使用过的胖友，可以看看 <a target="_blank" rel="noopener" href="https://www.tianmaying.com/tutorial/spring-jdbc-data-accessing">《Spring JDBC 访问关系型数据库》</a> 文章。</p>
<h3 id="Spring-数据数据访问层有哪些异常？"><a href="#Spring-数据数据访问层有哪些异常？" class="headerlink" title="Spring 数据数据访问层有哪些异常？"></a>Spring 数据数据访问层有哪些异常？</h3><p>通过使用 Spring 数据数据访问层，它统一了各个数据持久层框架的不同异常，统一进行提供 <code>org.springframework.dao.DataAccessException</code> 异常及其子类。如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/Spring/2018-12-24/09.jpg" alt="流程图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-04 11:08:09" itemprop="dateCreated datePublished" datetime="2020-08-04T11:08:09+08:00">2020-08-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/03/Java%E3%80%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/03/Java%E3%80%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【虚拟机】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-03T00:00:00+08:00">2020-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 17:39:03" itemprop="dateModified" datetime="2020-08-05T17:39:03+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="走近-Java"><a href="#走近-Java" class="headerlink" title="走近 Java"></a>走近 Java</h1><h2 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h2><p>Java 虚拟机，是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。</p>
<p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<p>但是，跨平台的是 Java 程序(包括字节码文件)，，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 。</p>
<p><a target="_blank" rel="noopener" href="http://static2.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301"><img src="http://static2.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301" alt="不同平台，不同 JVM"></a>不同平台，不同 JVM</p>
<p>也就是说，JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h2 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h2><p>JVM 的结构基本上由 4 部分组成：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/01.jpg" alt="img"></p>
<ul>
<li><p><strong>类加载器</strong>，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中。</p>
</li>
<li><p><strong>内存区</strong>，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等。</p>
<blockquote>
<p>关于这一块，我们在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「Java 内存区域与内存溢出异常」</a> 也会细看。</p>
</blockquote>
</li>
<li><p><strong>执行引擎</strong>，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU 。</p>
</li>
<li><p><strong>本地方法调用</strong>，调用 C 或 C++ 实现的本地方法的代码返回结果。</p>
</li>
</ul>
<h2 id="怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h2><p>Sun 有一个 Java System 属性来确定JVM的位数：32 或 64。</p>
<ul>
<li><code>sun.arch.data.model=32 // 32 bit JVM</code></li>
<li><code>sun.arch.data.model=64 // 64 bit JVM</code></li>
</ul>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(&quot;sun.arch.data.model&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h3><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB ，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。</p>
<p>64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64 ，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB 。甚至有的 JVM，如 Azul ，堆内存到 1000G 都是可能的。</p>
<h3 id="64-位-JVM-中，int-的长度是多数？"><a href="#64-位-JVM-中，int-的长度是多数？" class="headerlink" title="64 位 JVM 中，int 的长度是多数？"></a>64 位 JVM 中，int 的长度是多数？</h3><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h1 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h1><h2 id="JVM-运行内存的分类？"><a href="#JVM-运行内存的分类？" class="headerlink" title="JVM 运行内存的分类？"></a>JVM 运行内存的分类？</h2><p>JVM 运行内存的分类如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/02.png" alt="img"></p>
<ul>
<li><strong>程序计数器</strong>： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
</li>
<li><strong>虚拟机栈（栈内存）</strong>：Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
</li>
<li><strong>本地方法栈</strong> ：和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</li>
<li><strong>堆内存</strong>（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 <code>8:1:1</code> 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
</li>
<li><strong>方法区</strong>（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
</ul>
<h3 id="直接内存是不是虚拟机运行时数据区的一部分？"><a href="#直接内存是不是虚拟机运行时数据区的一部分？" class="headerlink" title="直接内存是不是虚拟机运行时数据区的一部分？"></a>直接内存是不是虚拟机运行时数据区的一部分？</h3><p>参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/leaf_0303/article/details/78961936">《JVM 直接内存》</a> 文章。</p>
<p>直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<ul>
<li>本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。</li>
<li>配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。</li>
</ul>
<h3 id="直接内存（堆外内存）与堆内存比较？"><a href="#直接内存（堆外内存）与堆内存比较？" class="headerlink" title="直接内存（堆外内存）与堆内存比较？"></a>直接内存（堆外内存）与堆内存比较？</h3><ol>
<li>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。</li>
<li>直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</li>
</ol>
<h3 id="实际上，后续的版本，主要对【方法区】做了一定的调整"><a href="#实际上，后续的版本，主要对【方法区】做了一定的调整" class="headerlink" title="实际上，后续的版本，主要对【方法区】做了一定的调整"></a>实际上，后续的版本，主要对【方法区】做了一定的调整</h3><ul>
<li><p>JDK7 的改变</p>
<ul>
<li>存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。但永久代仍存在于 JDK7 中，但是并没完全移除。</li>
<li>常量池和静态变量放到 Java 堆里。</li>
</ul>
</li>
<li><p>JDK8 的改变</p>
<ul>
<li><p>废弃 PermGen（永久代），新增 Metaspace（元数据区）。</p>
</li>
<li><p>那么方法区还在么？FROM 狼哥 的解答：方法区在 Metaspace 中了，方法区都是一个概念的东西。😈 狼哥通过撸源码获得该信息。</p>
<blockquote>
<p>因为，《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。</p>
<p>同时，大多数用的 JVM 都是 Sun 公司的 HotSpot 。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久带来实现方法区。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="JDK8-之后-Perm-Space-有哪些变动-MetaSpace-⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩"><a href="#JDK8-之后-Perm-Space-有哪些变动-MetaSpace-⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩" class="headerlink" title="JDK8 之后 Perm Space 有哪些变动? MetaSpace ⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?"></a>JDK8 之后 Perm Space 有哪些变动? MetaSpace ⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</h3><ul>
<li>JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。</li>
<li>MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</li>
<li>可以通过 JVM 参数配置<ul>
<li><code>-XX:MetaspaceSize</code> ： 分配给类元数据空间（以字节计）的初始大小（Oracle 逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize 的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><code>-XX:MaxMetaspaceSize</code> ：分配给类元数据空间的最大值，超过此值就会触发Full GC 。此值默认没有限制，但应取决于系统内存的大小，JVM 会动态地改变此值。</li>
</ul>
</li>
</ul>
<h3 id="为什么要废弃永久代？"><a href="#为什么要废弃永久代？" class="headerlink" title="为什么要废弃永久代？"></a>为什么要废弃永久代？</h3><p>1）现实使用中易出问题。</p>
<p>由于永久代内存经常不够用或发生内存泄露，爆出异常 <code>java.lang.OutOfMemoryError: PermGen</code> 。</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
</ul>
<p>2）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>3）Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
<p>即：移除永久代是为融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，不需要配置永久代。</p>
<h2 id="Java-内存堆和栈区别？"><a href="#Java-内存堆和栈区别？" class="headerlink" title="Java 内存堆和栈区别？"></a>Java 内存堆和栈区别？</h2><ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 <code>java.lang.StackOverFlowError</code> 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 <code>java.lang.OutOfMemoryError</code> 错误。</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。<code>-Xss</code> 选项设置栈内存的大小，<code>-Xms</code> 选项可以设置堆的开始时的大小。</li>
</ul>
<p>当然，如果你记不住这个些，只要记住如下即可：</p>
<blockquote>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
</blockquote>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/03.png" alt="img"></p>
<h2 id="Java-对象创建的过程？"><a href="#Java-对象创建的过程？" class="headerlink" title="Java 对象创建的过程？"></a>Java 对象创建的过程？</h2><p>JAVA 对象创建的过程，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/06.png" alt="JAVA 对象创建的过程"></p>
<ul>
<li>Java 中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于 new 关键字创建的普通 Java 对象，不包括数组对象的创建。</li>
</ul>
<p>1）检测类是否被加载</p>
<p>当虚拟机遇到 <code>new</code> 指令时，首先先去检查这个指令的参数是否能在常量池中<strong>定位到一个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程。</p>
<p>2）为对象分配内存</p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为“<strong>指针碰撞</strong>”。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为“<strong>空闲列表</strong>”。</li>
</ul>
<p>多线程并发时会出现正在给对象 A 分配内存，还没来得及修改指针，对象 B 又用这个指针<strong>分配内存</strong>，这样就出现问题了。解决这种问题有两种方案：</p>
<ul>
<li>第一种，是采用同步的办法，使用 CAS 来保证操作的原子性。</li>
<li>另一种，是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），分配内存的时候再TLAB上分配，互不干扰。可以通过 <code>-XX:+/-UseTLAB</code> 参数决定。</li>
</ul>
<p>3）为分配的内存空间初始化零值</p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p>4）对对象进行其他设置</p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。</p>
<p>5）执行 init 方法</p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了 init 方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是 new 关键字创建对象的过程。过程如下：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/07.png" alt="JAVA 对象创建的过程"></p>
<blockquote>
<p>另外，这个问题，面试官可能引申成 “<code>A a = new A()</code> 经历过什么过程”的问题。</p>
</blockquote>
<h2 id="对象的内存布局是怎样的？"><a href="#对象的内存布局是怎样的？" class="headerlink" title="对象的内存布局是怎样的？"></a>对象的内存布局是怎样的？</h2><p>对象的内存布局包括三个部分：</p>
<ul>
<li>对象头：对象头包括两部分信息。<ul>
<li>第一部分，是存储对象自身的运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁等等。</li>
<li>第二部分，是类型指针，即对象指向类元数据的指针。</li>
</ul>
</li>
<li>实例数据：就是数据。</li>
<li>对齐填充：不是必然的存在，就是为了对齐。</li>
</ul>
<h2 id="对象是如何定位访问的？"><a href="#对象是如何定位访问的？" class="headerlink" title="对象是如何定位访问的？"></a>对象是如何定位访问的？</h2><p>对象的访问定位有两种：</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/04.png" alt="句柄定位"></p>
<ul>
<li>直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li>
</ul>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/05.png" alt="直接指针访问"></p>
<h3 id="对比两种方式？"><a href="#对比两种方式？" class="headerlink" title="对比两种方式？"></a>对比两种方式？</h3><p>这两种对象访问方式各有优势。</p>
<ul>
<li>使用句柄来访问的最大好处，就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</li>
</ul>
<p>我们目前主要虚拟机 Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h2 id="有哪些-OutOfMemoryError-异常？"><a href="#有哪些-OutOfMemoryError-异常？" class="headerlink" title="有哪些 OutOfMemoryError 异常？"></a>有哪些 OutOfMemoryError 异常？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.4 实战：OutOfMemoryError 异常」</a> 。</p>
</blockquote>
<p>在 Java 虚拟机中规范的描述中，除了程序计数器外，虚拟机内存的其它几个运行时区域都有发生的 OutOfMemoryError(简称为“OOM”) 异常的可能。</p>
<ul>
<li><p>Java 堆溢出</p>
</li>
<li><p>虚拟机栈和本地方法栈溢出</p>
</li>
<li><p>方法区和运行时常量池溢出</p>
<blockquote>
<p>从 JDK8 开始，就变成元数据区的内存溢出。</p>
</blockquote>
</li>
<li><p>本机直接内存溢出</p>
</li>
</ul>
<p><strong>1）Java 堆溢出</strong></p>
<p>重现方式，参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/sells2012/article/details/18654915">《Java 堆溢出》</a> 文章。</p>
<p>另外，Java 堆溢出的原因，有可能是内存泄露，可以使用 MAT 进行分析。</p>
<p><strong>2）虚拟机栈和本地方法栈溢出</strong></p>
<p>由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 <code>-Xoss</code> 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 <code>-Xss</code>参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常：</p>
<ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p>
<blockquote>
<p>StackOverflowError 不属于 OOM 异常哈。</p>
</blockquote>
</li>
<li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</p>
</li>
</ul>
<p>重现方式，参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/en_joker/article/details/79727675">《OutOfMemoryError 异常 —— 虚拟机栈和本地方法栈溢出》</a> 文章。</p>
<p><strong>3）运行时常量池溢出</strong></p>
<p>因为 JDK7 将常量池和静态变量放到 Java 堆里，所以无法触发运行时常量池溢出。如果想要触发，可以使用 JDK6 的版本。</p>
<p>重现方式，参见 <a target="_blank" rel="noopener" href="https://www.niuhp.com/java/jvm-oom-pg.html">《JVM 内存溢出 - 方法区及运行时常量池溢出》</a> 文章。</p>
<p><strong>4）方法区的内存溢出</strong></p>
<p>因为 JDK8 将方法区溢出，所以无法触发方法区的内存溢出溢出。如果想要触发，可以使用 JDK7 的版本。</p>
<p>重现方式，参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章。</p>
<p><strong>5）元数据区的内存溢出</strong></p>
<p>实际上，方法区的内存溢出在 JDK8 中，变成了元数据区的内存溢出。所以，重现方式，还是参见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章，只是说，需要增加 <code>-XX:MaxMetaspaceSize=10m</code> VM 配置项。</p>
<p><strong>6）本机直接内存溢出</strong></p>
<p>重现方式，参见 <a target="_blank" rel="noopener" href="https://www.niuhp.com/java/jvm-oom-direct.html">《JVM 内存溢出 —— 直接内存溢出》</a> 文章。</p>
<hr>
<p>另外，非常推荐一篇文章，胖友耐心阅读，提供了更多有趣的案例，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2fdee831ed03">《Java 内存溢出(OOM)异常完全指南》</a> 。</p>
<p>🦅 <strong>当出现了内存溢出，你怎么排错？</strong></p>
<ul>
<li>1、首先，控制台查看错误日志。</li>
<li>2、然后，使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。</li>
<li>3、定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。<ul>
<li>如果是堆内存溢出，看是否创建了超大的对象。</li>
<li>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。</li>
</ul>
</li>
</ul>
<h2 id="Java-中会存在内存泄漏吗？"><a href="#Java-中会存在内存泄漏吗？" class="headerlink" title="Java 中会存在内存泄漏吗？"></a>Java 中会存在内存泄漏吗？</h2><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收也会发生内存泄露。例如说：</p>
<ul>
<li>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。</li>
<li>使用 Netty 的堆外的 ByteBuf 对象，在使用完后，并未归还，导致使用的一点一点在泄露。</li>
</ul>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="什么是垃圾回收机制？"><a href="#什么是垃圾回收机制？" class="headerlink" title="什么是垃圾回收机制？"></a>什么是垃圾回收机制？</h2><ul>
<li>ava 中对象是采用 <code>new</code> 或者反射的方法创建的，这些对象的创建都是在堆(Heap)中分配的，所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成的。GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。</li>
<li>Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。</li>
<li>可以调用下面的方法之一：<code>System#gc()</code> 或 <code>Runtime#getRuntime()#gc()</code> ，但 JVM 也可以屏蔽掉显示的垃圾回收调用。</li>
</ul>
<h3 id="为什么不建议在程序中显式的声明-System-gc-？"><a href="#为什么不建议在程序中显式的声明-System-gc-？" class="headerlink" title="为什么不建议在程序中显式的声明 System.gc() ？"></a>为什么不建议在程序中显式的声明 <code>System.gc()</code> ？</h3><p>因为显式声明是做堆内存全扫描，也就是 Full GC ，是需要停止所有的活动的(Stop The World Collection)，对应用很大可能存在影响。</p>
<p>另外，调用 <code>System.gc()</code> 方法后，不会立即执行 Full GC ，而是虚拟机自己决定的。</p>
<h3 id="如果一个对象的引用被设置为-null-GC-会立即释放该对象的内存么"><a href="#如果一个对象的引用被设置为-null-GC-会立即释放该对象的内存么" class="headerlink" title="如果一个对象的引用被设置为 null , GC 会立即释放该对象的内存么?"></a>如果一个对象的引用被设置为 <code>null</code> , GC 会立即释放该对象的内存么?</h3><p>不会, 这个对象将会在下一次 GC 循环中被回收。</p>
<h3 id="finalize-方法什么时候被调用？它的目的是什么？"><a href="#finalize-方法什么时候被调用？它的目的是什么？" class="headerlink" title="#finalize() 方法什么时候被调用？它的目的是什么？"></a>#finalize() 方法什么时候被调用？它的目的是什么？</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2.4 生存还是死亡」</a> 。</p>
</blockquote>
<p><code>#finallize()</code> 方法，是在释放该对象内存前由 GC (垃圾回收器)调用。</p>
<ul>
<li>通常建议在这个方法中释放该对象持有的资源，例如持有的堆外内存、和远程服务的长连接。</li>
<li>一般情况下，不建议重写该方法。</li>
<li>对于一个对象，该方法有且仅会被调用一次。</li>
</ul>
<h2 id="如何判断一个对象是否已经死去？"><a href="#如何判断一个对象是否已经死去？" class="headerlink" title="如何判断一个对象是否已经死去？"></a>如何判断一个对象是否已经死去？</h2><p>有两种方式：</p>
<ol>
<li>引用计数</li>
<li>可达性分析</li>
</ol>
<p><strong>1）引用计数</strong></p>
<p>每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。目前在用的有 Python、ActionScript3 等语言。</p>
<p><strong>2）可达性分析（Reachability Analysis）</strong></p>
<p>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。目前在用的有 Java、C# 等语言。</p>
<h3 id="如果-A-和-B-对象循环引用，是否可以被-GC？"><a href="#如果-A-和-B-对象循环引用，是否可以被-GC？" class="headerlink" title="如果 A 和 B 对象循环引用，是否可以被 GC？"></a>如果 A 和 B 对象循环引用，是否可以被 GC？</h3><p>可以，因为 Java 采用可达性分析的判断方式。</p>
<h3 id="在-Java-语言里，可作为-GC-Roots-的对象包括以下几种？"><a href="#在-Java-语言里，可作为-GC-Roots-的对象包括以下几种？" class="headerlink" title="在 Java 语言里，可作为 GC Roots 的对象包括以下几种？"></a>在 Java 语言里，可作为 GC Roots 的对象包括以下几种？</h3><ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)中引用的对象。</li>
</ol>
<h3 id="方法区是否能被回收？"><a href="#方法区是否能被回收？" class="headerlink" title="方法区是否能被回收？"></a>方法区是否能被回收？</h3><p>方法区可以被回收，但是价值很低，主要回收废弃的常量和无用的类。</p>
<p>如何判断无用的类，需要完全满足如下三个条件：</p>
<ol>
<li>该类所有实例都被回收（Java 堆中没有该类的对象）。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。</li>
</ol>
<h2 id="Java-对象有哪些引用类型？"><a href="#Java-对象有哪些引用类型？" class="headerlink" title="Java 对象有哪些引用类型？"></a>Java 对象有哪些引用类型？</h2><p>Java 一共有四种引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用（SoftReference）</li>
<li>弱引用（WeakReference）</li>
<li>虚引用（PhantomReference）</li>
</ul>
<p><strong>1）强引用</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<blockquote>
<p>艿艿：不然，代码都没法写了 😈</p>
</blockquote>
<p><strong>2）软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>使用示例，见 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/cache-package/">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.10 SoftCache」</a> 小节。</p>
<p><strong>3）弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>使用示例，见</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/MyBatis/cache-package/">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.9 WeakCache」</a> 小节。</li>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4. ResourceLeakDetector」</a> 小节。</li>
</ul>
<p><strong>4）虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<hr>
<p>如果胖友想看看各种引用在 GC 下的效果，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/Fight/Four-reference-types-in-Java/?vip">《Java 中的四种引用类型》</a> 提供的代码示例。</p>
<h3 id="WeakReference-与-SoftReference的区别？"><a href="#WeakReference-与-SoftReference的区别？" class="headerlink" title="WeakReference 与 SoftReference的区别？"></a>WeakReference 与 SoftReference的区别？</h3><p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率。</p>
<ul>
<li>但是 WeakReference 一旦失去最后一个强引用，就会被 GC 回收</li>
<li>而 SoftReference 虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</li>
</ul>
<h3 id="为什么要有不同的引用类型？"><a href="#为什么要有不同的引用类型？" class="headerlink" title="为什么要有不同的引用类型？"></a>为什么要有不同的引用类型？</h3><p>不像 C 语言，我们可以控制内存的申请和释放，在 Java 中有时候我们需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对 GC 回收时机不可控的妥协。有以下几个使用场景可以充分的说明：</p>
<ul>
<li>利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题.</li>
<li>通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person 的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person 对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能。</li>
</ul>
<h2 id="JVM-垃圾回收算法？"><a href="#JVM-垃圾回收算法？" class="headerlink" title="JVM 垃圾回收算法？"></a>JVM 垃圾回收算法？</h2><p>有四种算法：</p>
<ol>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ol>
<p><strong>1）标记-清除算法</strong></p>
<p>标记-清除（Mark-Sweep）算法，是现代垃圾回收算法的思想基础。</p>
<p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</p>
<p>一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。</p>
<p><img src="http://static2.iocoder.cn/f07ac7c68994aa21b7b4271073ea4e5b" alt="标记-清除算法"></p>
<ul>
<li>缺点：<ul>
<li>1、效率问题，标记和清除两个过程的效率都不高。</li>
<li>2、空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
</ul>
<p><strong>2）标记-整理算法</strong></p>
<p>标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="http://static2.iocoder.cn/52ea9a3813e09621c563b1cd4bdf0d22" alt="标记-整理算法"></p>
<ul>
<li>优点：<ul>
<li>1、相对标记清除算法，解决了内存碎片问题。</li>
<li>2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。</li>
</ul>
</li>
</ul>
<p><strong>3）复制算法</strong></p>
<p>复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。</p>
<p><img src="http://static2.iocoder.cn/cc3f228ca5353fd5deb4b22b7a9709e6" alt="复制算法"></p>
<ul>
<li>的上半部分是未回收前的内存区域，图的下半部分是回收后的内存区域。通过图，我们发现不管回收前还是回收后都有一半的空间未被利用。</li>
<li>优点：<ul>
<li>1、效率高，没有内存碎片。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、浪费一半的内存空间。</li>
<li>2、复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ul>
</li>
</ul>
<p><strong>4）分代收集算法</strong></p>
<p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。</li>
<li>而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</li>
</ul>
<p><img src="http://static2.iocoder.cn/fec52af474f1250831d46b541e0fe7a9" alt="分代收集算法"></p>
<ul>
<li>图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。</li>
<li>对象分配策略：<ul>
<li>对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。</li>
<li>长时间存活的对象进入到 Old 区域。</li>
</ul>
</li>
<li>改进自复制算法<ul>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 <code>1:1</code> 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</li>
<li>HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 <code>8:1:1</code>，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
</ul>
</li>
</ul>
<h2 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h2><p>SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s representation of it’s Java machine state is well described)，比如记录OopMap 的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。</p>
<p>SafePoint 指的特定位置主要有：</p>
<ol>
<li>循环的末尾 (防止大循环的时候一直不进入 Safepoint ，而其他线程在等待它进入 Safepoint )。</li>
<li>方法返回前。</li>
<li>调用方法的 Call 之后。</li>
<li>抛出异常的位置。</li>
</ol>
<p>详细的内容，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/wenbo123/blog/1822414">《深入学习 JVM-JVM 安全点和安全区域》</a> 。</p>
<ul>
<li><p>如何使线程中断</p>
<ul>
<li><p>主动式</p>
<blockquote>
<p>主动式 JVM 设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是 SafePoint 就主动挂起。</p>
<p>HostSpot 虚拟机采用的是主动式使线程中断。</p>
</blockquote>
</li>
<li><p>被动式</p>
<blockquote>
<p>被动式就是发个信号，例如关机、Control+C ，带来的问题就是不可控，发信号的时候不知道线程处于什么状态。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>安全区域</p>
<blockquote>
<p>如果程序长时间不执行，比如线程调用的 sleep 方法，这时候程序无法响应 JVM 中断请求这时候线程无法到达安全点，显然 JVM 也不可能等待程序唤醒，这时候就需要安全区域了。</p>
<p>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方 GC 都是安全的，安全区域可以看做是安全点的一个扩展。</p>
<ul>
<li>线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样 GC 时就不用管进入安全区域的线程了.</li>
<li>线程要离开安全区域时就检查 JVM 是否完成了 GC Roots 枚举（或者整个 GC 过程），如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="JVM-垃圾收集器有哪些？"><a href="#JVM-垃圾收集器有哪些？" class="headerlink" title="JVM 垃圾收集器有哪些？"></a>JVM 垃圾收集器有哪些？</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<ul>
<li><p>新生代收集器</p>
<ul>
<li><p>Serial 收集器</p>
</li>
<li><p>ParNew 收集器</p>
<blockquote>
<p>ParNew 收集器，是 Serial 收集器的多线程版。</p>
</blockquote>
</li>
<li><p>Parallel Scavenge 收集器</p>
</li>
</ul>
</li>
<li><p>老年代收集器</p>
<ul>
<li>Serial Old 收集器<ul>
<li>Serial Old 收集器，是 Serial 收集器的老年代版本。</li>
</ul>
</li>
<li>Parallel Old 收集器<ul>
<li>Parallel Old 收集器，是 Parallel Scavenge 收集器的老年代版本。</li>
</ul>
</li>
<li>CMS 收集器</li>
</ul>
</li>
<li><p>新生代 + 老年代收集器</p>
<ul>
<li>G1 收集器</li>
<li>ZGC 收集器</li>
</ul>
</li>
</ul>
<p>小结表格如下：</p>
<table>
<thead>
<tr>
<th align="left">收集器</th>
<th align="left">串行、并行or并发</th>
<th align="left">新生代/老年代</th>
<th align="left">算法</th>
<th align="left">目标</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Serial</strong></td>
<td align="left">串行</td>
<td align="left">新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">单CPU环境下的Client模式</td>
</tr>
<tr>
<td align="left"><strong>Serial Old</strong></td>
<td align="left">串行</td>
<td align="left">老年代</td>
<td align="left">标记-整理</td>
<td align="left">响应速度优先</td>
<td align="left">单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td align="left"><strong>ParNew</strong></td>
<td align="left">并行</td>
<td align="left">新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td align="left"><strong>Parallel Scavenge</strong></td>
<td align="left">并行</td>
<td align="left">新生代</td>
<td align="left">复制算法</td>
<td align="left">吞吐量优先</td>
<td align="left">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="left"><strong>Parallel Old</strong></td>
<td align="left">并行</td>
<td align="left">老年代</td>
<td align="left">标记-整理</td>
<td align="left">吞吐量优先</td>
<td align="left">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="left"><strong>CMS</strong></td>
<td align="left">并发</td>
<td align="left">老年代</td>
<td align="left">标记-清除</td>
<td align="left">响应速度优先</td>
<td align="left">集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td align="left"><strong>G1</strong></td>
<td align="left">并发</td>
<td align="left">both</td>
<td align="left">标记-整理+复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<p>关于每种垃圾收集器的说明，请看 如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://crowhawk.github.io/2017/08/15/jvm_3/">《深入理解 JVM(3) —— 7 种垃圾收集器》</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43608166">《一文读懂 Java 11 的 ZGC 为何如此高效》</a></li>
</ul>
<h3 id="G1-和-CMS-的区别？"><a href="#G1-和-CMS-的区别？" class="headerlink" title="G1 和 CMS 的区别？"></a>G1 和 CMS 的区别？</h3><ul>
<li><p>CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。</p>
</li>
<li><p>G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）</p>
</li>
<li><p>CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求。</p>
</li>
<li><p>CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。</p>
</li>
<li><p>G1 和 CMS 都是响应优先把，他们的目的都是尽量控制 STW 时间。</p>
<blockquote>
<p>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化为并行的。</p>
</blockquote>
</li>
</ul>
<p>感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="http://engineering.xueqiu.com/blog/2015/06/25/jvm-gc-tuning/">《GC 优化的一些总结》</a> 的分析。</p>
<h3 id="CMS-算法的过程，CMS-回收过程中-JVM-是否需要暂停？"><a href="#CMS-算法的过程，CMS-回收过程中-JVM-是否需要暂停？" class="headerlink" title="CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？"></a>CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？</h3><p>会有短暂的停顿。详细的，可以看看 [《<a target="_blank" rel="noopener" href="https://blog.csdn.net/wfh6732/article/details/57490195">jvm][面试] 并发收集器 CMS(Concurrent Mark-Sweep)》</a> 。</p>
<h3 id="如何使用指定的垃圾收集器？"><a href="#如何使用指定的垃圾收集器？" class="headerlink" title="如何使用指定的垃圾收集器？"></a>如何使用指定的垃圾收集器？</h3><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+UserSerialGC</td>
<td align="left">串行垃圾收集器</td>
</tr>
<tr>
<td align="left">-XX:+UserParrallelGC</td>
<td align="left">并行垃圾收集器</td>
</tr>
<tr>
<td align="left">-XX:+UseConcMarkSweepGC</td>
<td align="left">并发标记扫描垃圾回收器</td>
</tr>
<tr>
<td align="left">-XX:ParallelCMSThreads</td>
<td align="left">并发标记扫描垃圾回收器 =为使用的线程数量</td>
</tr>
<tr>
<td align="left">-XX:+UseG1GC</td>
<td align="left">G1垃圾回收器</td>
</tr>
</tbody></table>
<h2 id="对象分配规则是什么？"><a href="#对象分配规则是什么？" class="headerlink" title="对象分配规则是什么？"></a>对象分配规则是什么？</h2><ul>
<li><p>对象优先分配在 Eden 区。</p>
<blockquote>
<p>如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）</p>
<ul>
<li>如果 Survivor0 可以放入，那么放入之后清除 Eden 区。</li>
<li>如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。<ul>
<li>如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。</li>
<li>如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为<strong>分配担保</strong>。</li>
</ul>
</li>
</ul>
<p>ps：清除 Eden、Survivor 区，就是 Minor GC 。</p>
<p>总结来说，分配的顺序是：新生代（Eden =&gt; Survivor0 =&gt; Survivor1）=&gt; 老年代</p>
</blockquote>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</p>
<blockquote>
<p>这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</blockquote>
</li>
<li><p>长期存活的对象进入老年代。</p>
<blockquote>
<p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区。</p>
</blockquote>
</li>
<li><p>动态判断对象的年龄。</p>
<blockquote>
<p>为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。</p>
<p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</blockquote>
</li>
<li><p>空间分配担保。</p>
<blockquote>
<p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，如果小于检查 HandlePromotionFailure 设置，如果 <code>true</code> 则只进行 Monitor GC ，如果 <code>false</code> 则进行 Full GC 。</p>
</blockquote>
</li>
</ul>
<p><img src="http://static2.iocoder.cn/bc22a30cbe93b8dedda080144a73b613" alt="内存分配"></p>
<h3 id="为什么新生代内存需要有两个-Survivor-区？"><a href="#为什么新生代内存需要有两个-Survivor-区？" class="headerlink" title="为什么新生代内存需要有两个 Survivor 区？"></a>为什么新生代内存需要有两个 Survivor 区？</h3><p>详细的原因，可以看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/79802884">《为什么新生代内存需要有两个 Survivor 区》</a> 文章。</p>
<h2 id="什么是新生代-GC-和老年代-GC？"><a href="#什么是新生代-GC-和老年代-GC？" class="headerlink" title="什么是新生代 GC 和老年代 GC？"></a>什么是新生代 GC 和老年代 GC？</h2><p>GC 经常发生的区域是堆区，堆区还可以细分为</p>
<p><a target="_blank" rel="noopener" href="http://static2.iocoder.cn/67796f9fc657b7b4dd0054f561248f5b"><img src="http://static2.iocoder.cn/67796f9fc657b7b4dd0054f561248f5b" alt="堆"></a>堆</p>
<ul>
<li>新生代<ul>
<li>一个 Eden 区</li>
<li>两个 Survivor 区</li>
</ul>
</li>
<li>老年代</li>
</ul>
<blockquote>
<p>默认新生代(Young)与老年代(Old)的比例的值为 <code>1:2</code> (该值可以通过参数 <code>–XX:NewRatio</code> 来指定)。</p>
<p>默认的 <code>Eden:from:to=8:1:1</code> (可以通过参数 <code>–XX:SurvivorRatio</code> 来设定)。</p>
</blockquote>
<p><strong>新生代GC（MinorGC/YoungGC）</strong>：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。</p>
<p><strong>老年代GC（MajorGC/FullGC）</strong>：指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。</p>
<h3 id="什么情况下会出现-Young-GC？"><a href="#什么情况下会出现-Young-GC？" class="headerlink" title="什么情况下会出现 Young GC？"></a>什么情况下会出现 Young GC？</h3><p>对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。</p>
<h3 id="什么情况下回出现-Full-GC？"><a href="#什么情况下回出现-Full-GC？" class="headerlink" title="什么情况下回出现 Full GC？"></a>什么情况下回出现 Full GC？</h3><p>Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。</p>
<ul>
<li>1、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。</li>
<li>2、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。</li>
<li>3、显式调用 <code>System#gc()</code> 方法时。</li>
</ul>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="JDK-的命令行工具有哪些可以监控虚拟机？"><a href="#JDK-的命令行工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的命令行工具有哪些可以监控虚拟机？"></a>JDK 的命令行工具有哪些可以监控虚拟机？</h2><ul>
<li><p>jps ：虚拟机进程状况工具</p>
<blockquote>
<p>JVM Process Status Tool ，显示指定系统内所有的HotSpot虚拟机进程。</p>
</blockquote>
</li>
<li><p>jstat ：虚拟机统计信息监控工具</p>
<blockquote>
<p>JVM statistics Monitoring ，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
</blockquote>
</li>
<li><p>jinfo ：Java 配置信息工具</p>
<blockquote>
<p>JVM Configuration info ，这个命令作用是实时查看和调整虚拟机运行参数。</p>
</blockquote>
</li>
<li><p>jmap ：Java 内存映射工具</p>
<blockquote>
<p>JVM Memory Map ，命令用于生成 heap dump 文件。</p>
</blockquote>
</li>
<li><p>jhat ：虚拟机堆转储快照分析工具</p>
<blockquote>
<p>JVM Heap Analysis Tool ，命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型 的HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。</p>
</blockquote>
</li>
<li><p>jstack ：Java 堆栈跟踪工具</p>
<blockquote>
<p>Java Stack Trace ，用于生成 Java 虚拟机当前时刻的线程快照。</p>
</blockquote>
</li>
<li><p>HSDIS ：JIT 生成代码反编译</p>
</li>
</ul>
<h2 id="JDK-的可视化工具有哪些可以监控虚拟机？"><a href="#JDK-的可视化工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的可视化工具有哪些可以监控虚拟机？"></a>JDK 的可视化工具有哪些可以监控虚拟机？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4.3 JDK 的可视化工具」</a> 。</p>
</blockquote>
<ul>
<li><p>Java 自带</p>
<ul>
<li><p>JConsole ：Java 监视与管理控制台</p>
<blockquote>
<p>Java Monitoring and Management Console 是从 Java5 开始，在 JDK 中自带的 Java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控。</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a19881029/article/details/8432368/">VisualVM</a> ：多合一故障处理工具</p>
<blockquote>
<p>JDK 自带全能工具，可以分析内存快照、线程快照、监控内存变化、GC变化等。</p>
<p>特别是 BTrace 插件，动态跟踪分析工具。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第三方</p>
<ul>
<li><p>MAT ：内存分析工具</p>
<blockquote>
<p>Memory Analyzer Tool ，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
</blockquote>
</li>
<li><p>[GChisto](<a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/GC">http://svip.iocoder.cn/Java/VirtualMachine/Interview/GC</a> 日志分析工具 —— GChisto) ：一款专业分析 GC 日志的工具。</p>
</li>
</ul>
</li>
</ul>
<p>另外，一些开源项目，例如 <a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking">SkyWalking</a>、<a target="_blank" rel="noopener" href="https://github.com/dianping/cat">Cat</a> ，也提供了 JVM 监控的功能，更加适合生产环境，对 JVM 的监控。</p>
<h2 id="怎么获取-Java-程序使用的内存？"><a href="#怎么获取-Java-程序使用的内存？" class="headerlink" title="怎么获取 Java 程序使用的内存？"></a>怎么获取 Java 程序使用的内存？</h2><p>可以通过 <code>java.lang.Runtime</code> 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。</p>
<ul>
<li><code>Runtime#freeMemory()</code> 方法，返回剩余空间的字节数。</li>
<li><code>Runtime#totalMemory()</code> 方法，总内存的字节数。</li>
<li><code>Runtime#maxMemory()</code> 方法，返回最大内存的字节数。</li>
</ul>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="常见-GC-的优化配置？"><a href="#常见-GC-的优化配置？" class="headerlink" title="常见 GC 的优化配置？"></a>常见 GC 的优化配置？</h2><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Xms</td>
<td align="left">初始化堆内存大小</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">堆内存最大值</td>
</tr>
<tr>
<td align="left">-Xmn</td>
<td align="left">新生代大小</td>
</tr>
<tr>
<td align="left">-XX:PermSize</td>
<td align="left">初始化永久代大小</td>
</tr>
<tr>
<td align="left">-XX:MaxPermSize</td>
<td align="left">永久代最大容量</td>
</tr>
<tr>
<td align="left">-XX:SurvivorRatio</td>
<td align="left">设置年轻代中 Eden 区与 Survivor 区的比值</td>
</tr>
<tr>
<td align="left">-XX:Xmn</td>
<td align="left">设置年轻代大小</td>
</tr>
</tbody></table>
<p>另外，也可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaojw_420/article/details/70527138">《JVM 调优》</a> 文章。</p>
<h2 id="如何排查线程-Full-GC-频繁的问题？"><a href="#如何排查线程-Full-GC-频繁的问题？" class="headerlink" title="如何排查线程 Full GC 频繁的问题？"></a>如何排查线程 Full GC 频繁的问题？</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wilsonpeng3/article/details/70064336/">《线上 Full GC 频繁的排查》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenleixing/article/details/46706039/">《触发 JVM 进行 Full GC 的情况及应对策略》</a></li>
</ul>
<h3 id="JVM-的永久代中会发生垃圾回收么？"><a href="#JVM-的永久代中会发生垃圾回收么？" class="headerlink" title="JVM 的永久代中会发生垃圾回收么？"></a>JVM 的永久代中会发生垃圾回收么？</h3><ul>
<li><p><strong>Young GC</strong> 不会发生在永久代。</p>
</li>
<li><p>如果永久代满了或者是超过了临界值，会触发完全垃圾回收(<strong>Full GC</strong>)。如果我们仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。</p>
<blockquote>
<p>Java8 ：从永久代到元数据区 (注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)。</p>
</blockquote>
</li>
</ul>
<h2 id="有看过-GC-日志么？"><a href="#有看过-GC-日志么？" class="headerlink" title="有看过 GC 日志么？"></a>有看过 GC 日志么？</h2><blockquote>
<p>艿艿：这个问题，一般面试不会问，加进来，主要让胖友知道，有这么个知识点。</p>
</blockquote>
<p>参见文章如下：</p>
<ul>
<li>[《<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fd1d4f21733a">JVM]理解GC日志》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TimHeath/article/details/53053106">《GC 日志查看分析》</a></li>
</ul>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类加载器是有了解吗？"><a href="#类加载器是有了解吗？" class="headerlink" title="类加载器是有了解吗？"></a>类加载器是有了解吗？</h2><p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(<code>.java</code> 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(<code>.class</code> 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。</p>
<ul>
<li>每个这样的实例用来表示一个 Java 类。通过此实例的 <code>Class#newInstance(...)</code> 方法，就可以创建出该类的一个对象。</li>
<li>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</li>
</ul>
<h2 id="类加载发生的时机是什么时候？"><a href="#类加载发生的时机是什么时候？" class="headerlink" title="类加载发生的时机是什么时候？"></a>类加载发生的时机是什么时候？</h2><p>虚拟机严格规定，有且仅有 5 种情况必须对类进行加载：</p>
<blockquote>
<p>注意，有些文章会称为对类进行“初始化”。</p>
</blockquote>
<ul>
<li>1、遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>2、使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>3、当初始化了一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。</li>
<li>4、当虚拟机启动时，用户需要指定一个执行的主类，即调用其 <code>#main(String[] args)</code> 方法，虚拟机则会先初始化该主类。</li>
<li>5、当使用 JDK7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h2 id="类加载器是如何加载-Class-文件的？"><a href="#类加载器是如何加载-Class-文件的？" class="headerlink" title="类加载器是如何加载 Class 文件的？"></a>类加载器是如何加载 Class 文件的？</h2><p>下图所示是 ClassLoader 加载一个 <code>.class</code> 文件到 JVM 时需要经过的步骤：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/08.png" alt="类加载器是如何加载 class 文件"></p>
<ul>
<li><p>第一个阶段，加载(Loading)，是找到 <code>.class</code> 文件并把这个文件包含的字节码加载到内存中。</p>
</li>
<li><p>第二阶段，连接(Linking)，又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配、最后的符号表的解析。</p>
</li>
<li><p>第三阶段，Initialization(类中静态属性和初始化赋值)，以及Using(静态块的执行)等。</p>
<blockquote>
<p>注意，不包括卸载(Unloading)部分。</p>
</blockquote>
</li>
</ul>
<h3 id="1）加载"><a href="#1）加载" class="headerlink" title="1）加载"></a>1）加载</h3><blockquote>
<p>加载是“类加载”过程的第一阶段，胖友不要混淆这两个名字。</p>
</blockquote>
<p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code> 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="2）连接"><a href="#2）连接" class="headerlink" title="2）连接"></a>2）连接</h3><p><strong>2.1 验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类，除了 <code>java.lang.Object</code> 之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>2.2 准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段，是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li><p>1、这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
<blockquote>
<p>思考下，对于类本身，静态变量就是其属性。</p>
</blockquote>
</li>
<li><p>2、这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等），而不是被在 Java 代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为： <code>public static int value = 3</code>。那么静态变量 <code>value</code> 在准备阶段过后的初始值为 <code>0</code>，而不是 <code>3</code>。因为这时候尚未开始执行任何 Java 方法，而把 <code>value</code> 赋值为 <code>3</code> 的 <code>public static</code> 指令是在程序编译后，存放于<strong>类构造器</strong> <code>()</code> 方法之中的，所以把 <code>value</code> 赋值为 <code>3</code> 的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量(<code>static</code>)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被 <code>static</code> 和 <code>final</code> 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 <code>final</code> 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的空值，即 <code>null</code> 。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的“空”值。</li>
</ul>
</blockquote>
</li>
<li><p>3、如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量 <code>value</code> 就会被初始化为 ConstValue 属性所指定的值。</p>
<p>假设上面的类变量 <code>value</code> 被定义为： <code>public static final int value = 3</code> 。编译时， <code>javac</code> 将会为 <code>value</code> 生成 ConstantValue 属性。在准备阶段虚拟机就会根据 ConstantValue 的设置将 <code>value</code> 赋值为 3。我们可以理解为 <code>static final</code> 常量在编译期就将其结果放入了调用它的类的常量池中。</p>
</li>
</ul>
<p><strong>2.3 解析：把类中的符号引用转换为直接引用</strong></p>
<blockquote>
<p>这个步骤，艿艿看的也有点懵逼。</p>
<p>R 大在 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/50258991">《JVM 符号引用转换直接引用的过程?》</a> 和 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30300585">《JVM 里的符号引用如何存储？》</a> 做过解答，看的还是懵逼。</p>
</blockquote>
<p>解析阶段，是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<ul>
<li>符号引用，就是一组符号来描述目标，可以是任何字面量。</li>
<li>直接引用，就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<h3 id="3）初始化"><a href="#3）初始化" class="headerlink" title="3）初始化"></a>3）初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>1、声明类变量是指定初始值。</li>
<li>2、使用静态代码块为类变量指定初始值。</li>
</ul>
<p>JVM 初始化步骤：</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类。</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ul>
<h2 id="什么是双亲委派模型（Parent-Delegation-Model）？"><a href="#什么是双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="什么是双亲委派模型（Parent Delegation Model）？"></a>什么是双亲委派模型（Parent Delegation Model）？</h2><p>类加载器 ClassLoader 是具有层次结构的，也就是父子关系，如下图所示：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/09.png" alt="双亲委派模型"></p>
<ul>
<li><p>Bootstrap ClassLoader ：根类加载器，负责加载 Java 的核心类，它不是 <code>java.lang.ClassLoader</code> 的子类，而是由 JVM 自身实现。</p>
<blockquote>
<p>此处，说的是 Hotspot 的情况下。</p>
</blockquote>
</li>
<li><p>Extension ClassLoader ：扩展类加载器，扩展类加载器的加载路径是 JDK 目录下 <code>jre/lib/ext</code> 。扩展加载器的 <code>#getParent()</code> 方法返回 <code>null</code> ，实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是 Java 实现的。</p>
</li>
<li><p>System ClassLoader ：系统(应用)类加载器，它负责在 JVM 启动时加载来自 Java 命令的 <code>-classpath</code> 选项、<code>java.class.path</code> 系统属性或 <code>CLASSPATH</code> 环境变量所指定的 jar 包和类路径。程序可以通过 <code>#getSystemClassLoader()</code> 来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径。</p>
</li>
<li><p>该模型要求除了顶层的 Bootstrap 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。简略代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; java.lang.ClassLoader</span><br><span class="line"></span><br><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... 省略其它代码</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The parent class loader for delegation</span><br><span class="line">    &#x2F;&#x2F; Note: VM hardcoded the offset of this field, thus all new fields</span><br><span class="line">    &#x2F;&#x2F; must be added *after* it.</span><br><span class="line">    private final ClassLoader parent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成。</p>
<ul>
<li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）。</li>
<li>类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次。</li>
</ul>
</li>
</ul>
<h3 id="Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="Java 虚拟机是如何判定两个 Java 类是相同的？"></a>Java 虚拟机是如何判定两个 Java 类是相同的？</h3><p>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。<strong>只有两者都相同的情况，才认为两个类是相同的</strong>。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<p>比如一个 Java 类 <code>com.example.Sample</code> ，编译之后生成了字节代码文件 <code>Sample.class</code> 。两个不同的类加载器 ClassLoaderA 和 ClassLoaderB 分别读取了这个 <code>Sample.class</code> 文件，并定义出两个 <code>java.lang.Class</code> 类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException 。</p>
<h3 id="双亲委派模型的工作过程？"><a href="#双亲委派模型的工作过程？" class="headerlink" title="双亲委派模型的工作过程？"></a>双亲委派模型的工作过程？</h3><ul>
<li><p>1、当前 ClassLoader 首先从自己已经加载的类中，查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p>
<blockquote>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p>
</blockquote>
</li>
<li><p>2、当前 ClassLoader 的缓存中没有找到被加载的类的时候</p>
<ul>
<li>委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。</li>
<li>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</li>
</ul>
</li>
</ul>
<p>让我们来简单撸下源码。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; java.lang.ClassLoader</span><br><span class="line">&#x2F;&#x2F; 删除部分无关代码</span><br><span class="line"></span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先，从缓存中获得 name 对应的类</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 获得不到</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 其次，如果父类非空，使用它去加载类</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#x2F;&#x2F; 其次，如果父类为空，使用 Bootstrap 去加载类</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 还是加载不到</span><br><span class="line">                &#x2F;&#x2F; 最差，使用自己去加载类</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果要解析类，则进行解析</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么优先使用父-ClassLoader-加载类？"><a href="#为什么优先使用父-ClassLoader-加载类？" class="headerlink" title="为什么优先使用父 ClassLoader 加载类？"></a>为什么优先使用父 ClassLoader 加载类？</h3><ul>
<li><p>1、共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</p>
</li>
<li><p>2、隔离功能：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 <code>java.lang.ClassCaseException</code> 。</p>
<blockquote>
<p>这也就是说，即使我们自己定义了一个 <code>java.util.String</code> 类，也不会被重复加载。</p>
</blockquote>
</li>
</ul>
<h2 id="什么是破坏双亲委托模型？"><a href="#什么是破坏双亲委托模型？" class="headerlink" title="什么是破坏双亲委托模型？"></a>什么是破坏双亲委托模型？</h2><p>正如我们上面看到的源码，破坏双亲委托模型，需要做的是，<code>#loadClass(String name, boolean resolve)</code> 方法中，不调用父 <code>parent</code> ClassLoader 方法去加载类，那么就成功了。那么我们要做的仅仅是，错误的覆盖 <code>##loadClass(String name, boolean resolve)</code> 方法，不去使用父 <code>parent</code> ClassLoader 方法去加载类即可。</p>
<p>想要深入的胖友，可以深入看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dangwanma6489/article/details/80244981">《Tomcat 类加载器之为何违背双亲委派模型》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangcheng33/article/details/52631940">《真正理解线程上下文类加载器（多案例分析）》</a> 提供了多种打破双亲委托模型的案例。</li>
<li><a target="_blank" rel="noopener" href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「第 9 章 类加载及执行子系统的案例与实战」</a></li>
</ul>
<h3 id="如何自定义-ClassLoader-类？"><a href="#如何自定义-ClassLoader-类？" class="headerlink" title="如何自定义 ClassLoader 类？"></a>如何自定义 ClassLoader 类？</h3><p>直接参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3036b46f1188">《Java 自定义 ClassLoader 实现 JVM 类加载》</a> 文章即可。</p>
<h3 id="OSGI-如何实现模块化热部署？"><a href="#OSGI-如何实现模块化热部署？" class="headerlink" title="OSGI 如何实现模块化热部署？"></a>OSGI 如何实现模块化热部署？</h3><blockquote>
<p>了解即可。</p>
</blockquote>
<p>OSGI 实现模块化热部署的关键，是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要等换一个模块时，就把模块连同类加载器一起换掉以实现代码的热替换。</p>
<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h1 id="早期（编译期）优化"><a href="#早期（编译期）优化" class="headerlink" title="早期（编译期）优化"></a>早期（编译期）优化</h1><h1 id="晚期（运行期）优化"><a href="#晚期（运行期）优化" class="headerlink" title="晚期（运行期）优化"></a>晚期（运行期）优化</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/08/01/Java%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/01/Java%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【并发】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-01T00:00:00+08:00">2020-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 17:41:38" itemprop="dateModified" datetime="2020-08-05T17:41:38+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简述线程、进程、程序的基本概念？"><a href="#简述线程、进程、程序的基本概念？" class="headerlink" title="简述线程、进程、程序的基本概念？"></a>简述线程、进程、程序的基本概念？</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序，是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程，是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程，与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>另外，Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的。感兴趣的胖友，可以看 <a target="_blank" rel="noopener" href="http://landcareweb.com/questions/33900/javazhong-de-qing-liang-ji-xian-cheng">《Java 中的轻量级线程？》</a> 的讨论，没准未来 Java 也有内置的协程（Coroutine）。</p>
</blockquote>
<h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul>
<li>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
<h3 id="线程有什么优缺点？"><a href="#线程有什么优缺点？" class="headerlink" title="线程有什么优缺点？"></a>线程有什么优缺点？</h3><p>1）好处</p>
<ul>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载。</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好。</li>
</ul>
<p>2）坏处</p>
<ul>
<li>大量的线程降低代码的可读性。</li>
<li>更多的线程需要更多的内存空间。</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<h3 id="你了解守护线程吗？它和非守护线程有什么区别？"><a href="#你了解守护线程吗？它和非守护线程有什么区别？" class="headerlink" title="你了解守护线程吗？它和非守护线程有什么区别？"></a>你了解守护线程吗？它和非守护线程有什么区别？</h3><p>Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p>
<ul>
<li>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread#setDaemon(boolean on)</code> 设置。<code>true</code> 则把该线程设置为守护线程，反之则为用户线程。</li>
<li><code>Thread#setDaemon(boolean on)</code> 方法，必须在<code>Thread#start()</code> 方法之前调用，否则运行时会抛出异常。</li>
</ul>
<p>唯一的区别是：</p>
<blockquote>
<p>程序运行完毕，JVM 会等待非守护线程完成后关闭，但是 JVM 不会等待守护线程。</p>
</blockquote>
<ul>
<li>判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。</li>
<li>也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程。比如，JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
<p>扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程。可能会有：服务守护进程、编译守护进程、Windows 下的监听 Ctrl + break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<p>关于守护线程的各种骚操作，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/50392298">《Java 守护线程概述》</a> 。</p>
<h3 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<blockquote>
<p>简单的说，ThreadGroup 为了方便线程的管理。</p>
</blockquote>
<p>为什么不推荐使用？ThreadGroup API 比较薄弱，它并没有比 Thread 提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(uncaught exception handler)。但在 Java5 中 Thread 类也添加了 <code>#setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code> 方法，所以 ThreadGroup 是已经过时的，不建议继续使用。</p>
<h2 id="什么是多线程上下文切换？"><a href="#什么是多线程上下文切换？" class="headerlink" title="什么是多线程上下文切换？"></a>什么是多线程上下文切换？</h2><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p>
<p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。</p>
<ul>
<li>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</li>
<li>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>
<h3 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h3><p>假设计算机只有一个 CPU ，则在任意时刻只能执行一条机器指令，每个线程只有获得 CPU 的使用权才能执行指令。</p>
<ul>
<li>所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。</li>
<li>在运行池中，会有多个处于就绪状态的线程在等待 CPU ，Java 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</li>
</ul>
<p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li><p>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
</li>
<li><p>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</p>
<blockquote>
<p>如非特别需要，尽量不要用，防止线程饥饿。</p>
</blockquote>
</li>
</ul>
<h3 id="什么是线程饥饿？"><a href="#什么是线程饥饿？" class="headerlink" title="什么是线程饥饿？"></a>什么是线程饥饿？</h3><p>饥饿，一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。</p>
<ul>
<li>我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h2 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h2><p>线程一共有五个状态，分别如下：</p>
<ul>
<li><p>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：<code>Thread t1 = new Thread()</code> 。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：<code>t1.start()</code> 。</p>
<blockquote>
<p>有些文章，会称可运行(runnable)为就绪，意思是一样的。</p>
</blockquote>
</li>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（<code>#run()</code> 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<ul>
<li>自然终止：正常运行完 <code>#run()</code>方法，终止。</li>
<li>异常终止：调用 <code>#stop()</code> 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>堵塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
<ul>
<li><p>正在睡眠：调用 <code>#sleep(long t)</code> 方法，可使线程进入睡眠方式。</p>
<blockquote>
<p>一个睡眠着的线程在指定的时间过去可进入可运行(runnable)状态。</p>
</blockquote>
</li>
<li><p>正在等待：调用 <code>#wait()</code> 方法。</p>
<blockquote>
<p>调用 <code>notify()</code> 方法，回到就绪状态。</p>
</blockquote>
</li>
<li><p>被另一个线程所阻塞：调用 <code>#suspend()</code> 方法。</p>
<blockquote>
<p>调用 <code>#resume()</code> 方法，就可以恢复。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>整体如下图所示：</p>
<p><img src="http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c" alt="img"></p>
<ul>
<li>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</li>
<li>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。****</li>
<li>理解线程的状态，可以用早起坐地铁来比喻这个过程：<ul>
<li>还没起床：sleeping 。</li>
<li>起床收拾好了，随时可以坐地铁出发：Runnable 。</li>
<li>等地铁来：Waiting 。</li>
<li>地铁来了，但要排队上地铁：I/O 阻塞 。</li>
<li>上了地铁，发现暂时没座位：synchronized 阻塞。</li>
<li>地铁上找到座位：Running 。</li>
<li>到达目的地：Dead 。</li>
</ul>
</li>
</ul>
<p>如下是另外一个图，把阻塞的情况，放在了一起，也可以作为参考：</p>
<p><img src="http://static2.iocoder.cn/3281138331173cdd53d1364f9c56d594" alt="img"></p>
<p>无意中，又看到一张画的更牛逼的，如下图：</p>
<p><img src="http://static2.iocoder.cn/5eeec5f68f4fc412246efd4111d6fdec" alt="img"></p>
<h3 id="如何结束一个一直运行的线程？"><a href="#如何结束一个一直运行的线程？" class="headerlink" title="如何结束一个一直运行的线程？"></a>如何结束一个一直运行的线程？</h3><p>一般来说，有两种方式：</p>
<ul>
<li><p>方式一，使用退出标志，这个 flag 变量要多线程可见。</p>
<blockquote>
<p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p>
</blockquote>
</li>
<li><p>方式二，使用 interrupt 方法，结合 isInterrupted 方法一起使用。</p>
<blockquote>
<p>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 <code>Thread#join()</code> 方法，或者 <code>Thread#sleep(...)</code> 方法，在网络中调用<code>ServerSocket#accept()</code> 方法，或者调用了<code>DatagramSocket#receive()</code> 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时。即使主程序中将该线程的共享变量设置为 <code>true</code> ，但该线程此时根本无法检查循环标志，当然也就无法立即中断。</p>
<p>这里我们给出的建议是，不要使用 <code>Thread#stop()· 方法，而是使用 Thread 提供的</code>#interrupt()` 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p>
</blockquote>
</li>
</ul>
<p>所以，方式一和方式二，并不是冲突的两种方式，而是可能根据实际场景下，进行结合。</p>
<h3 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样?"></a>一个线程如果出现了运行时异常会怎么样?</h3><p>如果这个异常没有被捕获的话，这个线程就停止执行了。</p>
<p>另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p>
<h2 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h2><p>Java 中创建线程主要有三种方式：</p>
<blockquote>
<p>具体的每种方式的代码实现，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012973218/article/details/51280044">《Java创建线程的四种方式》</a> 。</p>
<p>关于文章中的方式四，实际是基于线程池的方式，使用下面的三种方式，也是生产实践中，最为推荐和常用的方式。</p>
</blockquote>
<ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li><p>使用方式一</p>
<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 <code>Thread#currentThread()</code> 方法，直接使用 <code>this</code> 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li><p>使用方式二、或方式三</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p>
</li>
<li><p>在这种方式下，多个线程可以共享同一个 <code>target</code> 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable runner &#x3D; new Runnable()&#123; ... &#125;;</span><br><span class="line">&#x2F;&#x2F; 通过new Thread(target, name) 方法创建新线程</span><br><span class="line">new Thread(runna,&quot;新线程1&quot;).start();</span><br><span class="line">new Thread(runna,&quot;新线程2&quot;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>当然，实际比较少这么用。</li>
</ul>
</li>
<li><p>【最重要】<strong>可以使用线程池</strong>。</p>
</li>
</ul>
</li>
<li><p>缺点：编程稍微复杂，如果要访问当前线程，则必须使用<code>Thread#currentThread()</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<h3 id="start-和-run-方法有什么区别？"><a href="#start-和-run-方法有什么区别？" class="headerlink" title="start 和 run 方法有什么区别？"></a>start 和 run 方法有什么区别？</h3><ul>
<li>当你调用 start 方法时，你将创建新的线程，并且执行在 run 方法里的代码。</li>
<li>但是如果你直接调用 run 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。</li>
</ul>
<h3 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h3><p>如果异常没有被捕获该线程将会停止执行。<code>Thread.UncaughtExceptionHandler</code> 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 <code>Thread#getUncaughtExceptionHandler()</code> 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 <code>#uncaughtException(exception)</code> 方法进行处理。</p>
<p>具体的使用，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/50417822">《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》</a> 。</p>
<h2 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h2><blockquote>
<p>wait + notify 对于大多数胖友，一开始理解可能会比较困难，多看多理解吧。</p>
</blockquote>
<p>在 Java 发展史上，曾经使用 suspend、resume 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p>
<p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait 和 notify方法实现线程阻塞。</p>
<ul>
<li>首先，wait、notify 方法是针对对象的，调用任意对象的 wait 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行。</li>
<li>其次，wait、notify 方法必须在 <code>synchronized</code> 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li>
</ul>
<p>具体的实现，看看 <a target="_blank" rel="noopener" href="https://juejin.im/entry/5a2bb783f265da43163cff74">《Wait / Notify通知机制解析》</a> 文章。</p>
<p>通过 wait + notify 的组合，可以通知机制，不过我们也可以使用其它工具，胖友可以思考下。例如如下的每一个方式：</p>
<ul>
<li>Condition</li>
<li>CountDownLatch</li>
<li>Queue</li>
<li>Future</li>
<li>…</li>
</ul>
<blockquote>
<p>艿艿：这个问题可以衍生下，Java 如何实现多线程之间的通讯和协作？具体的可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoucheng05_13/article/details/78311179">《Java多线程——线程间协作方式总结及使用示例》</a> 文章，当然不仅限于该文章所提供的方式。😈 胖友可以认真思索下。</p>
</blockquote>
<h3 id="Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？"></a>Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？</h3><blockquote>
<p>关于这个问题，可以结合 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「线程的生命周期？」</a> 问题的图，一起瞅瞅。</p>
</blockquote>
<ul>
<li>sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li>
<li>wait 方法，是 Object 类的方法。调用对象的 <code>#wait()</code> 方法，会导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 <code>#notify()</code> 方法（或<code>#notifyAll()</code>方法）时，才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<h3 id="请说出与线程同步以及线程调度相关的方法？"><a href="#请说出与线程同步以及线程调度相关的方法？" class="headerlink" title="请说出与线程同步以及线程调度相关的方法？"></a>请说出与线程同步以及线程调度相关的方法？</h3><ul>
<li>wait 方法，使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁。</li>
<li>sleep 方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常。</li>
<li>notify 方法，唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</li>
<li>notityAll 方法，唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</li>
</ul>
<h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify 和 notifyAll 有什么区别？"></a>notify 和 notifyAll 有什么区别？</h3><p>当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。</p>
<ul>
<li>使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。</li>
<li>如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。</li>
</ul>
<p>关于 notify 的信息丢失，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/91d95bb5a4bd">《wait 和 notify 的坑》</a> 文章。</p>
<h3 id="为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？"><a href="#为什么-wait-notify-和-notifyAll-这三方法不在-Thread-类里面？" class="headerlink" title="为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？"></a>为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？</h3><p>一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。</p>
<h3 id="为什么-wait-和-notify-方法要在同步块中调用？"><a href="#为什么-wait-和-notify-方法要在同步块中调用？" class="headerlink" title="为什么 wait 和 notify 方法要在同步块中调用？"></a>为什么 wait 和 notify 方法要在同步块中调用？</h3><ul>
<li>Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</li>
</ul>
<h3 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>所以，我们不能写 <code>if (condition)</code> 而应该是 <code>while (condition)</code> ，特别是 CAS 竞争的时候。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The standard idiom for using the wait method</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (condition does not hold) &#123;</span><br><span class="line">        obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外，也可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35181209/article/details/77362297">《wait 必须放在 while 循环里面的原因探析》</a></li>
</ul>
<h2 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h2><p>1）sleep 方法</p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有<code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 <code>synchronized</code>)，一个线程优先级为<code>MAX_PRIORITY</code> ，另一个为 <code>MIN_PRIORITY</code> 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 <code>#sleep(5000)</code> 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p>2）yield 方法</p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p>3）join 方法</p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 的尾部。在线程 A 执行完毕之前，线程 B 不能工作。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t &#x3D; new MyThread();</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 <code>t</code> 完成为止。然而，如果它加入的线程 <code>t</code> 没有存活，则当前线程不需要停止。</li>
</ul>
<h3 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep 方法和 yield 方法有什么区别？"></a>线程的 sleep 方法和 yield 方法有什么区别？</h3><ul>
<li>sleep 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。yield 方法只会给相同优先级或更高优先级的线程以运行的机会。</li>
<li>线程执行 sleep 方法后转入阻塞（blocked）状态，而执行 yield 方法后转入就绪（ready）状态。</li>
<li>sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。</li>
<li>sleep 方法比 yield 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</li>
</ul>
<blockquote>
<p>艿艿：实际场景下，我们很少使用 yield 方法噢。</p>
</blockquote>
<h3 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep 和 yield 方法是静态的？"></a>为什么 Thread 类的 sleep 和 yield 方法是静态的？</h3><p>Thread 类的 sleep 和 yield 方法，将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h3 id="sleep-0-有什么用途？"><a href="#sleep-0-有什么用途？" class="headerlink" title="sleep(0) 有什么用途？"></a>sleep(0) 有什么用途？</h3><p><code>Thread#sleep(0)</code> 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 <code>Thread#sleep(0)</code> 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。<code>Thread#sleep(0)</code> 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个<strong>让位动作</strong>。</p>
<p>感兴趣的胖友，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaoquan3/article/details/56281092">《Sleep(0) 的妙用》</a> 的示例。</p>
<h3 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</h3><blockquote>
<p>考点，就是 join 方法。</p>
</blockquote>
<p>我们可以使用 Thread 类的 <code>#join()</code> 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h2 id="interrupted-和-isInterrupted-方法的区别？"><a href="#interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="interrupted 和 isInterrupted 方法的区别？"></a>interrupted 和 isInterrupted 方法的区别？</h2><p>1）interrupt 方法</p>
<p><code>Thread#interrupt()</code> 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>2）interrupted</p>
<p><code>Thread#interrupted()</code> <strong>静态</strong>方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 <code>#interrupted()</code> 方法则返回 <code>true</code> ，第二次和后面的就返回 <code>false</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true); &#x2F;&#x2F; 清理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>

<p>3）interrupted</p>
<p><code>Thread#isInterrupted()</code> 方法，查询指定线程的中断状态，不会清除原状态。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return isInterrupted(false); &#x2F;&#x2F; 不清楚</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>



<h2 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h2><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="Servlet-是线程安全吗？"><a href="#Servlet-是线程安全吗？" class="headerlink" title="Servlet 是线程安全吗？"></a>Servlet 是线程安全吗？</h3><p>Servlet 不是线程安全的，Servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<h3 id="Struts2-是线程安全吗？"><a href="#Struts2-是线程安全吗？" class="headerlink" title="Struts2 是线程安全吗？"></a>Struts2 是线程安全吗？</h3><p>Struts2 的 Action 是多实例多线程的，是线程安全的，每个请求过来都会 <code>new</code> 一个新的 Action 分配给这个请求，请求完成后销毁。</p>
<h3 id="SpringMVC-是线程安全吗？"><a href="#SpringMVC-是线程安全吗？" class="headerlink" title="SpringMVC 是线程安全吗？"></a>SpringMVC 是线程安全吗？</h3><p>不是的，和 Servlet 类似的处理流程。</p>
<h3 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性?"></a>单例模式的线程安全性?</h3><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：非线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
<h2 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h2><p>1）<strong>线程同步</strong></p>
<p>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：<ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p>2）<strong>线程互斥</strong></p>
<p>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<h3 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h3><p>在两个线程间<strong>共享变量</strong>，即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>调用 <code>Thread#holdsLock(Object obj)</code> <strong>静态</strong>方法，它返回 <code>true</code> 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread.java</span><br><span class="line"></span><br><span class="line">public static native boolean holdsLock(Object obj);</span><br></pre></td></tr></table></figure>

<h3 id="10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>10 个线程和 2 个线程的同步代码，哪个更容易写？</h3><p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。</p>
<p>但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h2 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h2><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<p>它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。</p>
<ul>
<li>首先，通过复用减少了代价高昂的对象的创建个数。</li>
<li>其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</li>
</ul>
<p>😈 所以，ThreadLocal 很适合实现线程级的单例。</p>
<p>详细的，可以看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920407.html">《Java并发编程：深入剖析ThreadLocal》</a> 文章。</p>
<p>关于源码，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadLocal/?vip">《【死磕 Java 并发】—– 深入分析 ThreadLocal》</a> 。</p>
<h3 id="什么是-InheritableThreadLocal-？"><a href="#什么是-InheritableThreadLocal-？" class="headerlink" title="什么是 InheritableThreadLocal ？"></a>什么是 InheritableThreadLocal ？</h3><p>InheritableThreadLocal 类，是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，<strong>InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值</strong>。</p>
<ul>
<li>具体的实现原理，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ni357103403/article/details/51970748">《Java 多线程：InheritableThreadLocal 实现原理》</a> 文章。</li>
<li>具体的使用示例，可以看看 <a target="_blank" rel="noopener" href="http://blog.didispace.com/Spring-Cloud%E4%B8%ADHystrix-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%AF%BC%E8%87%B4ThreadLocal%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/">《Spring Cloud中Hystrix 线程隔离导致ThreadLocal数据丢失》</a> 。</li>
</ul>
<h3 id="在多线程环境下，SimpleDateFormat-是线程安全的吗？"><a href="#在多线程环境下，SimpleDateFormat-是线程安全的吗？" class="headerlink" title="在多线程环境下，SimpleDateFormat 是线程安全的吗？"></a>在多线程环境下，SimpleDateFormat 是线程安全的吗？</h3><p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，<strong>如将 SimpleDateFormat 限制在 ThreadLocal 中</strong>。</p>
<p>如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h2 id="如何在-Java-中获取线程堆栈？"><a href="#如何在-Java-中获取线程堆栈？" class="headerlink" title="如何在 Java 中获取线程堆栈？"></a>如何在 Java 中获取线程堆栈？</h2><ul>
<li><p><code>kill -3 [java pid]</code></p>
<p>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如， <code>kill -3 tomcat pid</code> , 输出堆栈到 log 目录下。</p>
</li>
<li><p><code>Jstack [java pid]</code></p>
<p>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a3b92def265da4319567218"><code>JVisualVM：Thread Dump</code></a></p>
<p>不做说明，打开 JVisualVM 后，都是界面操作，过程还是很简单的。</p>
</li>
</ul>
<h2 id="什么是Java-Timer-类？"><a href="#什么是Java-Timer-类？" class="headerlink" title="什么是Java Timer 类？"></a>什么是Java Timer 类？</h2><p><code>java.util.Timer</code> ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。</p>
<p><code>java.util.TimerTask</code> ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。</p>
<p>目前有开源的 Qurtz 可以用来创建定时任务。</p>
<h2 id="你有哪些多线程开发良好的实践？"><a href="#你有哪些多线程开发良好的实践？" class="headerlink" title="你有哪些多线程开发良好的实践？"></a>你有哪些多线程开发良好的实践？</h2><ul>
<li><p>1、给线程命名。</p>
<blockquote>
<p>这样可以方便找 bug 或追踪。OrderProcessor、QuoteProcessor、TradeProcessor 这种名字比 Thread-1、Thread-2、Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
</blockquote>
</li>
<li><p>2、最小化同步范围。</p>
<blockquote>
<p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
</blockquote>
</li>
<li><p>3、优先使用 <code>volatile</code> ，而不是 <code>synchronized</code> 。</p>
</li>
<li><p>4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。</p>
<blockquote>
<p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。</p>
<p>其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
</blockquote>
</li>
<li><p>5、优先使用并发容器，而非同步容器。</p>
<blockquote>
<p>这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。</p>
</blockquote>
</li>
<li><p>6、考虑使用线程池。</p>
</li>
</ul>
<h2 id="并发编程和并行编程有什么区别？"><a href="#并发编程和并行编程有什么区别？" class="headerlink" title="并发编程和并行编程有什么区别？"></a>并发编程和并行编程有什么区别？</h2><p>并发（Concurrency）和并行（Parallellism）是：</p>
<ul>
<li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。</li>
<li>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。</li>
</ul>
<p>所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="同步和异步有何异同，在什么情况下分别使用他们？"><a href="#同步和异步有何异同，在什么情况下分别使用他们？" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？"></a>同步和异步有何异同，在什么情况下分别使用他们？</h2><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行<strong>同步</strong>存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用<strong>异步</strong>编程，在很多情况下采用异步途径往往更有效率。</p>
<blockquote>
<p>当然，如果我们对效率没有特别大的要求，也不一定需要使用异步编程，因为它会带来编码的复杂性。总之，合适才是正确的。</p>
</blockquote>
<h2 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a>synchronized 的原理是什么?</h2><p><code>synchronized</code>是 Java 内置的关键字，它提供了一种独占的加锁方式。</p>
<ul>
<li><code>synchronized</code>的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</li>
<li>然而，synchronized 也有一定的局限性。<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li>
</ul>
</li>
</ul>
<p>关于原理，直接阅读 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/synchronized/?vip">《【死磕 Java 并发】—– 深入分析 synchronized 的实现原理》</a> 文章，有几个重点要注意看。</p>
<ul>
<li>实现原理</li>
<li>Java 对象头、Monitor</li>
<li>锁优化<ul>
<li>自旋锁<ul>
<li>适应自旋锁</li>
</ul>
</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>锁的升级<ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个-synchronized-的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个 <code>synchronized</code> 的实例方法后，其它线程是否可进入此对象的其它方法？</h3><ul>
<li>如果其他方法没有 <code>synchronized</code> 的话，其他线程是可以进入的。</li>
<li>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</li>
</ul>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h3><p>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。<strong>线程在获取锁之前不允许执行同步代码</strong>。</p>
<h3 id="Java-如何实现“自旋”（spin）"><a href="#Java-如何实现“自旋”（spin）" class="headerlink" title="Java 如何实现“自旋”（spin）"></a>Java 如何实现“自旋”（spin）</h3><p>参考 <a target="_blank" rel="noopener" href="http://ifeve.com/java_lock_see1/">《Java 锁的种类以及辨析（一）：自旋锁》</a></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign &#x3D;new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123; &#x2F;&#x2F; &lt;1&gt;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        while(!sign .compareAndSet(null, current)) &#123;</span><br><span class="line">            &#x2F;&#x2F; &lt;1.1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock () &#123; &#x2F;&#x2F; &lt;2&gt;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        sign .compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 处，<code>#lock()</code> 方法，如果获得不到锁，就会“死循环”，直到或得到锁为止。考虑到“死循环”会持续占用 CPU ，可能导致其它线程无法获得到 CPU 执行，可以在 <code>&lt;1.1&gt;</code> 处增加 <code>Thread.yiead()</code> 代码段，出让下 CPU 。</li>
<li><code>&lt;2&gt;</code> 处，<code>#unlock()</code> 方法，释放锁。</li>
</ul>
<h2 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h2><p><code>volatile</code> 涉及的内容，其实蛮多的，所以胖友直接看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/volatile/?vip">《【死磕 Java 并发】—– 深入分析 volatile 的实现原理》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ftf-java-volatile">聊聊并发（一）——深入分析Volatile的实现原理</a></li>
</ul>
<h3 id="volatile-有什么用？"><a href="#volatile-有什么用？" class="headerlink" title="volatile 有什么用？"></a>volatile 有什么用？</h3><p><code>volatile</code> 保证内存可见性和禁止指令重排。</p>
<blockquote>
<p>同时，<code>volatile</code> 可以提供部分原子性。</p>
</blockquote>
<p>简单来说，<code>volatile</code> 用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><ul>
<li><code>volatile</code> 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 <code>volatile</code> 修饰 <code>count</code> 变量，那么 <code>count++</code> 操作就不是原子性的。</li>
<li>AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 <code>#getAndIncrement()</code> 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<h3 id="可以创建-volatile-数组吗"><a href="#可以创建-volatile-数组吗" class="headerlink" title="可以创建 volatile 数组吗?"></a>可以创建 volatile 数组吗?</h3><p>Java 中可以创建 <code>volatile</code> 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 <code>volatile</code> 的保护，但是如果多个线程同时改变数组的元素，<code>volatile</code> 标示符就不能起到之前的保护作用了。</p>
<p>同理，对于 Java POJO 类，使用 <code>volatile</code> 修饰，只能保证这个引用的可见性，不能保证其内部的属性。</p>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗"><a href="#volatile-能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗?"></a>volatile 能使得一个非原子操作变成原子操作吗?</h3><p>一个典型的例子是在类中有一个 <code>long</code> 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 <code>volatile</code> 。为什么？因为 Java 中读取 <code>long</code> 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 <code>long</code> 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子。</p>
<blockquote>
<p>如下的内容，可以作为上面的内容的补充。</p>
<p>一种实践是用 <code>volatile</code> 修饰 <code>long</code> 和 <code>double</code> 变量，使其能按原子类型来读写。<code>double</code> 和 <code>long</code> 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子的。</p>
</blockquote>
<h3 id="volatile-类型变量提供什么保证？"><a href="#volatile-类型变量提供什么保证？" class="headerlink" title="volatile 类型变量提供什么保证？"></a>volatile 类型变量提供什么保证？</h3><p><code>volatile</code> 主要有两方面的作用：</p>
<ol>
<li>避免指令重排</li>
<li>可见性保证</li>
</ol>
<p>例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 <code>volatile</code> 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。</p>
<ul>
<li><code>volatile</code> 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。</li>
<li>某些情况下，<code>volatile</code> 还能提供原子性，如读 64 位数据类型，像 <code>long</code> 和 <code>double</code> 都不是原子的(低 32 位和高 32 位)，但 <code>volatile</code> 类型的 <code>double</code> 和 <code>long</code> 就是原子的。<strong>不过需要在 64 位的 JVM 虚拟机上</strong>。详细的分析，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/u/1753415/blog/724242">《Java中 long 和 double 的原子性》</a> 。</li>
</ul>
<h3 id="volatile-和-synchronized-的区别？"><a href="#volatile-和-synchronized-的区别？" class="headerlink" title="volatile 和 synchronized 的区别？"></a>volatile 和 synchronized 的区别？</h3><ol>
<li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别。<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性。而<code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li>
<li><code>volatile</code> 不会造成线程的阻塞。<code>synchronized</code> 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化。<code>synchronized</code>标记的变量可以被编译器优化。</li>
</ol>
<blockquote>
<p>另外，会有面试官会问 <code>volatile</code> 能否取代 <code>synchronized</code> 呢？答案肯定是不能，虽然说 <code>volatile</code> 被称之为轻量级锁，但是和 <code>synchronized</code> 是有本质上的区别，原因就是上面的几点落。</p>
</blockquote>
<h3 id="什么场景下可以使用-volatile-替换-synchronized-？"><a href="#什么场景下可以使用-volatile-替换-synchronized-？" class="headerlink" title="什么场景下可以使用 volatile 替换 synchronized ？"></a>什么场景下可以使用 volatile 替换 synchronized ？</h3><ol>
<li>只需要保证共享资源的可见性的时候可以使用 <code>volatile</code> 替代，<code>synchronized</code> 保证可操作的原子性一致性和可见性。</li>
<li><code>volatile</code> 适用于新值不依赖于旧值的情形。</li>
<li>1 写 N 读。</li>
<li>不与其他变量构成不变性条件时候使用 <code>volatile</code> 。</li>
</ol>
<h2 id="什么是死锁、活锁？"><a href="#什么是死锁、活锁？" class="headerlink" title="什么是死锁、活锁？"></a>什么是死锁、活锁？</h2><p>死锁，是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<h3 id="死锁与活锁的区别？"><a href="#死锁与活锁的区别？" class="headerlink" title="死锁与活锁的区别？"></a>死锁与活锁的区别？</h3><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，聪慧的胖友是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h2 id="什么是悲观锁、乐观锁？"><a href="#什么是悲观锁、乐观锁？" class="headerlink" title="什么是悲观锁、乐观锁？"></a>什么是悲观锁、乐观锁？</h2><p>1）悲观锁</p>
<p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 <code>synchronized</code> 关键字的实现也是悲观锁。</li>
</ul>
<p>2）乐观锁</p>
<p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li><p>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。</p>
<blockquote>
<p>例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</p>
</blockquote>
</li>
<li><p>在 Java 中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
</li>
</ul>
<p>乐观锁的实现方式：</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h2 id="Java-AQS"><a href="#Java-AQS" class="headerlink" title="Java AQS"></a>Java AQS</h2><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。事实上<code>concurrent</code> 包内许多类都是基于 AQS 构建。例如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。AQS 解决了在实现同步容器时设计的大量细节问题。</p>
<p>AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 <code>waitStatus</code> 。</p>
<p>可能这么说，胖友会一脸懵逼，最好的方式，还是直接去撸源码，可见如下的四篇文章。</p>
<blockquote>
<p>可能胖友在阅读时，会有一定的挫败感，没关系，大家都是如此，包括艿艿，还有我认识的各种大佬。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-0-intro?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：AQS 简介》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-1-clh?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：CLH 同步队列》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-2?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/aqs-3?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：阻塞和唤醒线程》</a></li>
</ul>
<h2 id="什么是-Java-Lock-接口？"><a href="#什么是-Java-Lock-接口？" class="headerlink" title="什么是 Java Lock 接口？"></a>什么是 Java Lock 接口？</h2><p><code>java.util.concurrent.locks.Lock</code> 接口，比 <code>synchronized</code> 提供更具拓展行的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>
<ul>
<li>可以使锁更公平。</li>
<li>可以使线程在等待锁的时候响应中断。</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁。</li>
</ul>
<h2 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h2><p>举例来说明锁的可重入性。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UnReentrant&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line"></span><br><span class="line">    public void outer() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inner() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#outer()</code> 方法中调用了 <code>#inner()</code> 方法，<code>#outer()</code> 方法先锁住了 <code>lock</code> ，这样 <code>#inner()</code> 就不能再获取 <code>lock</code> 。</li>
<li>其实调用 <code>#outer()</code> 方法的线程已经获取了 <code>lock</code> 锁，但是不能在 <code>#inner()</code> 方法中重复利用已经获取的锁资源，这种锁即称之为不可重入。</li>
<li>可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</li>
</ul>
<p><code>synchronized</code>、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p>
<p>关于 ReentrantLock 类，详细的源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ReentrantLock/?vip">《【死磕 Java 并发】—– J.U.C 之重入锁：ReentrantLock》</a> 。</p>
<blockquote>
<p>简单来说，ReenTrantLock 的实现是一种自旋锁，通过循环调用 CAS 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
</blockquote>
<h3 id="synchronized-和-ReentrantLock-异同？"><a href="#synchronized-和-ReentrantLock-异同？" class="headerlink" title="synchronized 和 ReentrantLock 异同？"></a>synchronized 和 ReentrantLock 异同？</h3><ul>
<li>相同点<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
</li>
<li>不同点<ul>
<li>同步实现机制不同<ul>
<li><code>synchronized</code> 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。<br>*</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li><code>synchronized</code> 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 <code>volatile state</code> 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li><code>synchronized</code> 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 <code>finally</code> 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li><code>synchronized</code> 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>synchronized</code> 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 <code>synchronized</code> 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 <code>synchronized</code> 。</p>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。</p>
</blockquote>
<h2 id="ReadWriteLock-是什么？"><a href="#ReadWriteLock-是什么？" class="headerlink" title="ReadWriteLock 是什么？"></a>ReadWriteLock 是什么？</h2><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<p>ReadWriteLock 的源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/">《【死磕 Java 并发】—– J.U.C 之读写锁：ReentrantReadWriteLock》</a> 。</p>
<h2 id="Condition-是什么？"><a href="#Condition-是什么？" class="headerlink" title="Condition 是什么？"></a>Condition 是什么？</h2><p>在没有 Lock 之前，我们使用 <code>synchronized</code> 来控制同步，配合 Object 的 <code>#wait()</code>、<code>#notify()</code> 等一系列方法可以实现<strong>等待 / 通知模式</strong>。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 <code>synchronized</code> 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）：</p>
<p><img src="http://static2.iocoder.cn/e7e7bb0837bbe68a4364366d4ec9c5db" alt="img"></p>
<ul>
<li>Condition 的使用，可以看看 <a target="_blank" rel="noopener" href="http://www.importnew.com/9281.html">《怎么理解 Condition》</a></li>
<li>Condition 的源码，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Condition/">《【死磕 Java 并发】—– J.U.C 之 Condition》</a> 。</li>
</ul>
<h3 id="用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？"><a href="#用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc-？" class="headerlink" title="用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？"></a>用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？</h3><ul>
<li>使用 Lock + Condition 来实现。具体代码，参看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Big_Blogger/article/details/65629204">《用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc》</a> 。</li>
<li>使用 <code>synchronized</code> + await/notifyAll 来实现，参看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41704428/article/details/80482928">《Java用三个线程按顺序循环打印 abc 三个字母,比如 abcabcabc》</a> 。</li>
</ul>
<h2 id="LockSupport-是什么？"><a href="#LockSupport-是什么？" class="headerlink" title="LockSupport 是什么？"></a>LockSupport 是什么？</h2><p>LockSupport 是 JDK 中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。</p>
<ul>
<li>Java 锁和同步器框架的核心 AQS(AbstractQueuedSynchronizer)，就是通过调用 <code>LockSupport#park()</code>和 <code>LockSupport#unpark()</code> 方法，来实现线程的阻塞和唤醒的。</li>
<li>LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</li>
</ul>
<p>对于 LockSupport 了解即可，面试一般问的不多。感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hvicen/p/6217303.html">《多线程同步工具 —— LockSupport》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tianshouzhi.com/api/tutorials/mutithread/303">《Java 并发编程 —— LockSupport》</a> 带部分源码解析。</li>
</ul>
<h2 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h2><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在<strong>工作内存</strong>中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如下图：</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/01.png" alt="线程、主内存、工作内存"></p>
<blockquote>
<p> 艿艿：当然，有个面试官会把 Java 内存模型，和 JVM 内存结构搞混淆。所以，在回答之前，可以先和面试官确认下说的是哪个。</p>
<p>关于 JVM 内存结构的面试题，我们在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Java/VirtualMachine/Interview">《精尽 Java【虚拟机】面试题》</a> 中在详细分享。</p>
</blockquote>
<h2 id="两个线程之间是如何通信的呢？"><a href="#两个线程之间是如何通信的呢？" class="headerlink" title="两个线程之间是如何通信的呢？"></a>两个线程之间是如何通信的呢？</h2><p>线程之间的通信方式，目前有共享内存和消息传递两种。</p>
<p><strong>1）共享内存</strong></p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/02.png" alt="共享内存"></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</li>
</ol>
<p><strong>2）消息传递</strong></p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 <code>#wait()</code> 和 <code>#notify()</code> ，或者 BlockingQueue 。</p>
<p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/03.png" alt="消息传递"></p>
<h2 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h2><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p><strong>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义</strong>。</p>
<h2 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h2><p>详细看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/happens-before/?vip">《【死磕 Java 并发】—– Java 内存模型之 happens-before》</a> 文章。</p>
<h2 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h2><p>内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<h3 id="内存屏障为何重要？"><a href="#内存屏障为何重要？" class="headerlink" title="内存屏障为何重要？"></a>内存屏障为何重要？</h3><p>对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。</p>
<p>当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据写入的顺序不一致。适当的放置内存屏障，通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><p>何为同步容器？可以简单地理解为通过 <code>synchronized</code>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p>
<ul>
<li>比如 Vector，Hashtable，以及 <code>Collections#synchronizedSet()</code>，<code>Collections#synchronizedList()</code> 等方法返回的容器。</li>
<li>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 <code>synchronized</code> 。</li>
</ul>
<p>并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。</p>
<ul>
<li>例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map ，所以它可以在并发环境下实现更高的吞吐量。</li>
<li>再例如，CopyOnWriteArrayList 。</li>
</ul>
<h2 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><ul>
<li>SynchronizedMap<ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</li>
<li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 <code>new</code> 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li>
</ul>
</li>
</ul>
<p>关于 ConcurrentHashMap 的源码解析，推荐胖友看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/?vip">《【死磕 Java 并发】—– J.U.C 之 Java并发容器：ConcurrentHashMap》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/?vip">《【死磕 Java 并发】—– J.U.C 之 ConcurrentHashMap 红黑树转换分析》</a></li>
</ul>
<h3 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h3><p>在 JDK8 前，ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16 ，这样在多线程情况下就能避免争用。</p>
<p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现，利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>
<h3 id="ConcurrentHashMap-为何读不用加锁？"><a href="#ConcurrentHashMap-为何读不用加锁？" class="headerlink" title="ConcurrentHashMap 为何读不用加锁？"></a>ConcurrentHashMap 为何读不用加锁？</h3><p>在 JDK7 以及以前</p>
<ul>
<li>HashEntry 中的key、hash、next 均为 final型，只能表头插入、删除结点。<ul>
<li>HashEntry 类的 <code>value</code> 域被声明为 <code>volatile</code> 型。</li>
<li>不允许用 <code>null</code> 作为键和值，当读线程读到某个 HashEntry 的 <code>value</code> 域的值为 <code>null</code> 时，便知道产生了冲突——发生了重排序现象（put 方法设置新 <code>value</code> 对象的字节码指令重排序），需要加锁后重新读入这个 <code>value</code> 值。</li>
</ul>
</li>
<li><code>volatile</code> 变量 <code>count</code> 协调读写线程之间的内存可见性，写操作后修改 <code>count</code> ，读操作先读 <code>count</code>，根据 happen-before 传递性原则写操作的修改读操作能够看到。</li>
</ul>
<p>在 JDK8 开始</p>
<ul>
<li>Node 的 <code>val</code> 和 <code>next</code> 均为 <code>volatile</code> 型。</li>
<li><code>#tabAt(..,)</code> 和 <code>#casTabAt(...)</code> 对应的 Unsafe 操作实现了 <code>volatile</code> 语义。</li>
</ul>
<h2 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h2><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException 异常。在 CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 ygc 或者 fgc 。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
</ul>
<p>CopyOnWriteArrayList 透露的思想：</p>
<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
<p>CopyOnWriteArrayList 适用于读操作远远多于写操作的场景。例如，缓存。</p>
<p>关于 CopyOnWriteArrayList 的源码，可以看看 <a target="_blank" rel="noopener" href="http://www.importnew.com/12773.html">《CopyOnWriteArrayList 实现原理及源码分析》</a> 文章。</p>
<h2 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<ul>
<li>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程</li>
<li>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</li>
</ul>
<blockquote>
<p>艿艿：如下的内容，和上面是相对重复的，或者是换一个说法，重新描述。</p>
</blockquote>
<p>BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：</p>
<ul>
<li>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。</li>
<li>当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。</li>
<li>正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。</li>
</ul>
<p>阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：</p>
<ul>
<li>读取数据的线程不断将数据放入队列。</li>
<li>然后，解析线程不断从队列取数据解析。</li>
</ul>
<h2 id="Java-提供了哪些阻塞队列的实现？"><a href="#Java-提供了哪些阻塞队列的实现？" class="headerlink" title="Java 提供了哪些阻塞队列的实现？"></a>Java 提供了哪些阻塞队列的实现？</h2><p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<blockquote>
<p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait、notify、notifyAll、<code>sychronized</code> 这些关键字。</p>
<p>而在 Java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
</blockquote>
<ul>
<li><p>【最常用】ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p>
</blockquote>
</li>
<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先出先进的原则对元素进行排序</p>
</blockquote>
</li>
<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<blockquote>
<p>每一个 put 必须等待一个 take 操作，否则不能继续添加元素。并且他支持公平访问队列。</p>
</blockquote>
</li>
<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
<blockquote>
<p>相对于其他阻塞队列，多了 tryTransfer 和 transfer 方法。</p>
<ul>
<li>transfer 方法：如果当前有消费者正在等待接收元素（take 或者待时间限制的 poll 方法），transfer 可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</li>
<li>tryTransfer 方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回 false 。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</li>
</ul>
</blockquote>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<blockquote>
<p>优势在于多线程入队时，减少一半的竞争。</p>
</blockquote>
</li>
</ul>
<p>具体的源码解析，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ArrayBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：ArrayBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/PriorityBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：PriorityBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/SynchronousQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：SynchronousQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/LinkedTransferQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedTransferQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/LinkedBlockingDeque?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedBlockingDeque》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/BlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：BlockingQueue 总结》</a></li>
</ul>
<p>🦅 <strong>阻塞队列提供哪些重要方法？</strong></p>
<table>
<thead>
<tr>
<th align="left">方法处理方式</th>
<th align="left">抛出异常</th>
<th align="left">返回特殊值</th>
<th align="left">一直阻塞</th>
<th align="left">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入方法</td>
<td align="left">add(e)</td>
<td align="left">offer(e)</td>
<td align="left">put(e)</td>
<td align="left">offer(e, time, unit)</td>
</tr>
<tr>
<td align="left">移除方法</td>
<td align="left">remove()</td>
<td align="left">poll()</td>
<td align="left">take()</td>
<td align="left">poll(time, unit)</td>
</tr>
<tr>
<td align="left">检查方法</td>
<td align="left">element()</td>
<td align="left">peek()</td>
<td align="left">不可用</td>
<td align="left">不可用</td>
</tr>
</tbody></table>
<p>🦅 <strong>ArrayBlockingQueue 与 LinkedBlockingQueue 的区别？</strong></p>
<table>
<thead>
<tr>
<th align="left">Queue</th>
<th align="left">阻塞与否</th>
<th align="left">是否有界</th>
<th align="left">线程安全保障</th>
<th align="left">适用场景</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ArrayBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">有界</td>
<td align="left">一把全局锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）</td>
</tr>
<tr>
<td align="left">LinkedBlockingQueue</td>
<td align="left">阻塞</td>
<td align="left">可配置</td>
<td align="left">存取采用 2 把锁</td>
<td align="left">生产消费模型，平衡两边处理速度</td>
<td align="left">无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加 JVM 垃圾回收的负担。</td>
</tr>
</tbody></table>
<p>感兴趣的胖友，可以看看如下两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b85c1794351">《ArrayBlockingQueue 与 LinkedBlockingQueue》</a></li>
<li><a target="_blank" rel="noopener" href="http://hellojava.info/?p=464">《从一个故障说说 Java 的三个 BlockingQueue》</a></li>
</ul>
<h2 id="什么是双端队列？"><a href="#什么是双端队列？" class="headerlink" title="什么是双端队列？"></a>什么是双端队列？</h2><p>在上面，我们看到的 LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等，都是阻塞队列。</p>
<p>而 ArrayDeque、LinkedBlockingDeque 就是双端队列，类名以 Deque 结尾。</p>
<ul>
<li>正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。<ul>
<li>如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。</li>
<li>在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。</li>
</ul>
</li>
<li>适用于：网页爬虫等任务中</li>
</ul>
<blockquote>
<p>😈 实际场景下，双端队列，我们使用比较少。艿艿根本没用过。</p>
</blockquote>
<h2 id="延迟队列的实现方式，DelayQueue-和时间轮算法的异同？"><a href="#延迟队列的实现方式，DelayQueue-和时间轮算法的异同？" class="headerlink" title="延迟队列的实现方式，DelayQueue 和时间轮算法的异同？"></a>延迟队列的实现方式，DelayQueue 和时间轮算法的异同？</h2><p>JDK 的 Timer 和 DelayQueue 插入和删除操作的平均时间复杂度为 <code>O(nlog(n))</code> ，而基于时间轮可以将插入和删除操作的时间复杂度都降为 <code>O(1)</code> 。</p>
<ul>
<li>关于 DelayQueue 的实现方式，在 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》》</a> 。</li>
<li>关于实践论的实现方法，在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/80697456">《Kafka解惑之时间轮（TimingWheel）》</a> 。</li>
</ul>
<h2 id="简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？"><a href="#简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？" class="headerlink" title="简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？"></a>简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？</h2><p>参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1a49293294aa">《LinkedBlockingQueue 和 ConcurrentLinkedQueue的用法及区别》</a> 。</p>
<p>在 Java 多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列(先进先出)。</p>
<p>Java 提供的线程安全的 Queue 可以分为</p>
<ul>
<li><p>阻塞队列，典型例子是 LinkedBlockingQueue 。</p>
<blockquote>
<p>适用阻塞队列的好处：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。</p>
</blockquote>
</li>
<li><p>非阻塞队列，典型例子是 ConcurrentLinkedQueue 。</p>
<blockquote>
<p>当许多线程共享访问一个公共集合时，<code>ConcurrentLinkedQueue</code> 是一个恰当的选择。</p>
</blockquote>
</li>
</ul>
<p>具体的选择，如下：</p>
<ul>
<li>LinkedBlockingQueue 多用于任务队列。<ul>
<li>单生产者，单消费者</li>
<li>多生产者，单消费者</li>
</ul>
</li>
<li>ConcurrentLinkedQueue 多用于消息队列。<ul>
<li>单生产者，多消费者</li>
<li>多生产者，多消费者</li>
</ul>
</li>
</ul>
<h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。</p>
<ul>
<li>处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。</li>
<li>在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。CAS操作 —— Compare &amp; Set ，或是 Compare &amp; Swap ，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</li>
</ul>
<p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<ul>
<li><code>int++</code> 并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原子的，在 JDK5 之前我们可以使用同步技术来做到这一点。到 JDK5 后，<code>java.util.concurrent.atomic</code> 包提供了 <code>int</code> 和 <code>long</code> 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</li>
</ul>
<p><code>java.util.concurrent</code> 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p>
<ul>
<li>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 。</li>
<li>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 。</li>
<li>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 。</li>
<li>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个<code>boolean</code> 来反映中间有没有变过），AtomicStampedReference（通过引入一个 <code>int</code> 来累加来反映中间有没有变过）。</li>
</ul>
<p>关于 CAS 的内容，建议胖友在看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CAS/">《【死磕 Java 并发】—- 深入分析 CAS》</a> 。</p>
<h2 id="CAS-操作有什么缺点？"><a href="#CAS-操作有什么缺点？" class="headerlink" title="CAS 操作有什么缺点？"></a>CAS 操作有什么缺点？</h2><p>1）<strong>ABA 问题</strong></p>
<p>比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。</p>
<p>从 Java5 开始 JDK 的 <code>atomic</code>包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2）<strong>循环时间长开销大</strong></p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 <code>synchronized</code> 。</p>
<p>3）<strong>只能保证一个共享变量的原子操作</strong></p>
<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<h2 id="Semaphore-是什么？"><a href="#Semaphore-是什么？" class="headerlink" title="Semaphore 是什么？"></a>Semaphore 是什么？</h2><p>Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。</p>
<ul>
<li>如有必要，在许可可用前会阻塞每一个 <code>#acquire()</code> 方法，然后再获取该许可。</li>
<li>每个 <code>#release()</code> 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。</li>
</ul>
<p>信号量常常用于多线程的代码中，比如数据库连接池。</p>
<ul>
<li>使用方式，可以看看 <a target="_blank" rel="noopener" href="https://my.oschina.net/cloudcoder/blog/362974">《JAVA多线程 – 信号量(Semaphore)》</a> 。</li>
<li>源码解析，可以看看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Semaphore/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Semaphore》</a> 。</li>
</ul>
<h2 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h2><p>CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。</p>
<p>CountDownLatch 默认的构造方法是 <code>CountDownLatch(int count)</code> ，其参数表示需要减少的计数，主线程调用 <code>#await()</code> 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，然后其它线程调用 CountDownLatch 的 <code>#countDown()</code> 方法，减小计数(不会阻塞)。等待计数被减少到零，主线程结束阻塞等待，继续往下执行。</p>
<ul>
<li>CountDownLatch 的使用示例，请看 <a target="_blank" rel="noopener" href="https://zk1878.iteye.com/blog/1002652">《Java 多线程 CountDownLatch 用法》</a> 。</li>
<li>CountDownLatch 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CountDownLatch/?vip">《【死磕 Java 并发】—– J.U.C 之并发工具类：CountDownLatch》</a></li>
</ul>
<h2 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h2><p>CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，其参数表示屏障拦截的线程数量，每个线程调用 <code>#await()</code> 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞，直到 <code>parties</code> 个线程到达，结束阻塞。</p>
<ul>
<li>CyclicBarrier 的使用示例，请看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuling/p/2013-8-21-01.html">《CyclicBarrier 的用法》</a></li>
<li>CyclicBarrier 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/CyclicBarrier/?vip">《【死磕 Java 并发】—- J.U.C 之并发工具类：CyclicBarrier》</a> 。</li>
</ul>
<h2 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h2><p>实际场景下，问了一圈朋友，Exchanger 基本没在业务中使用过。</p>
<ul>
<li>Exchanger 的使用示例，请看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/eson_15/article/details/51581842">《【Java并发】线程同步工具Exchanger的使用》</a> 。</li>
<li>Exchanger 的源码解析，请看 <a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/Exchanger/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Exchanger》</a></li>
</ul>
<h2 id="CyclicBarrier-和-CountdownLatch-有什么区别？"><a href="#CyclicBarrier-和-CountdownLatch-有什么区别？" class="headerlink" title="CyclicBarrier 和 CountdownLatch 有什么区别？"></a>CyclicBarrier 和 CountdownLatch 有什么区别？</h2><p>CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</p>
<ul>
<li>CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。<ul>
<li>你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 <code>#await()</code> 方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier 。</li>
<li>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 <code>#await()</code> 方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 <code>#countDown()</code> 方法，这个调用 <code>#await()</code> 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。</li>
</ul>
</li>
<li>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环的 barrier 。</li>
</ul>
<p>整理表格如下：</p>
<table>
<thead>
<tr>
<th align="left">CountDownLatch</th>
<th align="left">CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td align="left">减计数方式</td>
<td align="left">加计数方式</td>
</tr>
<tr>
<td align="left">计算为 0 时释放所有等待的线程</td>
<td align="left">计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td align="left">计数为 0 时，无法重置</td>
<td align="left">计数达到指定值时，计数置为 0 重新开始</td>
</tr>
<tr>
<td align="left">调用 <code>#countDown()</code> 方法计数减一，调用 <code>#await()</code> 方法只进行阻塞，对计数没任何影响</td>
<td align="left">调用 <code>#await()</code> 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td align="left">不可重复利用</td>
<td align="left">可重复利用</td>
</tr>
</tbody></table>
<h2 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h2><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<h3 id="为什么使用-Executor-框架？"><a href="#为什么使用-Executor-框架？" class="headerlink" title="为什么使用 Executor 框架？"></a>为什么使用 Executor 框架？</h3><ol>
<li>每次执行任务创建线程 <code>new Thread()</code> 比较消耗性能，创建一个线程是比较耗时、耗资源的。</li>
<li>调用 <code>new Thread()</code> 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li>
<li>接使用 <code>new Thread()</code> 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li>
</ol>
<h3 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h3><ul>
<li>Executors 是 Executor 的工具类，不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象，能执行我们的线程任务。<ul>
<li>ExecutorService 接口，继承了 Executor 接口，并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。<ul>
<li>使用 ThreadPoolExecutor ，可以创建自定义线程池。</li>
</ul>
</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 <code>#get()</code> 方法，获取计算的结果。</li>
</ul>
</li>
</ul>
<h2 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3932921.html">《Java并发编程：线程池的使用》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadPool-core/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：线程池的基础架构》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ThreadPoolExecutor》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/JUC/sike/ScheduledThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ScheduledThreadPoolExecutor》</a></li>
</ul>
<h2 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h2><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<blockquote>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
</blockquote>
<ul>
<li>普通任务线程池<ul>
<li>1、#newFixedThreadPool(int nThreads)方法，创建一个固定长度的线程池。<ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
<li>2、#newCachedThreadPool()方法，创建一个可缓存的线程池。<ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
<li>3、#newSingleThreadExecutor()方法，创建一个单线程的线程池。<ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
</li>
<li>定时任务线程池<ul>
<li>4、<code>#newScheduledThreadPool(int corePoolSize)</code> 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li>5、<code>#newSingleThreadExecutor()</code> 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
</li>
</ul>
<h3 id="如何使用-ThreadPoolExecutor-创建线程池？"><a href="#如何使用-ThreadPoolExecutor-创建线程池？" class="headerlink" title="如何使用 ThreadPoolExecutor 创建线程池？"></a>如何使用 ThreadPoolExecutor 创建线程池？</h3><p>Executors 提供了创建线程池的常用模板，实际场景下，我们可能需要自动以更灵活的线程池，此时就需要使用 ThreadPoolExecutor 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ThreadPoolExecutor.java</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 参数，核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行任务。</li>
<li>maximumPoolSize参数，最大线程数， 当线程数 &gt;= corePoolSize 的时候，会把任务放入workQueue 队列中。</li>
<li>keepAliveTime 参数，保持存活时间，当线程数大于 <code>corePoolSize</code> 的空闲线程能保持的最大时间。</li>
<li>unit 参数，时间单位。</li>
<li>workQueue 参数，保存任务的阻塞队列。</li>
<li>handler 参数，超过阻塞队列的大小时，使用的拒绝策略。</li>
<li>threadFactory 参数，创建线程的工厂。</li>
</ul>
<h3 id="ThreadPoolExecutor-有哪些拒绝策略？"><a href="#ThreadPoolExecutor-有哪些拒绝策略？" class="headerlink" title="ThreadPoolExecutor 有哪些拒绝策略？"></a>ThreadPoolExecutor 有哪些拒绝策略？</h3><p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy()</code> ，直接抛出异常 RejectedExecutionException 。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy()</code> ，直接调用 run 方法并且阻塞执行。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy()</code> ，直接丢弃后来的任务。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy()</code> ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。</p>
<h2 id="线程池的关闭方式有几种？"><a href="#线程池的关闭方式有几种？" class="headerlink" title="线程池的关闭方式有几种？"></a>线程池的关闭方式有几种？</h2><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：</p>
<ul>
<li><code>#shutdown()</code> 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li><code>#shutdownNow()</code> 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
<p>实际场景下，一般会结合这两个方法，一起实现线程池的优雅关闭。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void shutdownAndAwaitTermination(ExecutorService pool) &#123;</span><br><span class="line">  pool.shutdown(); &#x2F;&#x2F; Disable new tasks from being submitted</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; Wait a while for existing tasks to terminate</span><br><span class="line">    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) &#123;</span><br><span class="line">      pool.shutdownNow(); &#x2F;&#x2F; Cancel currently executing tasks</span><br><span class="line">      &#x2F;&#x2F; Wait a while for tasks to respond to being cancelled</span><br><span class="line">      if (!pool.awaitTermination(60, TimeUnit.SECONDS))</span><br><span class="line">          System.err.println(&quot;Pool did not terminate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">    &#x2F;&#x2F; (Re-)Cancel if current thread also interrupted</span><br><span class="line">    pool.shutdownNow();</span><br><span class="line">    &#x2F;&#x2F; Preserve interrupt status</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-线程池大小为何会大多被设置成-CPU-核心数-1-？"><a href="#Java-线程池大小为何会大多被设置成-CPU-核心数-1-？" class="headerlink" title="Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？"></a>Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？</h2><p>详细的可以看看 <a target="_blank" rel="noopener" href="http://ifeve.com/how-to-calculate-threadpool-size/">《如何合理地估算线程池大小？》</a> 。如下是简单的总结和整理：</p>
<p>一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数）</p>
<ul>
<li><p>如果是 CPU 密集型应用，则线程池大小设置为 N+1</p>
<blockquote>
<p>因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</p>
</blockquote>
</li>
<li><p>如果是 IO 密集型应用，则线程池大小设置为 2N+1</p>
<blockquote>
<p>IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。</p>
</blockquote>
</li>
<li><p>如果是混合型应用，那么分别创建线程池</p>
<blockquote>
<p>可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。</p>
<p>因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
</blockquote>
</li>
</ul>
<p>如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p>
<p>但是，IO 优化中，这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间 + 线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目<br><strong>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>
<p>下面举个例子：比如平均每个线程 CPU 运行时间为 0.5s ，而线程等待时间（非 CPU 运行时间，比如 IO）为 1.5s ，CPU 核心数为 8 。<br>那么根据上面这个公式估算得到：<code>((0.5 + 1.5) / 0.5) * 8 = 32</code>。这个公式进一步转化为：最佳线程数目 = （线程等待时间与线程 CPU 时间之比 + 1）* CPU数目。</p>
<h3 id="线程池容量的动态调整？"><a href="#线程池容量的动态调整？" class="headerlink" title="线程池容量的动态调整？"></a>线程池容量的动态调整？</h3><p>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：</p>
<ul>
<li>setCorePoolSize：设置核心池大小。</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
<p>当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h2 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h2><p>1）<strong>Callable</strong></p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<blockquote>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
</blockquote>
<p>2）<strong>Future</strong></p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p>3）<strong>FutureTask</strong></p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h2 id="线程池执行任务的过程？"><a href="#线程池执行任务的过程？" class="headerlink" title="线程池执行任务的过程？"></a>线程池执行任务的过程？</h2><p>刚创建时，里面没有线程调用 execute() 方法，添加任务时：</p>
<ol>
<li>如果正在运行的线程数量小于核心参数 corePoolSize，继续创建线程运行这个任务<ul>
<li>否则，如果正在运行的线程数量大于或等于 <code>corePoolSize</code> ，将任务加入到阻塞队列中。</li>
<li>否则，如果队列已满，同时正在运行的线程数量小于核心参数 <code>maximumPoolSize</code> ，继续创建线程运行这个任务。</li>
<li>否则，如果队列已满，同时正在运行的线程数量大于或等于 <code>maximumPoolSize</code> ，根据设置的拒绝策略处理。</li>
</ul>
</li>
<li>完成一个任务，继续取下一个任务处理。<ul>
<li>没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。</li>
<li>否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 <code>corePoolSize</code> 。</li>
</ul>
</li>
</ol>
<h3 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit 和 execute 方法有什么区别？"></a>线程池中 submit 和 execute 方法有什么区别？</h3><p>两个方法都可以向线程池提交任务。</p>
<ul>
<li><code>#execute(...)</code> 方法，返回类型是 <code>void</code> ，它定义在 Executor 接口中。</li>
<li><code>#submit(...)</code> 方法，可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
<h3 id="如果你提交任务时，线程池队列已满，这时会发生什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么？"></a>如果你提交任务时，线程池队列已满，这时会发生什么？</h3><blockquote>
<p>艿艿：重点在于线程池的队列是有界还是无界的。</p>
</blockquote>
<ul>
<li>如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。</li>
<li>如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 。</li>
</ul>
<h2 id="Fork-Join-框架是什么？"><a href="#Fork-Join-框架是什么？" class="headerlink" title="Fork/Join 框架是什么？"></a>Fork/Join 框架是什么？</h2><blockquote>
<p>艿艿：这是，可能了解的人不多，我也是。大体知道就好。</p>
</blockquote>
<p>Oracle 的官方给出的定义是：Fork/Join 框架是一个实现了 ExecutorService接口 的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。</p>
<p>我们再通过 Fork 和 Join 这两个单词来理解下 Fork/Join 框架。</p>
<ul>
<li>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li>比如计算 <code>1+2+...＋10000</code> ，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</li>
</ul>
<p>感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/index.html">《JDK 7 中的 Fork/Join 模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/fork-join-introduction">《聊聊并发（八） —— Fork/Join 框架介绍》</a></li>
</ul>
<h2 id="如何让一段程序并发的执行，并最终汇总结果？"><a href="#如何让一段程序并发的执行，并最终汇总结果？" class="headerlink" title="如何让一段程序并发的执行，并最终汇总结果？"></a>如何让一段程序并发的执行，并最终汇总结果？</h2><ul>
<li><p>1、CountDownLatch：允许一个或者多个线程等待前面的一个或多个线程完成，构造一个 CountDownLatch 时指定需要 countDown 的点的数量，每完成一点就 countDown 一下。当所有点都完成，CountDownLatch 的 <code>#await()</code> 就解除阻塞。</p>
</li>
<li><p>2、CyclicBarrier：可循环使用的 Barrier ，它的作用是让一组线程到达一个 Barrier 后阻塞，直到所有线程都到达 Barrier 后才能继续执行。</p>
<blockquote>
<p>CountDownLatch 的计数值只能使用一次，CyclicBarrier 可以通过使用 reset 重置，还可以指定到达栅栏后优先执行的任务。</p>
</blockquote>
</li>
<li><p>3、Fork/Join 框架，fork 把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fatefrank.github.io/2020/07/26/Java%E3%80%90%E9%9B%86%E5%90%88%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Seif Zheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seif Zheng's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/Java%E3%80%90%E9%9B%86%E5%90%88%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java【集合】面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-26T00:00:00+08:00">2020-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-05 16:48:30" itemprop="dateModified" datetime="2020-08-05T16:48:30+08:00">2020-08-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java-集合框架有哪些？"><a href="#Java-集合框架有哪些？" class="headerlink" title="Java 集合框架有哪些？"></a>Java 集合框架有哪些？</h2><h3 id="说出一些集合框架的优点？"><a href="#说出一些集合框架的优点？" class="headerlink" title="说出一些集合框架的优点？"></a>说出一些集合框架的优点？</h3><p>集合框架的部分优点如下：</p>
<ul>
<li>1、使用核心集合类降低开发成本，而非实现我们自己的集合类。</li>
<li>2、随着使用经过严格测试的集合框架类，代码质量会得到提高。</li>
<li>3、通过使用 JDK 附带的集合类，可以降低代码维护成本。</li>
<li>4、复用性和可操作性。</li>
</ul>
<h3 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h3><p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。</p>
<p>泛型也使得代码整洁，我们不需要使用显式转换和 <code>instanceOf</code> 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h2 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h2><ul>
<li>Collection ，为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。<ul>
<li>Set ，是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</li>
<li>List ，是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</li>
</ul>
</li>
<li>Map ，是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</li>
<li>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。</li>
</ul>
<h3 id="为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h3><p>Collection 接口指定一组对象，对象即为它的元素。</p>
<ul>
<li>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。</li>
<li>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</li>
</ul>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制，<strong>特定的实现应该决定它是否可以被克隆和序列化</strong>。</p>
<h3 id="为何-Map-接口不继承-Collection-接口？"><a href="#为何-Map-接口不继承-Collection-接口？" class="headerlink" title="为何 Map 接口不继承 Collection 接口？"></a>为何 Map 接口不继承 Collection 接口？</h3><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。</p>
<p>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合“一组对象”规范。</p>
<h3 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h3><ul>
<li>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。</li>
<li>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h3 id="集合框架里实现的通用算法有哪些？"><a href="#集合框架里实现的通用算法有哪些？" class="headerlink" title="集合框架里实现的通用算法有哪些？"></a>集合框架里实现的通用算法有哪些？</h3><p>Java 集合框架提供常用的算法实现，比如排序和搜索。</p>
<p>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p>1）List</p>
<ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
<p>2）Map</p>
<ul>
<li>HashMap ：<ul>
<li>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
<li>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
</li>
<li>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a> 。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ul>
<p>3）Set</p>
<ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
<h2 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h2><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 <code>#remove(Object Obj)</code> 方法删除，可以通过迭代器的 <code>#remove()</code> 方法删除。</p>
<h3 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h3><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h3 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h3><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 <code>java.util</code> 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 <code>java.util.concurrent</code> 包下的全是安全失败的。</li>
</ul>
<h3 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h3><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<p>Enumeration 和 Iterator 接口有什么不同？</p>
<ul>
<li>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。</li>
<li>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</li>
</ul>
<p>对于很多胖友，可能并未使用过 Enumeration 类，所以可以看看 <a target="_blank" rel="noopener" href="http://www.runoob.com/java/java-enumeration-interface.html">《Java Enumeration 接口》</a> 文章。</p>
<h3 id="为何-Iterator-接口没有具体的实现？"><a href="#为何-Iterator-接口没有具体的实现？" class="headerlink" title="为何 Iterator 接口没有具体的实现？"></a>为何 Iterator 接口没有具体的实现？</h3><p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。</p>
<p>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p>
<h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h2><ul>
<li>Comparable 接口，在 <code>java.lang</code> 包下，用于当前对象和其它对象的比较，所以它有一个 <code>#compareTo(Object obj)</code> 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 <code>java.util</code> 包下，用于传入的两个对象的比较，所以它有一个 <code>#compare(Object obj1, Object obj2)</code> 方法用来排序，该方法有两个参数。</li>
</ul>
<p>详细的，可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/whing123/article/details/77851737">《Java 自定义比较器》</a> 文章，重点是如何自己实现 Comparable 和 Comparator 的方法。</p>
<h3 id="compareTo-方法的返回值表示的意思？"><a href="#compareTo-方法的返回值表示的意思？" class="headerlink" title="compareTo 方法的返回值表示的意思？"></a>compareTo 方法的返回值表示的意思？</h3><ul>
<li>大于 0 ，表示对象大于参数对象。</li>
<li>小于 0 ，表示对象小于参数对象</li>
<li>等于 0 ，表示两者相等。</li>
</ul>
<h3 id="如何对-Object-的-List-排序？"><a href="#如何对-Object-的-List-排序？" class="headerlink" title="如何对 Object 的 List 排序？"></a>如何对 Object 的 List 排序？</h3><ul>
<li>对 <code>Object[]</code> 数组进行排序时，我们可以用 <code>Arrays#sort(...)</code> 方法。</li>
<li>对 <code>List</code> 数组进行排序时，我们可以用 <code>Collections#sort(...)</code> 方法。</li>
</ul>
<h2 id="有哪些关于-Java-集合框架的最佳实践？"><a href="#有哪些关于-Java-集合框架的最佳实践？" class="headerlink" title="有哪些关于 Java 集合框架的最佳实践？"></a>有哪些关于 Java 集合框架的最佳实践？</h2><ul>
<li>基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array ，而不是 ArrayList 。</li>
<li>一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。</li>
<li>总是使用泛型来保证类型安全，可靠性和健壮性。同时，使用泛型还可以避免运行时的 ClassCastException 异常。</li>
<li>在 Map 中使用 JDK 提供的不可变类作为一个 key，这样可以避免 hashcode 的实现和我们自定义类的 equals 方法。</li>
<li>应该依照接口而不是实现来编程。</li>
<li>返回零长度的集合或者数组，而不是返回一个 <code>null</code> ，这样可以防止底层集合是空的。</li>
</ul>
<h2 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h2><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</li>
</ul>
<blockquote>
<p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。</p>
<p>另外 List 支持 <code>for</code> 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
</blockquote>
<p>Set 和 List 对比：</p>
<ul>
<li>Set：检索指定的元素效率高，删除和插入效率高，插入和删除<strong>可能会</strong>引起元素位置改变。</li>
<li>List：和数组类似，List 可以动态增长，查找<strong>指定的</strong>元素效率低，插入删除指定的元素效率低，因为可能会引起其他元素位置改变。</li>
</ul>
<p>当然，如果是随机访问（指定下标），则 List 会快于 Set 。总之，什么场景下使用 Set ，什么场景下使用 List ，还是比较明确的。</p>
<h2 id="List-和-Map-区别？"><a href="#List-和-Map-区别？" class="headerlink" title="List 和 Map 区别？"></a>List 和 Map 区别？</h2><ul>
<li>List 是对象集合，允许对象重复。</li>
<li>Map 是键值对的集合，不允许 key 重复。</li>
</ul>
<h2 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h2><ul>
<li>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</li>
<li>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。</li>
<li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li>
</ul>
<p>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p>
<ul>
<li>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们</li>
<li>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</li>
<li>3、如果你要使用多维数组，使用 <code>[][]</code> 比 List 会方便。</li>
</ul>
<h2 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h3 id="适用场景分析"><a href="#适用场景分析" class="headerlink" title="适用场景分析"></a>适用场景分析</h3><ul>
<li><p>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</p>
</li>
<li><p>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</p>
<blockquote>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList 。</p>
</blockquote>
</li>
<li><p>当然，绝大数业务的场景下，使用 ArrayList 就够了。主要是，注意好避免 ArrayList 的扩容，以及非顺序的插入。</p>
</li>
</ul>
<h3 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h3><p>直接看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kuoAT/p/6771653.html">《ArrayList 动态扩容详解》</a> 文章，很详细。主要结论如下：</p>
<ul>
<li>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 <strong>1.5</strong> 倍（位运算）的比率通过 copeOf 的方式扩容。</li>
<li>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 <strong>1.5</strong> 倍。</li>
</ul>
<blockquote>
<p>重点是 1.5 倍扩容，这是和 HashMap 2 倍扩容不同的地方。</p>
</blockquote>
<h3 id="ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><a href="#ArrayList-集合加入-1-万条数据，应该怎么提高效率？" class="headerlink" title="ArrayList 集合加入 1 万条数据，应该怎么提高效率？"></a>ArrayList 集合加入 1 万条数据，应该怎么提高效率？</h3><p>ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！</p>
<p>这样就可以提高效率了~</p>
<h2 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h2><p>ArrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p>
<ul>
<li><p>1、Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 <code>synchronized</code> 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比。</p>
<blockquote>
<p>Vector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>
</blockquote>
</li>
<li><p>2、两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</p>
</li>
<li><p>3、Vector 可以设置增长因子，而 ArrayList 不可以。</p>
</li>
</ul>
<p>适用场景分析：</p>
<ul>
<li><p>1、Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。</p>
<blockquote>
<p>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。</p>
</blockquote>
</li>
<li><p>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</p>
<blockquote>
<p>这种情况下，使用 LinkedList 更合适。</p>
</blockquote>
</li>
</ul>
<h2 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h2><blockquote>
<p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。</p>
</blockquote>
<ul>
<li>Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li>
<li>2、HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li>
<li>3、HashMap 允许空键值，而 Hashtable 不允许。</li>
<li>【重点】4、HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>5、HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li>
<li>6、HashTable 中数组默认大小是 11 ，扩容方法是 <code>old * 2 + 1</code> ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。</li>
</ul>
<p>一般现在不建议用 HashTable 。主要原因是两点：</p>
<ul>
<li>一是，HashTable 是遗留类，内部实现很多没优化和冗余。</li>
<li>二是，即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable 。</li>
</ul>
<p>Hashtable 的 <code>#size()</code> 方法中明明只有一条语句 <code>&quot;return count;&quot;</code> ，为什么还要做同步？</p>
<p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 <code>#size()</code> 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 <code>count++</code> ，线程 B 就已经读取 <code>count</code> 了，那么对于线程 B 来说读取到的 <code>count</code> 一定是不准确的。</p>
<p><strong>而给 <code>#size()</code> 方法加了同步之后，意味着线程 B 调用 <code>#size()</code> 方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性</strong>。</p>
<h2 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h2><ul>
<li><p>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。</p>
</li>
<li><p>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构。</p>
<blockquote>
<p>因为不同的 key 值，可能有相同的 hashcode ，所以 value 值需要是链表结构。</p>
</blockquote>
</li>
</ul>
<p>他们的共同点都是 hash 算法实现的唯一性，他们都不能持有基本类型，只能持有对象。</p>
<blockquote>
<p>为了更好的性能，Netty 自己实现了 key 为基本类型的 HashMap ，例如 <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/collection/IntObjectHashMap.html">IntObjectHashMap</a> 。</p>
</blockquote>
<h2 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h2><ul>
<li>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 <code>O(1)</code> 。</li>
<li>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 <code>O(logn)</code> 。</li>
</ul>
<h3 id="如何决定选用-HashMap-还是-TreeMap？"><a href="#如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定选用 HashMap 还是 TreeMap？"></a>如何决定选用 HashMap 还是 TreeMap？</h3><ul>
<li>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。</li>
<li>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。</li>
</ul>
<p>基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，再将 HashMap 换为 TreeMap 进行有序 key 的遍历。</p>
<h2 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h2><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<ul>
<li><p>1、ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。</p>
<blockquote>
<p>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。</p>
</blockquote>
</li>
<li><p>2、HashMap 的键值对允许有 <code>null</code> ，但是 ConCurrentHashMap 都不允许。</p>
</li>
</ul>
<h2 id="队列和栈是什么，列出它们的区别？"><a href="#队列和栈是什么，列出它们的区别？" class="headerlink" title="队列和栈是什么，列出它们的区别？"></a>队列和栈是什么，列出它们的区别？</h2><p>栈和队列两者都被用来预存储数据。</p>
<ul>
<li>java.util.Queue是一个接口，它的实现类在Java并发包中。<ul>
<li>队列允许先进先出（FIFO）检索元素，但并非总是这样。</li>
<li>Deque 接口允许从两端检索元素。</li>
</ul>
</li>
<li>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。<ul>
<li>Stack 是一个扩展自 Vector 的类，而 Queue 是一个接口。</li>
</ul>
</li>
</ul>
<h2 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h2><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个<strong>“链表散列”</strong>。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<ul>
<li>我们使用 <code>#put(key, value)</code> 方法来存储对象到 HashMap 中，使用 <code>get(key)</code> 方法从 HashMap 中获取对象。</li>
<li>当我们给 <code>#put(key, value)</code> 方法传递键和值时，我们先对键调用 <code>#hashCode()</code> 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。</li>
</ul>
<h3 id="当两个对象的-hashCode-相同会发生什么？"><a href="#当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="当两个对象的 hashCode 相同会发生什么？"></a>当两个对象的 hashCode 相同会发生什么？</h3><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。</p>
<p>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
<h3 id="hashCode-和-equals-方法有何重要性？"><a href="#hashCode-和-equals-方法有何重要性？" class="headerlink" title="hashCode 和 equals 方法有何重要性？"></a>hashCode 和 equals 方法有何重要性？</h3><p>HashMap 使用 key 对象的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。</p>
<ul>
<li>如果这两个方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</li>
</ul>
<p>同样的，所有不允许存储重复数据的集合类都使用 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 去查找重复，所以正确实现它们非常重要。<code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法的实现，应该遵循以下规则：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> ，那么 <code>o1.hashCode() == o2.hashCode()</code> 总是为 <code>true</code> 的。</li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code> ，并不意味 <code>o1.equals(o2)</code> 会为 <code>true</code> 。</li>
</ul>
<h3 id="HashMap-默认容量是多少？"><a href="#HashMap-默认容量是多少？" class="headerlink" title="HashMap 默认容量是多少？"></a>HashMap 默认容量是多少？</h3><p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（<code>16 * 0.75 = 12</code>），一般为原内存的 2 倍。</p>
<h3 id="有哪些顺序的-HashMap-实现类？"><a href="#有哪些顺序的-HashMap-实现类？" class="headerlink" title="有哪些顺序的 HashMap 实现类？"></a>有哪些顺序的 HashMap 实现类？</h3><ul>
<li>LinkedHashMap ，是基于元素进入集合的顺序或者被访问的先后顺序排序。</li>
<li>TreeMap ，是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。</li>
</ul>
<h3 id="我们能否使用任何类作为-Map-的-key？"><a href="#我们能否使用任何类作为-Map-的-key？" class="headerlink" title="我们能否使用任何类作为 Map 的 key？"></a>我们能否使用任何类作为 Map 的 key？</h3><p>我们可以使用任何类作为 Map 的 key ，然而在使用它们之前，需要考虑以下几点：</p>
<ul>
<li><p>1、如果类重写了 equals 方法，它也应该重写 hashcode 方法。</p>
</li>
<li><p>2、类的所有实例需要遵循与 equals 和 hashcode 相关的规则。</p>
</li>
<li><p>3、如果一个类没有使用 equals ，你不应该在 hashcode 中使用它。</p>
</li>
<li><p>4、用户自定义 key 类的最佳实践是使之为不可变的，这样，hashcode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashcode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</p>
<blockquote>
<p>比如，我有一个 类MyKey ，在 HashMap 中使用它。代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传递给MyKey的name参数被用于equals()和hashCode()中</span><br><span class="line">MyKey key &#x3D; new MyKey(&#39;Pankaj&#39;); &#x2F;&#x2F;assume hashCode&#x3D;1234</span><br><span class="line">myHashMap.put(key, &#39;Value&#39;);</span><br><span class="line">&#x2F;&#x2F; 以下的代码会改变key的hashCode()和equals()值</span><br><span class="line">key.setName(&#39;Amit&#39;); &#x2F;&#x2F;assume new hashCode&#x3D;7890</span><br><span class="line">&#x2F;&#x2F;下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null</span><br><span class="line">myHashMap.get(new MyKey(&#39;Pankaj&#39;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>那就是为何 String 和 Integer 被作为 HashMap 的 key 大量使用。</p>
</li>
</ul>
<h3 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 <code>%</code> 取余的操作来实现。但是，重点来了：</p>
<ul>
<li>取余(<code>%</code>)操作中如果除数是 2 的幂次则等价于与其除数减一的与(<code>&amp;</code>)操作（也就是说 <code>hash % length == hash &amp; (length - 1)</code> 的前提是 length 是 2 的 n 次方；）。</li>
<li>并且，采用二进制位操作 <code>&amp;</code>，相对于 <code>%</code> 能够提高运算效率，</li>
</ul>
<p>这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h2 id="HashSet-的工作原理是什么？"><a href="#HashSet-的工作原理是什么？" class="headerlink" title="HashSet 的工作原理是什么？"></a>HashSet 的工作原理是什么？</h2><p>HashSet 是构建在 HashMap 之上的 Set hashing 实现类。让我们直接撸下源码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet.java</span><br><span class="line"></span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">private static final Object PRESENT &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>map</code> 属性，当我们创建一个 HashMap 对象时，其内部也会创建一个 <code>map</code> 对象。后续 HashSet 所有的操作，实际都是基于这个 <code>map</code> 之上的封装。</p>
</li>
<li><p><code>PRESENT</code> 静态属性，所有 <code>map</code> 中 KEY 对应的值，都是它，避免重复创建。</p>
</li>
<li><p>OK ，再来看一眼 add 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashSet.java</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT) &#x3D;&#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是不是一目了然。</p>
</li>
</ul>
<h3 id="HashSet-如何检查重复？"><a href="#HashSet-如何检查重复？" class="headerlink" title="HashSet 如何检查重复？"></a>HashSet 如何检查重复？</h3><blockquote>
<p>艿艿：正如我们上面看到 HashSet 的实现原理，我们自然可以推导出，HashMap 也是如何检查重复滴。</p>
</blockquote>
<p>如下摘取自 《Head First Java》 第二版：</p>
<p>当你把对象加入 HashSet 时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较。</p>
<ul>
<li>如果没有相符的 hashcode ，HashSet会假设对象没有重复出现。</li>
<li>但是如果发现有相同 hashcode 值的对象，这时会调用 equals 方法来检查 hashcode 相等的对象是否真的相同。<ul>
<li>如果两者相同，HashSet 就不会让加入操作成功。</li>
<li><strong>如果两者不同，HashSet 就会让加入操作成功</strong>。</li>
</ul>
</li>
</ul>
<h2 id="EnumSet-是什么？"><a href="#EnumSet-是什么？" class="headerlink" title="EnumSet 是什么？"></a>EnumSet 是什么？</h2><p><code>java.util.EnumSet</code> ，是使用枚举类型的集合实现。</p>
<ul>
<li>当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet 是不同步的，不允许值为 <code>null</code> 的元素。</li>
<li>它也提供了一些有用的方法，比如 <code>#copyOf(Collection c)</code>、<code>#of(E first, E... rest)</code> 和 <code>#complementOf(EnumSet s)</code> 方法。</li>
</ul>
<p>关于 EnumSet 的源码解析，见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010887744/article/details/50834738">《EnumSet 源码分析》</a> 文章。</p>
<h2 id="TreeMap-原理"><a href="#TreeMap-原理" class="headerlink" title="TreeMap 原理"></a>TreeMap 原理</h2><p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p>TODO TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</p>
<p>等到源码解析后，在进行补充。</p>
<h2 id="Java-Priority-Queue-是什么"><a href="#Java-Priority-Queue-是什么" class="headerlink" title="Java Priority Queue 是什么?"></a>Java Priority Queue 是什么?</h2><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素都以他们的自然顺序有序排列。</p>
<ul>
<li>在它创建的时候，我们可以可以提供一个比较器 Comparator 来负责PriorityQueue 中元素的排序。</li>
<li>PriorityQueue 不允许 `` null元素，不允许不提供自然排序的对象，也不允许没有任何关联 Comparator 的对象。</li>
<li>最后，PriorityQueue 不是线程安全的，在执行入队和出队操作它需要 <code>O(log(n))</code> 的时间复杂度。</li>
</ul>
<h3 id="poll-方法和-remove-方法的区别？"><a href="#poll-方法和-remove-方法的区别？" class="headerlink" title="poll 方法和 remove 方法的区别？"></a>poll 方法和 remove 方法的区别？</h3><p>poll 和 remove 方法，都是从队列中取出一个元素，差别在于：</p>
<ul>
<li>poll 方法，在获取元素失败的时候会返回空</li>
<li>remove() 方法，失败的时候会抛出异常。</li>
</ul>
<h3 id="LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>LinkedHashMap 和 PriorityQueue 的区别是什么？</h3><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，LinkedHashMap 维持的顺序是元素插入的顺序。</li>
<li>当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Seif Zheng"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Seif Zheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fatefrank" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fatefrank" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:astutenicol@gmail.com" title="E-Mail → mailto:astutenicol@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Seif Zheng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
